1.Introduction														[18-SEP-2022]  (Done)
2.Mockito Mock creation                     						[19-SEP-2022]  (Done)
3.Mockito behavior verification             						[19-SEP-2022]  (Done)
4.Mockito verify interaction                						[19-SEP-2022]  (Done)
5.Mockito Stub Concrete Class               						[19-SEP-2022]  (Done)
6.Mockito Spy                               						[19-SEP-2022]  (Done)
7.Mockito InjectMocks												[19-SEP-2022]  ()
8.Mockito Mock Void Method                  						[22-SEP-2022]  (Done)
9.Mockito Mock Static Method                						[19-SEP-2022]  ()
10.Mockito Argument Matchers                						[19-SEP-2022]  ()
11.Mockito Argument Captor  (davidvlijmincx)                 		[19-SEP-2022]  ()
12.Mockito Iterator                         						[19-SEP-2022]  ()
13.Difference between thenReturn and thenAnswer(stacktraceguru)		[19-SEP-2022]  ()
14.do When (stacktraceguru)											[19-SEP-2022]  ()


************************************************* 1.Introduction ***********************************************************

Mockito is a Java based mocking framework ans is used in conjuction with other Testing Frameworks such as Junit and TestNG.
Mockito internally uses Java Reflection API and allows us to create Objects of an service.
Mock obejct returns dummy data and avoids external dependencies.
Mockito simplifies the development of the Test cases by mocking the external dependencies.

To implement mockito based Test cases into our project we need to add the below dependencies.
mockito-core
mockito-junit-jupiter

************************************************* 2.Mockito Mock creation  **************************************************

Mockito framework allows us to create Mock Objects either by using 

@ExtendWith(MockitoExtension.class)
@Mock Annotation
mock() method.

	class CalcServiceOneTest {

	@Test
	void calcTest() {
		CalcService calcService;
		AddService addService;

		addService = Mockito.mock(AddService.class);
		calcService = new CalcService(addService);

		int num1 = 11;
		int num2 = 12;
		int expected = 23;

		when(addService.add(num1, num2)).thenReturn(expected);
		int actual = calcService.calc(num1, num2);
		assertEquals(expected, actual);
	}
	}
	
	@ExtendWith(MockitoExtension.class)
	public class CalcServiceTwoTest {

	@InjectMocks
	CalcService calcService;

	@Mock
	AddService addService;

	@Test
	void calcTest() {
		int num1 = 11;
		int num2 = 12;
		int expected = 23;

		when(addService.add(num1, num2)).thenReturn(expected);
		int actual = calcService.calc(num1, num2);
		assertEquals(expected, actual);
	}
	}

Note :
------
To initialize the mocks that are annotated with @Mock,@Spy,@Captor or @InjectMocks we use @ExtendWith(MockitoExtension.class) at Class Level.

************************************************* 3.Mockito behavior verification  ************************************************* 

To add a behavior to the mocked class we use when() and thenReturn() functions.
It means that when the Mock object is called for the method,it should return the value stored in the expected variable.
Here CalcService has dependency on AddService.It uses AddService method to perform its operation.
Since we are doing the Unit Testing for CalcService,we have to mock the AddService instance.

		when(addService.add(num1, num2)).thenReturn(expected);
		
************************************************* 4.Mockito verify interaction  ****************************************************

Mockito framework keeps track of all the method calls and their parameters to the Mock Object.
verify() on the Mock Object verifies that the method is called with right parameters.
We can also specify the number of invocation logic.
We can use VerificationModeFactory for number of invocation times logic.

	@Test
	public void testMethod() {
		@SuppressWarnings("unchecked")
		List<String> mockedList = Mockito.mock(List.class);

		mockedList.add("first-element");
		mockedList.add("second-element");
		mockedList.add("third-element");
		mockedList.add("third-element");
		mockedList.clear();

		verify(mockedList).add("first-element");
		verify(mockedList).add("second-element");
		verify(mockedList, VerificationModeFactory.times(2)).add("third-element");

		verify(mockedList).clear();
	}
	
************************************************* 5.Mockito Stub Concrete Class **************************************************

To add a behavior to the mocked class we use when() and thenReturn() fucntions.
Using when() and thenReturn() functions we can also Mock the concrete/implementation class and also single element of a collection.

	@SuppressWarnings("unchecked")
	List<String> mockedList = Mockito.mock(List.class);

	@Test
	void testStub() {
		when(mockedList.get(0)).thenReturn("first-element");
		System.out.println(mockedList.get(0));
		assertEquals(mockedList.get(0), "first-element");
		System.out.println(mockedList.get(1));
	}
	
************************************************* 6.Mockito Spy *****************************************************************

Whenever we call the method of a spied Object,real Method will be called unless predefined behavior was defined.
If the behavior is defined using when() and thenReturn(),then it won't call the actual method call.

	@Test
	void testSpy() {
		List<String> list = new ArrayList<>();
		List<String> listSpy = spy(list);

		listSpy.add("spy-element");
		System.out.println(listSpy.get(0));
		assertEquals("spy-element", listSpy.get(0));
		
		when(listSpy.get(0)).thenReturn("second-element");
		assertEquals("second-element", listSpy.get(0));
	}

************************************************* 7.Mockito InjectMocks	**********************************************************


************************************************* 8.Mockito Mock Void Method *****************************************************

Most of the times we use Mockito when() and is good enough to mock an object behavior.
But when we have to mock the void method then in this case we can't use when().
Mockito provides the following methods that can be used to mock void methods.

doAnswer(Answer)
doThrow()
doNothing()
doCallRealMethod()

1.doAnswer() :
--------------
Whenever we want to stub a void method to let it perform the other behavior i.e. we use Mockito's doAnswer() to change the behavior.

	@Test
	void mockitoDoAnswerTest() {
		doAnswer((i) -> {
			System.out.println("Employee Name is " + i.getArgument(0));
			assertTrue("Bhaumik".equals(i.getArgument(0)));
			return null;
		}).when(employee).setName(ArgumentMatchers.anyString());
		employee.setName("Bhaumik");
	}

2.doThrow() :
-------------
we use doThrow() whenever we want to stub a void method that has to throw an Exception.

	@Test
	void mockitoDoThrowTest() {
		doThrow(IllegalArgumentException.class).when(employee).setName(null);
		assertThrows(IllegalArgumentException.class, () -> employee.setName(null));
	}
	

3.doNothing() :
---------------
If we want to completely ignore the void method call we use doNothing().
In Mocking,for every method of Mocked Object doNothing() is the default behavior.

	@Test
	void mockitoDoNothingTest() {
		doNothing().when(employee).setName(null);
		employee.setName(null);
	}
	
4.doCallRealMethod() :
----------------------
Sometime sit is necessary to call the real method from the mocked Object.
In such cases we use doCallRealMethod().
Default is the doNothing() behavior.

	@Test
	void mockitoCallRealMethodTest() {
		doCallRealMethod().when(employee).setName("Bhaumik");
		employee.setName("Bhaumik");
	}
	
*************************************************  9.Mockito Mock Static Method  *******************************************************













