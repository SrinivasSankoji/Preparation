1.Junit5 with Maven											 [03-SEP-2022]  ()
2.Junit5 with Gradle                                         [03-SEP-2022]  ()
3.Display Name for Tests                                     [03-SEP-2022]  ()
4.@Test Instance                                             [03-SEP-2022]  ()
5.Assumptions Class Example                                  [03-SEP-2022]  ()
6.@Disabled Example                                          [03-SEP-2022]  ()
7.Conditional Test                                           [03-SEP-2022]  ()
8.Repeated Test                                              [03-SEP-2022]  ()
9.Timeout                                                    [03-SEP-2022]  ()
10.Order of Test                                             [03-SEP-2022]  ()
11.Parameterized Test                                        [08-SEP-2022]  (Done)
12.Console Launcher                                          [03-SEP-2022]  (Done)
13.Allure Reports                                            [03-SEP-2022]  ()
14.Dynamic Tests                                             [03-SEP-2022]  (Done)
15.Nested Tests                                              [03-SEP-2022]  ()
16.Parameter Resolver and Dependency Injection               [03-SEP-2022]  ()
17.@Tag Annotation                                           [03-SEP-2022]  ()
18.Paralell Execution                                        [03-SEP-2022]  ()
19.SpringBoot Junit5                                         [03-SEP-2022]  ()
20.JunitPlatform Runner                                      [03-SEP-2022]  ()


********************************************************** 5.Assumptions Class Example **************************************************************


********************************************************** 6.@Disabled Example  *********************************************************************


********************************************************** 7.Conditional Test ***********************************************************************


********************************************************** 8.Repeated Test **************************************************************************


********************************************************** 9.Timeout ********************************************************************************


********************************************************** 10.Order of Test *************************************************************************


********************************************************** 11.Parameterized Test ********************************************************************

Sometimes we may need to run the same test with different parameters or different values.
Parameterized Test makes it posssible to run the test multiple times with different arguments.
Parameterized Test can be declared by using the Annotation @ParameterizedTest instead of @Test Annotation.

	@ParameterizedTest
	@ValueSource(ints = { 2, 4, 6, 8, 10 })
	void testArrayWithParameters(int arguments) {
		System.out.println("Parameterized Test with Integer Array " + arguments);
	}
	
We can also customize the display name of the Parameterized Test.
By default display name of the Parameterized Test invocation contains the invocation index and the String representation of all the arguments for the specific invocation.
	
	@ParameterizedTest(name = "{index}.testArrayWithParameters with value - {arguments} ")
	@ValueSource(ints = { 2, 4, 6, 8, 10 })
	void testArrayWithParameters(int arguments) {
		System.out.println("Parameterized Test with Integer Array " + arguments);
	}
	
Here index starts with 1.
	
@valueSource Arguments :
------------------------
@valueSource allows us to specify the Single Array of literal values and can be used only for providing for single argument for ParameterizedTest invocation.
We can also pass Empty and Null Parameters using @EmptySource and @NullSource Annotations.

	@ParameterizedTest(name = "{index} With String argument {0}")
	@ValueSource(strings = { "Peter King", "Arthur King", "Martin King" })
	void testWithStringParameters(String input) {
		String searchKey = "King";
		System.out.println("String Arguments :" + input);
		assertTrue(input.contains(searchKey));
	}
	
@EnumSource Arguments :
-----------------------
@EnumSource provides a convinient way to use Enum Constants.
@EnumSource provides an optional names attribute that allows us to specify which constants it should consider.
By default names attribute will keep only the matched Enum Constants.
We can use the mode attribute which supports EXCLUDE,INCLUDE,MATCH_ALL,MATCH_ANY.

	@ParameterizedTest(name = "{index} Enum values are : {arguments}")
	@EnumSource(value = Role.class, names = { "ADMIN", "SUBSCRIBER" })
	void testWithEnumParameters(Role role) {
		assertNotNull(role);
	}

@MethodSource Arguments :
-------------------------
By using @ValueSource or @EnumSource it is not possible to pass complex type as an argument.
@MethodSource allows us to pass the Factory Methods of the Test class as an argument. 
Here Factory Method should be static and it does not accept any argument.
Every Factory Method should generate stream of arguments and each set of values will be provided to the Test Method.
If we do not provide the Factory Method to the @MethodSource,It will search for the Factory Method with the same name as ParameterizedTest.

	@ParameterizedTest(name = "{index} Method Source with parameters {arguments}")
	@MethodSource("getNames")
	void testWithMethodSource(String arguments) {
		assertNotNull(arguments);
	}

	static Stream<String> getNames() {
		return Stream.of("ADMIN", "SUBSCRIBER", "OBSERVER", "AUTHOR", "PUBLISHER", "ANONYMOUS");
	}
	
	@ParameterizedTest(name = "{index} Method with Multiple Paraeters {arguments}")
	@MethodSource
	void stringIntAndListProvider(String str, int num, List<String> list) {
		System.out.println("str => " + str + "; num =>" + num + "; list => " + list);
		assertTrue(str.length() > 0);
		assertTrue(num >= 1 && num <= 3);
		assertTrue(!list.isEmpty());
	}
	
	static Stream<Arguments> stringIntAndListProvider() {
		return Stream.of(Arguments.arguments("Peter", 1, Arrays.asList("admin", "author")));
	}

@CSVSource Arguments :
----------------------
@ValueSource and @EnumSource does not allow us to provide Multiple Parameters for Parameterized Test.
@CSVSource allow us to provide argument list as comma seperated values.
@CSVSource accepts an Array of comma seperated values and each entry corresponds to a line in a CSV File.

	@ParameterizedTest
	@CsvSource({"Bhaumik,Chary,23", "Aadvik,Chary,15"})
	void testWithCSVSource(String firstName, String lastName, Integer dateOfBirth) {
		assertTrue(firstName != null);
		assertTrue(lastName != null);
		assertTrue(dateOfBirth > 0);
	}

@CSVFileSource Arguments :
--------------------------

@ArgumentSource :
-----------------
To support advanced approach,Junit5 supports custome reusable ArgumentProvider to provide Test arguments.

	@ParameterizedTest(name = "{index}. Custom Argument Provider values {arguments}")
	@ArgumentsSource(CustomArgumentProvider.class)
	void testWithArgumentSource(String name, Integer date, List<?> details) {
		assertTrue(name != null);
		assertTrue(date > 0);
		assertTrue(!details.isEmpty());
	}
	
	public class CustomArgumentProvider implements ArgumentsProvider {

	@Override
	public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) throws Exception {
		return Stream.of(Arguments.arguments("Bhaumik", 23, Arrays.asList("Aadvik", 15)));
	}
	}

@Argument Conversion :
----------------------
Impicit Conversion :
--------------------
Junit5 supports built-in implicit type conversion.
The conversion process depends on the declared type of each method parameter.
For example If we are provide Parameterized Test annotated with @ValueSource(ints={2,4,5}),then method argument can be int,long,float,double.
This is called implicit conversion.

	@ParameterizedTest(name = "{index}. Implicit Conversion for Parameter {arguments}")
	@ValueSource(strings = { "2017-11-23", "2022-04-15" })
	void testWithImplicitConversion(LocalDate localDate) {
		System.out.println("Local Date " + localDate.toString());
		assertTrue(localDate != null);
	}


Explicit Conversion :
---------------------
Instead of relying on implicit conversion,we can create explicit conversion by using ArgumentConverter and @ConvertWith Annotations.

	@ParameterizedTest(name = "{index}.Explicit Conversion for parameters {arguments}")
	@ValueSource(strings = {"23-11-2107","15-04-2021"})
	void testWithExplicitConversion(@ConvertWith(DateConverter.class) LocalDate localDate) {
		System.out.println("Local Date " + localDate.toString());
		assertTrue(localDate != null);
	}
	
	public class DateConverter implements ArgumentConverter {

	@Override
	public Object convert(Object source, ParameterContext context) throws ArgumentConversionException {
		DateTimeFormatter format = DateTimeFormatter.ofPattern("dd-MM-yyyy");
		return LocalDate.parse(source.toString(), format);
	}
	}

@Argument Accessor :
--------------------

Custom Argument Aggregators :
-----------------------------




	






********************************************************** 14.Dynamic Tests **************************************************************************

All the Tests that are annotated with @Test are static Test cases.
A Dynamic Test is a Test that is generated at runtime by factory method using @TestFactory Annotation.
The method marked with @TestFactory is not a Test case,rather it is a factory of Test Cases.

Rules to create Dynamic Tests :
-------------------------------
@TestFactory method must not be private and static.
@TestFactory method must return Stream,Collection,Iterable,Iterator or Array of Dynamic Node instances.
@TestFactory method can also return sub class of Dynamic Node i.e. they are DynamicContainer and DynamicTest.

	@TestFactory
	DynamicTest dynamicTest() {
		return DynamicTest.dynamicTest("Single Dynamic Test",
				() -> Assertions.assertEquals(25, MathUtils.addAndCheck(5, 20)));

	}
	
	@TestFactory
	List<DynamicTest> dynamicTestFromCollection() {
		List<DynamicTest> list = new ArrayList<>();
		list.add(dynamicTest("1st List<DynamicTest>", () -> Assertions.assertEquals(25, 23)));
		list.add(dynamicTest("2nd List<DynamicTest>", () -> Assertions.assertEquals(5, 5)));
		return list;
	}

	@TestFactory method must return Subclass of Dynamic Node i.e.they are DynamicContainer and DynamicTest.

	@TestFactory
	DynamicContainer dynamicTestFromContainer() {
		return DynamicContainer.dynamicContainer("Dynamic Container",
				Stream.of(DynamicTest.dynamicTest("1st Dynamic Container", () -> Assertions.assertEquals(25, 25))));
	}
	
Lifecycle methods for Dynamic tests :
-------------------------------------
In the Dynamic Test @BeforeEach and @AfterEach lifecycle methods are executed for each @TestFactory method but not for each Dynamic Tests.

	public class DynamicTestLifecycleTest {

	@BeforeEach
	public void setUp() {
		System.out.println("Before Class Execution");
	}

	@TestFactory
	List<DynamicTest> dynamicTestFromList() {
		return Arrays.asList(DynamicTest.dynamicTest("First Dynamic Test", () -> assertTrue(true)),
				DynamicTest.dynamicTest("Second Dynamic Test", () -> assertTrue(true)));
	}

	@AfterEach
	public void tearDown() {
		System.out.println("After Class Execution");
	}
	}
	
Hierarchy or nesting dynamic tests  :
-------------------------------------


Timeout in Dynamic tests :
--------------------------
Declaring @TimeOut on a @TestFactory method checks that the factory method returns within the specified duration or not 
but it does not verify the execution time of each individual DynamicTest generated by the factory.
For that purpose we use assertTimeout() or assertTimeoutPrremptively().

	@TestFactory
	Collection<DynamicTest> timeoutInDynamicTest() {
		return Arrays.asList(DynamicTest.dynamicTest("First Timeout", () -> {
			assertTimeout(Duration.ofSeconds(5), () -> TimeUnit.SECONDS.sleep(5));
		}));
	}

Execution order in dynamic tests :
----------------------------------
The execution order for the Dynamic Test does not depends on @TestMethodOrder declared on Top level Test Class.
To control the Order of Dynamic Tests we have to implement Custom Sort.

	@TestFactory
	Collection<DynamicTest> executionOrderInDynamicTest() {
		List<DynamicTest> dynamicTests = Arrays.asList(
				DynamicTest.dynamicTest("First Dynamic Test", () -> assertEquals(6, MathUtils.addAndCheck(2, 4))),
				DynamicTest.dynamicTest("Second Dynamic Test", () -> assertEquals(6, MathUtils.addAndCheck(2, 4))),
				DynamicTest.dynamicTest("Third Dynamic Test", () -> assertEquals(6, MathUtils.addAndCheck(2, 4))));
		sortDynamicTests(dynamicTests);
		return dynamicTests;
	}

	static void sortDynamicTests(List<DynamicTest> dynamicTests) {
		dynamicTests.sort((DynamicTest d1, DynamicTest d2) -> d2.getDisplayName().compareTo(d1.getDisplayName()));
	}

Parallel Test execution in Dynamic tests :
------------------------------------------


Parameterized dynamic tests :
-----------------------------
To create a Parameterized Dynamic Tests,we simply loop over the data and calls the Test Method with It.


********************************************************** 15.Nested Tests **********************************************************








	
	

	
	
	
	


 

