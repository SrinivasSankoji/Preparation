1.JVM  Architecture 					(DZone)						[29-NOV-2020]  (Done)
2.Class Loader Subsystem				(Alexander Obregon)			[01-DEC-2025]  (Done)
3.Stack Area 							(digitalocean)				[03-DEC-2025]  (Done)
4.Heap Memory 							(digitalocean)				[03-DEC-2025]  (Done)
5.Method Area 							()							[03-DEC-2025]  (Done)
6.Execution Engine 						()							[30-NOV-2020]  ()
7.PC Registers 							()							[30-NOV-2020]  ()
8.Native Method Stack 					(Kalyani Dagde)				[30-NOV-2020]  ()
9.Garbage Collection 					(Subhasis Roy)				[30-NOV-2020]  ()
10.Reference Types 						(Constantin Marian)			[30-NOV-2020]  ()		
11.Dynamic Class Loading				(DZone)						[30-NOV-2020]  (Done)
12.JDK vs JRE vs JVM 					(guru99)					[23-JAN-2021]  ()


Delegation Heirarchy
Class Level Data
Stack Frame / Stack Area
Operand Stack
Frame Data 

############################################################  1.JVM  Architecture ########################################################################

Java was developed with the concept of WORA i.e. write once and run anywhere.
Compiler compiles the .java file and generates the .class file i.e. Byte Code which is platform independent.
The same Byte Code can run on any Operating System which has JVM installed.
No need to recompile for each platform.

Bytecode is NOT machine code.
Bytecode is platform independent instruction set to understood by the JVM.
JVM converts Bytecode into machine-specific native instructions and executes them on the hardware.

JVM does not directly convert all Bytecode into machine code line-by-line.
Interpreter ‚Üí Executes Bytecode line by line
JIT Compiler ‚Üí Converts frequently executed Bytecode blocks into native machine code for faster performance.

This hybrid model provides both
Portability (Interpreter)
High performance (JIT Compiler)


			        Java Source Code (.java)
                          ‚Üì
                    javac Compiler
                          ‚Üì
                Bytecode File (.class)
                          ‚Üì
						 JVM  
                          ‚Üì
              Class Loader Subsystem
                          ‚Üì
            Load ‚Üí Verify ‚Üí Prepare ‚Üí Resolve ‚Üí Initialize
                          ‚Üì
               Runtime Data Area (Memory Setup)
						  ‚Üì
           Method Area | Heap | Stack | PC | Native Stack
                          ‚Üì
                  Execution Engine
                          ‚Üì
                Interpreter (line by line)
                          ‚Üì
             Hot code detected ‚Üí JIT Compiler
                          ‚Üì
                   Native Machine Code
                          ‚Üì (Now the program runs at near C/C++ native speed)
				Stored in Code Cache (RAM)
						  ‚Üì
                         CPU
                          ‚Üì
                         OS
                          ‚Üì
                    Program Executes
					
As a Java Developer if we know the Architecture of JVM,it helps us to write the code more efficiently.

What is JVM :
-------------
JVM is is a software-based virtual machine that :
1.Provides the runtime environment for executing Java programs.
2.Loads, verifies, links, and executes Java Bytecode.
3.Converts Bytecode into platform-specific machine code.
4.Manages Memory,Threads,Garbage Collection,Security

Component										Description
JVM										Engine that runs Java Bytecode
JRE (Java Runtime Environment)			JVM + core runtime libraries
JDK (Java Development Kit)				JRE + Developer tools (javac, javadoc, debugger, etc.)

In most programming languages Source Code ‚Üí Compiler ‚Üí Machine Code ‚Üí CPU.
Machine code is specific to the OS & CPU and must be recompiled per platform.

In Java
Source Code ‚Üí Java Compiler ‚Üí Bytecode ‚Üí JVM ‚Üí Machine Code ‚Üí CPU.
Bytecode works on Windows JVM,Linux JVM,MacOS JVM.
Platform independence achieved because JVM is platform-specific, but Bytecode is not.

JVM is divided into 3 main sub Systems.

1.Class Loader Subsystem
2.Runtime Data Area
3.Execution Engine

############################################################ 2.Class Loader Subsystem #####################################################################

Class loaders in Java handle the process of dynamically bringing Java classes into the Java Virtual Machine (JVM) as needed.
This system makes Java different from many other programming languages, where programs are compiled directly into machine code and executed by the operating system.
Java programs are first compiled into bytecode.
The Class Loader loads the required .class files into JVM memory only when they are needed (dynamic loading).
Loaded classes Verified for safety,Prepared (static memory allocated) and Initialized (static code executed).
Execution Engine runs the bytecode using the Interpreter and the JIT Compiler, converting it into native machine code that runs on the CPU.

Other than loading the.class files into memory, Class loaders define the namespace for every class they load.
A class in Java is uniquely identified not only by its fully-qualified class name, but by the combination of

	(Class Name + Defining Class Loader)
	
Because each Class Loader maintains its own namespace, the same class name can exist multiple times in a JVM, as long as each copy is loaded by a different Class Loader.
This mechanism allows for the same class name to be used in different parts of the program without causing conflicts, as long as they are loaded by different class loaders.

Note :
------
Same class such as com.mysql.cj.jdbc.Driver can be loaded multiple times in the same JVM provided that different Class Loaders load it.
Each loaded copy belongs to a separate namespace and is treated as a distinct class.
This enables Java servers and frameworks to support version isolation, plugins, and hot deployments, but requires caution to avoid casting issues and memory leaks.

Class Loading Process :
-----------------------
1.Loading :
------------
Class Loader loads the .class files(bytecode) from the file system or other sources.
Class Loader then converts this bytecode into a binary stream of data representing the class in the memory.

Class Loader operate in a parent-child structure to load classes in a controlled and efficient manner.

A.Bootstrap Class Loader :
--------------------------
Responsible for loading essential Java classes such as those in java.lang.# and java.util.#
Highest priority is given to the Bootstrap Class Loader.

Java 8 and earlier loads core Java classes from JAVA_HOME/jre/lib.
Java 9 and later loads core Java classes from the modular runtime image, typically in JAVA_HOME/lib/modules or JAVA_HOME/jmods.

B.Extension Class Loader or Platform Class Loader :
---------------------------------------------------
Responsible for loading the Classes which are inside ext folder i.e. JAVA_HOME/jre/lib/ext.

C.Application Class Loader :
----------------------------
Responsible for loading the classes at application-level classes specified in the class path i.e.
Classes specified in the CLASSPATH environment variable.
Classes set using the -classpath command-line option.
Classes packaged inside JAR files with a MANIFEST.MF that specifies a classpath.

Delegation Principle :
----------------------
Java‚Äôs Class Loader system follows the delegation model.
When a Class Loader load's the class, it first passes the request to its parent class loader.
This process continues up the chain until it reaches the Bootstrap Class Loader. 
If the parent class loader finds the class, it returns it to the child. If not, the child class loader steps in and tries to load it on its own.
This setup helps avoid loading the same class multiple times and keeps things consistent across the JVM.
Since classes loaded by a parent class loader are available to all its child loaders.

2.Linking :
------------
After loading the class, Class Loader performs the Linking process.

üîπ Verify (Bytecode Verification)
The Bytecode Verifier checks that the .class file is safe to run.
‚úÖ Bytecode format is correct
‚úÖ Instructions are valid
‚úÖ Stack usage is safe
‚úÖ No illegal memory access
‚úÖ No type mismatch
‚úÖ No forged pointers

	public class Test {
		public static void main(String[] args) {
			int a = "hello";   // Invalid bytecode after tampering
		}
	}

VerifyError is thrown only at runtime by the JVM when already-compiled bytecode is invalid or corrupted.
JVM aborts the execution and rejects the class before running it.

‚úÖ Note :
---------
we cannot produce a VerifyError using legal Java source code alone ‚Äî because the compiler guarantees safe bytecode.
VerifyError usually happens only if:
.class file is manually edited
Bytecode tools (ASM, ByteBuddy) generate invalid instructions
Class files are corrupted during transmission

‚úÖ SOLUTION BY JVM
JVM refuses to load corrupted or invalid bytecode.
Program stops before reaching execution.
Ensures JVM remains stable and secure.

üîπ Prepare (Static Memory Allocation) :
Memory is allocated for static variables and set to default values.

üîπ Resolve :
In Java bytecode references to methods, fields and classes are stored symbolically.	
During Resolve phase JVM converts these symbolic references into direct memory pointers i.e. actual addresses in the Method Area.

	public class App {
		public static void main(String[] args) {
			Database.connect();
		}
	}
	
Byte code has symbolic connect i.e. Database.connect()
During Resolve:
‚úÖ JVM locates class Database
‚úÖ Locates its method connect()
‚úÖ Replaces symbolic reference with direct pointer to the method in memory


3.Initialization :
-------------------
This is the final phase of Class Loading.
Here all the static variables will be assigned with original values and static block will be executed.

###############################################################  3.Stack Area ####################################################################################

Stack Area (Java Stack) stores the method execution data for each Thread i.e Stack Frame.
For every method call performed by the Thread, the JVM creates a separate Stack Frame and pushes it onto the Thread‚Äôs Stack Area.
Each Thread has its own runtime Stack Frame, making Stack memory thread-safe.
All method-local variables (both primitive values and object references) are stored in the stack.
When the method returns (normally or due to an exception), the frame is popped from the stack.

Each stack frame consists of:
1.Local Variable Array (Local Variable Table)
2.Operand Stack
3.Frame Data (also called Frame Metadata)
		
When the method completes or an exception occurs, the entire stack frame is removed immediately.


				Stack Frame
		---------------------------------
		|  Frame Data (Method Info)     |
		---------------------------------
		|  Operand Stack                |
		---------------------------------
		|  Local Variable Array         |
		---------------------------------


1.Local Variable Array :
------------------------
Local Variable Array stores method parameters, primitive local variables, and references to Heap objects.

	void calc(int x) {
		int y = 10;
		String msg = "Hi";
	}
	
	| Slot | Value                                     |
	| ---- | ----------------------------------------- |
	| 0    | `this` reference (for non-static methods) |
	| 1    | `x`                                       |
	| 2    | `y`                                       |
	| 3    | `msg` (reference to Heap)                 |
	
Note :
------	
The array size is fixed at compile time based on method needs.
Local Variable Array stores values directly for primitives and addresses/references for objects.
Slot reuse is possible when variables go out of scope.

2.Operand Stack :
-----------------
Operand Stack is used as a working area to evaluate expresions and method execution.
Operand Stack is not used to store variables permanently.

	void calculate() {
		int a = 10;
		int b = 20;
		int c = a + b;
	}
	
LOAD a        // push a to operand stack
LOAD b        // push b to operand stack
ADD           // pop both values, add them
STORE c       // store result into local variable "c",Value 30 is removed from operand stack

Operand Stack: EMPTY
Local Variable Array

a = 10
b = 20
c = 30 ‚úÖ

3.Frame Data :
--------------
Frame Data stores method-related data, including
1.Constant pool reference of the currently running class
2.Method metadata
3.Exception handling data
4.Return address
5.Symbolic information used during linking & execution


############################################################ 4.Heap Memory (digitalocean) ########################################################

Understanding the JMM(Java Memory Model) is essential for anyone who is working with Java concurrency.
It specifies the behavior of the java.util.concurrent package, low-level synchronization primitives, and lock-free algorithms.
By knowing this Developers can ensure that shared data remains consistent and applications behave reliably under load.

Java Virtual Machine(JVM) divides its memory area into several logical runtime data areas, each serving a specific role during program execution.
This structured memory model ensures the isolation between different types of data, supports multithreading, and enables features like automatic garbage collection.
At runtime, the JVM creates a set of runtime data areas. These include

Heap Memory
Stack Memory
Method Area (Implemented as Metaspace in Java 8+)
Program Counter (PC) Register
Native Method Stack

Heap Memory :
-------------
Heap memory is the primary area for dynamic memory allocation. 
All class instances, arrays, and objects created during program execution are stored in the Heap Memory.
Unlike stack memory, which is isolated to individual threads, Heap is a shared memory accessible by all threads in the JVM.
This shared access allows objects to be passed between threads and persist beyond the execution of any single method.

Heap memory is automatically managed by the garbage collector, which reclaims memory occupied by objects that are no longer in use.
To optimize this process and reduce application pause times, JVM divides the heap into two regions.

1.Young Generation
2.Old Generation

This is known as Generational Heap Model and is based on the principle that most objects in Java applications are short-lived and those that survive are likely to live much longer.

1.Young Generation :
--------------------
The Young Generation is where all newly created objects begin their lifecycle. 
It is optimized for fast allocation and frequent garbage collection.
Because the majority of objects are short-lived, this region is collected often using Minor Garbage Collections (Minor GCs), which are typically fast and efficient.

Method-local objects
Temporary DTOs
REST request/response objects
Loop variables
Buffers (StringBuilder, byte[], etc.)

Young Generation is divided into three spaces.

Eden Space :
------------ 
This is the starting point for new object allocations. 
As soon as an object is created, JVM attempts to place it in Eden. 
When Eden fills up, Minor GC is triggered.

Survivor Spaces :
----------------- 
The two survivor spaces, commonly referred to as S0 and S1, act as staging areas for objects that survive a garbage collection.
After each Minor GC, reachable objects from Eden are moved into one of the survivor spaces. 
Objects that continue to survive are moved between the two survivor spaces across collection cycles.

As objects survive more GC cycles, their age increases. 
Once an object‚Äôs age exceeds a threshold, it is promoted to the Old Generation. 
Promotion is also forced when the survivor spaces do not have enough room to hold surviving objects.

These parameters are particularly useful for applications with high allocation rates, such as REST APIs, streaming pipelines, or real-time event processing systems.

		NEW OBJECT
			|
			‚ñº
		EDEN SPACE
			|
		Eden full
			|
			‚ñº
		MINOR GC
			|
			‚îú‚îÄ unreachable ‚Üí removed ‚ùå
			|
			‚îî‚îÄ reachable
				   |
				   ‚ñº
		Survivor S0 ‚Üî Survivor S1 (age++)
				   |
		Age ‚â• threshold OR space full
				   |
				   ‚ñº
		OLD GENERATION
		
2.Old Generation :
------------------
The Old Generation, also known as the Tenured Generation, is designed to hold long-lived objects, those that have survived multiple Minor GCs.
While Young Generation handles the frequent allocation and disposal of short-lived data,Old Generation holds the objects that are in use for extended periods are eventually stored.

Examples include
Persistent application-level caches
Large object graphs such as sessions or user data
Static or shared data structures that are retained across requests

Because the Old Generation contains objects that are more likely to still be in use, it is collected less frequently than the Young Generation.
Garbage collection in this region is referred to as a Major GC, and when both generations are collected together, the process is known as a Full GC.

Note :
------
A Full GC collects the entire Heap (Young and Old), and depending on the garbage collector and memory pressure, It may also include Metaspace, though this is not guaranteed.

############################################################### 6.Execution Engine ####################################################################################

Byte Code which is assigned to the Runtime Data Area will be executed by the Execution Engine.
Execution Engine reads the Byte Code and executes it piece by piece.

A)Interpreter :
---------------
Interpreter interprets the byte code faster but executes slowly.
Disadvantage of Interpreter is that when one method is called multiple times,every time a new interpretation is required.

B)JIT Compiler :
----------------
JIT Compiler neutralizes the disadvantage of Interpreter.
With the help of Interpreter,Execution Engine interprets the byte Code.
When the Execution Engine finds repeated code,it uses JIT Compiler which compiles the entire Byte Code and converts it into native code.
This native code will be used directly for the repeated method calls,which improoves the performance of the system.

Intermediate Code Generator : Generates Intermediate code.
Code Optimizer 				: Responsible for optimizing the Intermediate code which is generated above.
Target Code Generator 		: Responsible for generating Machine code or Native code.
Profiler 					: A Special componenet responsible for finding Hotspots i.e whether the method is called multiple times or not.

C)Garbage Collector :
---------------------
Garbage Collector collects and removes unreferenced Objects.
Garbage Collector can be triggered by calling Syste.gc() but the execution is not gauranteed.

D)Java Native Interface will be interacting with Native Method Libraries and provides the Native Libraries required for the Execution Engine.

########################################################## 10.Reference Types(Constantin Marian) ############################################################# 

Java has Automatic memory management and Garbage Collector that works in the background to clean up the unused Objects and free up some memory.
As a Java programmer we need not worry about destroying the Objects as they are not used any more.
However the process is Automatic in Java and it does not gaurantee the clean up of unused Objects. 
we could have the Objects that are not eligible for Garbage Collector and no longer used.

If we know how JMM actually works in Java, it gives the advantage of writing high performance code that will never-ever crash with an OutOfMemoryError.
Generally memory is divided into two parts i.e. Stack and Heap.
Heap has huge amount of memory compared to Stack.

Reference Types :
-----------------
In Java programming Language,we have different type of references that points from Stack memory to the Heap Memory.
Types of reference is that the Objects on the Heap they refer to are eligible for Garbage Collector.

Strong Reference :
------------------
Object on the Heap is not Garbage Collected when there is a Strong reference pointing to it.
It is strongly reachable through a chain of strong references.

Weak reference :
----------------
Weak reference to an object from the Heap is most likely not to survive after the next garbage collection process.
Best scenarion for Weak reference is Caching Mechanism.
If we want to retreive some data and want to store in memory as well.
Here the same data will be requested again.
If we put the weak reference and garbage collector runs then it destroys the object on the Heap.

Soft Reference :
----------------
Soft references are used for more memory sensitive scenarios.
These are going to be Garbage collected only when the application is running low on memory.
As long as there is no critical free up space,the Garbage Collector will not touch softly reusable objects.
Java Gaurantees that all the soft referenced objects are cleaned up before it throws an OutOfMemoryError.

Phantom Reference :
-------------------
Phantom reference are used to schedule post-mortem clean up actions.
Since we know for sure that Objects are no longer Live.
Phantom references are considered preferably as Finalizers.

How Strings are Referenced :
----------------------------
Strings are Immutable that means each time we do something with string,another object is created actually on the Heap.
For String Java manages a String Pool Memory.This means that Java Stores and reuse Strings whenever possible.
This is mostly true for String literals.

	String local_prefix="297";
	String prefix="297";
	
	if(""=="")
	{
		sysout("Strings are Equal");
	}
	else
	{
	sysout("Strings are Different");
	}

We can force the JVM to add the String to the SCP i.e String Content Pool we use intern().

Garbage Collection Process :
----------------------------
Depending on the type of reference that a variable from the stack holds to an object from the Heap,
At certain point in time,that object becomes eligible for Garbage Collector.








Garbage Collector Types :
-------------------------




Tips and Tricks For Java Memory Management :
--------------------------------------------



 
############################################################  11.Dynamic Class Loading (DZone) ###############################################################

Class.forName is used to load the class dynamically where we does not know the class name before hand.
Once the Class is loaded we will use newInstance() to create the object dyanmically.

############################################################ 12.JDK vs JRE vs JVM (guru99)  ##################################################################

JDK is a software Development Kit,JRE is a software bundle that allows us Java Program to run where as JVM is an environment for executing Byte Code.

JDK :
-----
JDK contains tools required to write Java Programs and JRE to execute them.Tools like Debugger,Compiler etc.
It includes Compiler,Application Launcher and AppletViewer etc.
Compiler converts the code written in Java into Byte Code.
Java Application Launcher opens JRE which loads the necessary Classes ane executes the Main Method.

JRE :
-----
JRE contains class libraries,JVM and other supporting files etc.
If we want to run any Java Program then JRE must be installed in our system.

JVM :
-----
JVM provides platform independent way of executing Java Source Code.






