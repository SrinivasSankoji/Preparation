1.JVM  Architecture 					(DZone)							[29-NOV-2020]  (Done)
2.Class Loader Subsystem				(Alexander Obregon)				[01-DEC-2025]  (Done)
3.Stack Area 							(digitalocean)					[03-DEC-2025]  (Done)
4.Heap Memory 							(digitalocean)					[03-DEC-2025]  (Done)
5.Method Area 							(digitalocean,FullStackTips)	[06-DEC-2025]  ()
6.PC Registers 							()								[30-NOV-2020]  ()
7.Execution Engine 						()								[30-NOV-2020]  ()
8.Native Method Stack 					(Kalyani Dagde)					[30-NOV-2020]  ()
9.Garbage Collection 					(Subhasis Roy)					[30-NOV-2020]  ()
10.Reference Types 						(Constantin Marian)				[30-NOV-2020]  ()		
11.Dynamic Class Loading				(DZone)							[30-NOV-2020]  (Done)
12.JDK vs JRE vs JVM 					(guru99)						[23-JAN-2021]  ()


Delegation Heirarchy
Class Level Data
Stack Frame / Stack Area
Operand Stack
Frame Data 

############################################################  1.JVM  Architecture ########################################################################

Java was developed with the concept of WORA i.e. write once and run anywhere.
Compiler compiles the .java file and generates the .class file i.e. Byte Code which is platform independent.
The same Byte Code can run on any Operating System which has JVM installed.
JVM converts Bytecode into machine-specific native instructions and executes them on the hardware.

JVM does not directly convert the Bytecode into machine code line-by-line.
Interpreter â†’ Executes Bytecode line by line
JIT Compiler â†’ Converts frequently executed Bytecode blocks into native machine code for faster performance.

			        Java Source Code (.java)
                          â†“
                    javac Compiler
                          â†“
                Bytecode File (.class)
                          â†“
						 JVM  
                          â†“
              Class Loader Subsystem
                          â†“
            Load â†’ Verify â†’ Prepare â†’ Resolve â†’ Initialize
                          â†“
               Runtime Data Area (Memory Setup)
						  â†“
           Method Area | Heap | Stack | PC | Native Stack
                          â†“
                  Execution Engine
                          â†“
                Interpreter (line by line)
                          â†“
             Hot code detected â†’ JIT Compiler
                          â†“
                   Native Machine Code
                          â†“ (Now the program runs at near C/C++ native speed)
				Stored in Code Cache (RAM)
						  â†“
                         CPU
                          â†“
                         OS
                          â†“
                    Program Executes
					
As a Java Developer if we know the Architecture of JVM,it helps us to write the code more efficiently.

What is JVM :
-------------
JVM is is a software-based virtual machine that :
1.Loads, verifies, links, and executes Java Bytecode.
2.Converts Bytecode into platform-specific machine code.
3.Provides the runtime environment for executing Java programs.
4.Manages Memory,Threads,Garbage Collection,Security

Component										Description
JVM										Engine that runs Java Bytecode
JRE (Java Runtime Environment)			JVM + core runtime libraries
JDK (Java Development Kit)				JRE + Developer tools (javac, javadoc, debugger, etc.)

In most programming languages Source Code â†’ Compiler â†’ Machine Code â†’ CPU.
Machine code is specific to the OS & CPU and must be recompiled per platform.

In Java
Source Code â†’ Java Compiler â†’ Bytecode â†’ JVM â†’ Machine Code â†’ CPU.
Bytecode works on Windows JVM,Linux JVM,MacOS JVM.
Platform independence achieved because JVM is platform-specific, but Bytecode is not.

JVM is divided into 3 main sub Systems.

1.Class Loader Subsystem
2.Runtime Data Area
3.Execution Engine

############################################################ 2.Class Loader Subsystem #####################################################################

1.Loading :
------------
Class Loader loads the required .class files into JVM memory only when they are needed (Dynamic loading).
Loaded classes are verified for safety and then prepared and initialized.
Execution engine runs the Bytecode using the Interpreter and the JIT Compiler, converting into native machine code that runs on the CPU.
Class Loader operates in a parent-child structure to load classes in a controlled and efficient manner.

Note :
------
Other than loading the.class files into memory, Class loaders define the namespace for every class they load.
A class in Java is uniquely identified not only by its fully-qualified class name, but by the combination of

	(Class Name + Defining Class Loader)
	
This mechanism allows for the same class to be used in different parts of the program without causing conflicts, as long as they are loaded by different class loaders.

Note :
------
Same class such as com.mysql.cj.jdbc.Driver can be loaded multiple times in the same JVM provided that different Class Loaders load it.
Each loaded copy belongs to a separate namespace and is treated as a distinct class.
This enables Java servers and frameworks to support version isolation, plugins, and hot deployments, but requires caution to avoid casting issues and memory leaks.

A.Bootstrap Class Loader :
--------------------------
Responsible for loading essential Java classes such as those in java.lang.* and java.util.*
Highest priority is given to the Bootstrap Class Loader.

Java 8 and earlier loads core Java classes from JAVA_HOME/jre/lib.
Java 9 and later loads core Java classes from the modular runtime image, typically in JAVA_HOME/lib/modules or JAVA_HOME/jmods.

B.Extension Class Loader or Platform Class Loader :
---------------------------------------------------
Responsible for loading the Classes which are inside ext folder i.e. JAVA_HOME/jre/lib/ext.

C.Application Class Loader :
----------------------------
Responsible for loading the classes at application-level classes specified in the class path i.e.
Classes specified in the CLASSPATH environment variable.
Classes set using the -classpath command-line option.
Classes packaged inside JAR files with a MANIFEST.MF that specifies a classpath.

Delegation Principle :
----------------------
Javaâ€™s Class Loader system follows the delegation model.
When a Class Loader load's the class, it first passes the request to its parent class loader.
This process continues up the chain until it reaches the Bootstrap Class Loader. 
If the parent Class Loader finds the class, it returns it to the child. If not, child Class Loader steps in and tries to load it on its own.
This process helps to avoid loading the same class multiple times and keeps things consistent across the JVM.

2.Linking :
------------
After loading the class, Class Loader performs the Linking process.

ğŸ”¹ Verify (Bytecode Verification)
The Bytecode Verifier checks that the .class file is safe to run.
âœ… Bytecode format is correct
âœ… Instructions are valid
âœ… Stack usage is safe
âœ… No illegal memory access
âœ… No type mismatch
âœ… No forged pointers

	public class Test {
		public static void main(String[] args) {
			int a = "hello";   // Invalid bytecode after tampering
		}
	}

VerifyError is thrown only at runtime by the JVM when already-compiled bytecode is invalid or corrupted.
JVM aborts the execution and rejects the class before running it.

âœ… Note :
---------
we cannot produce a VerifyError using legal Java source code alone â€” because the compiler guarantees safe bytecode.
VerifyError usually happens only if:
.class file is manually edited.
Bytecode tools (ASM, ByteBuddy) generate invalid instructions.
Class files are corrupted during transmission.

âœ… SOLUTION BY JVM
JVM refuses to load corrupted or invalid bytecode.
Program stops before reaching execution.
Ensures JVM remains stable and secure.

ğŸ”¹ Prepare (Static Memory Allocation) :
Memory is allocated for static variables and set to default values.

ğŸ”¹ Resolve :
In Java bytecode references to methods, fields and classes are stored symbolically.	
During Resolve phase JVM converts these symbolic references into direct memory pointers i.e. actual addresses in the Method Area.

	public class App {
		public static void main(String[] args) {
			Database.connect();
		}
	}
	
Byte code has symbolic connect i.e. Database.connect()
During Resolve:
âœ… JVM locates class Database
âœ… Locates its method connect()
âœ… Replaces symbolic reference with direct pointer to the method in memory


3.Initialization :
-------------------
This is the final phase of Class Loading.
Here all the static variables will be assigned with original values and static block will be executed.

###############################################################  3.Stack Area ####################################################################################

For every method call performed by the Thread, JVM creates a separate Stack Frame and pushes it into the Stack Area.
Each Thread has its own runtime Stack Frame, making Stack Area thread-safe.
When the method completes the execution or an Exception occurs, the entire Stack frame is removed immediately.

Each stack frame consists of:
1.Local Variable Array (Local Variable Table)
2.Operand Stack
3.Frame Data (also called Frame Metadata)

				Stack Frame
		---------------------------------
		|  Frame Data (Method Info)     |
		---------------------------------
		|  Operand Stack                |
		---------------------------------
		|  Local Variable Array         |
		---------------------------------


1.Local Variable Array :
------------------------
Local Variable Array stores method parameters, method local variables and references to Heap objects.

	void calc(int x) {
		int y = 10;
		String msg = "Hi";
	}
	
	| Slot | Value                                     |
	| ---- | ----------------------------------------- |
	| 0    | `this` reference (for non-static methods) |
	| 1    | `x`                                       |
	| 2    | `y`                                       |
	| 3    | `msg` (reference to Heap)                 |
	
Note :
------	
The array size is fixed at compile time and based on method needs.
Local Variable Array stores values directly for primitives and addresses/references for objects.

2.Operand Stack :
-----------------
Operand Stack is used as a working area to evaluate the expresions and method execution.
Operand Stack is not used to store variables permanently.

	void calculate() {
		int a = 10;
		int b = 20;
		int c = a + b;
	}
	
LOAD a        // push a to operand stack
LOAD b        // push b to operand stack
ADD           // pop both values, add them
STORE c       // store result into local variable "c",Value 30 is removed from operand stack

Operand Stack: EMPTY
Local Variable Array

a = 10
b = 20
c = 30 âœ…

3.Frame Data :
--------------
Frame Data stores method-related data, including
1.Constant pool reference of the currently running class
2.Method metadata
3.Exception handling data
4.Return address
5.Symbolic information used during linking & execution


############################################################ 4.Heap Memory (digitalocean) ########################################################

Understanding the JMM(Java Memory Model) is essential for anyone who is working with Java concurrency.
It specifies the behavior of the java.util.concurrent package, low-level synchronization primitives, and lock-free algorithms.
By knowing this Developers can ensure that shared data remains consistent and applications behave reliably under load.

Java Virtual Machine(JVM) divides its memory area into several logical runtime data areas, each serving a specific role during program execution.
This structured memory model ensures the isolation between different types of data, supports multithreading, and enables features like automatic garbage collection.
At runtime, the JVM creates a set of runtime data areas. These include

Heap Memory
Stack Memory
Method Area (Implemented as Metaspace in Java 8+)
Program Counter (PC) Register
Native Method Stack

Heap Memory :
-------------
Heap memory is the primary area for dynamic memory allocation. 
All class instances, arrays, and objects created during program execution are stored in the Heap Memory.
Unlike stack memory, which is isolated to individual threads, Heap is a shared memory accessible by all threads in the JVM.
This shared access allows objects to be passed between threads and persist beyond the execution of any single method.

Heap memory is automatically managed by the garbage collector, which reclaims memory occupied by objects that are no longer in use.
To optimize this process and reduce application pause times, JVM divides the heap into two regions.

1.Young Generation
2.Old Generation

This is known as Generational Heap Model and is based on the principle that most objects in Java applications are short-lived and those that survive are likely to live much longer.

1.Young Generation :
--------------------
The Young Generation is where all newly created objects begin their lifecycle. 
It is optimized for fast allocation and frequent garbage collection.
Because the majority of objects are short-lived, this region is collected often using Minor Garbage Collections (Minor GCs), which are typically fast and efficient.

Method-local objects
Temporary DTOs
REST request/response objects
Loop variables
Buffers (StringBuilder, byte[], etc.)

Young Generation is divided into three spaces.

Eden Space :
------------ 
This is the starting point for new object allocations. 
As soon as an object is created, JVM attempts to place it in Eden. 
When Eden fills up, Minor GC is triggered.

Survivor Spaces :
----------------- 
The two survivor spaces, commonly referred to as S0 and S1, act as staging areas for objects that survive a garbage collection.
After each Minor GC, reachable objects from Eden are moved into one of the survivor spaces. 
Objects that continue to survive are moved between the two survivor spaces across collection cycles.

As objects survive more GC cycles, their age increases. 
Once an objectâ€™s age exceeds a threshold, it is promoted to the Old Generation. 
Promotion is also forced when the survivor spaces do not have enough room to hold surviving objects.

These parameters are particularly useful for applications with high allocation rates, such as REST APIs, streaming pipelines, or real-time event processing systems.

		NEW OBJECT
			|
			â–¼
		EDEN SPACE
			|
		Eden full
			|
			â–¼
		MINOR GC
			|
			â”œâ”€ unreachable â†’ removed âŒ
			|
			â””â”€ reachable
				   |
				   â–¼
		Survivor S0 â†” Survivor S1 (age++)
				   |
		Age â‰¥ threshold OR space full
				   |
				   â–¼
		OLD GENERATION
		
2.Old Generation :
------------------
The Old Generation, also known as the Tenured Generation, is designed to hold long-lived objects, those that have survived multiple Minor GCs.
While Young Generation handles the frequent allocation and disposal of short-lived data,Old Generation holds the objects that are in use for extended periods are eventually stored.

Examples include
Persistent application-level caches
Large object graphs such as sessions or user data
Static or shared data structures that are retained across requests

Because the Old Generation contains objects that are more likely to still be in use, it is collected less frequently than the Young Generation.
Garbage collection in this region is referred to as a Major GC, and when both generations are collected together, the process is known as a Full GC.

Note :
------
A Full GC collects the entire Heap (Young and Old), and depending on the garbage collector and memory pressure, It may also include Metaspace, though this is not guaranteed.

############################################################### 5.Method Area #########################################################################################

Method area is another memory area used by JVM to store class level meta-data which is required to run the Java Program.
Method area will be created at the start of the Application, exists one per JVM and shared among all the Threads.
Although it is conceptually distinct from the Heap, its actual implementation has evolved over different versions of the JVM.
Most notably with the transition from Permanent Generation (PermGen) to Metaspace in Java 8.
	
Method Area stores
1.Class Metadata
2. Runtime Constant Pool
3. Static Variables (Class Variables)
4. Method Bytecode
5.Field and method information
6.Constructor code
7.Type information used for method resolution and dispatching

	        METHOD AREA (PermGen / Metaspace)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                CLASS METADATA                   â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚ Class Identity Info                         â”‚ â”‚
   â”‚ â”‚  â€¢ Fully Qualified Name                     â”‚ â”‚
   â”‚ â”‚  â€¢ Superclass reference                     â”‚ â”‚
   â”‚ â”‚  â€¢ Implemented interfaces                   â”‚ â”‚
   â”‚ â”‚  â€¢ Access flags (public, final, abstractâ€¦)  â”‚ â”‚
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚ 5. FIELD INFORMATION                        â”‚ â”‚
   â”‚ â”‚  â€¢ Field names                              â”‚ â”‚
   â”‚ â”‚  â€¢ Types (int, String, Objectâ€¦)             â”‚ â”‚
   â”‚ â”‚  â€¢ Modifiers (static, final, privateâ€¦)      â”‚ â”‚
   â”‚ â”‚  â€¢ Annotations                              â”‚ â”‚ 
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚ 5. METHOD INFORMATION                       â”‚ â”‚
   â”‚ â”‚  â€¢ Method names                             â”‚ â”‚
   â”‚ â”‚  â€¢ Return types                             â”‚ â”‚
   â”‚ â”‚  â€¢ Parameter types                          â”‚ â”‚
   â”‚ â”‚  â€¢ Modifiers                                â”‚ â”‚
   â”‚ â”‚  â€¢ Annotations                              â”‚ â”‚ 
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚ 6. CONSTRUCTOR CODE                         â”‚ â”‚
   â”‚ â”‚  â€¢ Bytecode for constructors (<init>)       â”‚ â”‚
   â”‚ â”‚  â€¢ Static initializers (<clinit>)           â”‚ â”‚
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚ 7. TYPE INFORMATION / DISPATCH INFO         â”‚ â”‚
   â”‚ â”‚  â€¢ Virtual method tables (vtable/itable)    â”‚ â”‚
   â”‚ â”‚  â€¢ Interface method maps                    â”‚ â”‚
   â”‚ â”‚  â€¢ Method resolution tables                 â”‚ â”‚
   â”‚ â”‚  â€¢ Polymorphism dispatch structures         â”‚ â”‚
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚   RUNTIME CONSTANT POOL                     â”‚ â”‚
   â”‚ â”‚   â€¢ Literals                                â”‚ â”‚
   â”‚ â”‚   â€¢ Class refs                              â”‚ â”‚
   â”‚ â”‚   â€¢ Method refs                             â”‚ â”‚
   â”‚ â”‚   â€¢ Field refs                              â”‚ â”‚
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â”‚                                                 â”‚
   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
   â”‚ â”‚   STATIC VARIABLES                          â”‚ â”‚
   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


All of this information is essential for enabling runtime features such as dynamic method invocation, polymorphism, and class reflection.
Because this data does not change after the class is loaded (with few exceptions, such as dynamic class redefinition).
It is considered immutable for the duration of the classâ€™s life cycle.

Class Metadata :
----------------
Every loaded class has an internal structure created in the Method Area.

	class Student {
	   String name;
	   static int count;
	   void study(){}
	}

| Component                  | What it holds                      |
| -------------------------- | ---------------------------------- |
| **Class name**             | `Student`                          |
| **Package name**           | `com.example.Student`              |
| **Superclass info**        | `java.lang.Object`                 |
| **Interfaces implemented** | e.g. `Runnable`                    |
| **Access flags**           | `public`, `abstract`, etc          |
| **Field metadata**         | Field names, types, modifiers      |
| **Method metadata**        | Method names, return types, params |
| **Annotations**            | `@Service`, `@Entity`, etc         |
| **Bytecode**               | Method instructions                |

Runtime Constant Pool :
-----------------------
Each class has a Runtime Constant Pool, stored in the Method Area.
It contains
âœ… String literals
âœ… Class names
âœ… Method references
âœ… Field references
âœ… Numeric constants

	String s = "HELLO";
	
"HELLO" is kept in the Constant Pool.
All references to "HELLO" reuse the same entry.

Static Variables (Class Variables) :
------------------------------------
Static fields live in the Method Area and not the Heap.
All instances access the same static variable copy

	class Counter {
		static int count = 0;
	}
	
Method Area â†’ count = 0
Heap â†’ Counter object instance

Method Bytecode :
-----------------
Every method's Bytecode instructions are stored here.

	void add(){
	   int x = 10;
	}

The actual JVM instructions for add() are stored in Method Area
Execution runs on Stack frames, but bytecode remains in Method Area.

Since the Method Area is shared across all threads, Multiple threads may read class metadata safely.
JVM uses internal synchronization to ensure
A class loads only once.
Fields/method info isn't corrupted.

Without Method Area
âŒ JVM cannot load classes
âŒ Bytecode cannot be executed
âŒ Static fields have no storage
âŒ Constant pools donâ€™t exist
âŒ Reflection fails

Method Area is the backbone of runtime type information (RTTI) in Java.

PermGen: The Original implementation (Before Java 8) :
------------------------------------------------------
In JVM versions prior to Java 8, Method area was physically implemented in a fixed-size memory region called the Permanent Generation (PermGen).
PermGen resided in the Heap and had to be explicitly sized using JVM flags like

	-XX:PermSize=128m
	-XX:MaxPermSize=256m
	
The fixed nature of PermGen introduced several challenges.
Class metadata could exceed PermGen space, leading to java.lang.OutOfMemoryError: PermGen space especially in applications that dynamically load many classes.
It could not grow beyond its configured maximum, regardless of available system memory.

Metaspace: Modern implementation (Java 8 and Later) :
-----------------------------------------------------
With the release of Java 8, the JVM replaced PermGen with a new memory region called Metaspace.
Unlike PermGen, Metaspace is not part of the Java Heap.
It is allocated from native memory, which allows it to grow dynamically as needed.

This change brought several improvements:
Developers no longer need to worry about sizing PermGen manually.
The risk of OutOfMemoryError: PermGen space is greatly reduced.
Class metadata is handled more flexibly and efficiently.

However, while Metaspace can grow automatically, it is still constrained by available system memory.
If too many classes are loaded (or not properly unloaded), Metaspace can still overflow, leading to a an error.

	-XX:MetaspaceSize=128m
	-XX:MaxMetaspaceSize=512m
	
MetaspaceSize defines the initial size, which affects when the first GC of class metadata will be triggered.
MaxMetaspaceSize limits how large Metaspace can grow. If omitted, Metaspace will grow until it exhausts native memory.

Applications that dynamically load and unload classes â€” such as servlet containers (Tomcat, Jetty), OSGi platforms, or scripting engines â€” should monitor Metaspace usage closely.

Class Unloading and Garbage Collection :
----------------------------------------
Metaspace memory is eligible for collection when classes are unloaded, but this only happens if

1.The class loader that loaded the class is no longer reachable.
2.The garbage collector is invoked and identifies the class loader as unreachable.
3.The JVM supports class unloading (some collectors may restrict this).

Uncollected class loaders can lead to Metaspace leaks, especially in environments where classes are reloaded frequently (e.g., Hot deployment in Development servers). 
To mitigate this, JVM options like -XX:+ClassUnloading (enabled by default in modern JVMs) can help enable or improve class unloading behavior.

############################################################### 7.Execution Engine ####################################################################################

Byte Code which is assigned to the Runtime Data Area will be executed by the Execution Engine.
Execution Engine reads the Byte Code and executes it piece by piece.

A)Interpreter :
---------------
Interpreter interprets the byte code faster but executes slowly.
Disadvantage of Interpreter is that when one method is called multiple times,every time a new interpretation is required.

B)JIT Compiler :
----------------
JIT Compiler neutralizes the disadvantage of Interpreter.
With the help of Interpreter,Execution Engine interprets the byte Code.
When the Execution Engine finds repeated code,it uses JIT Compiler which compiles the entire Byte Code and converts it into native code.
This native code will be used directly for the repeated method calls,which improoves the performance of the system.

Intermediate Code Generator : Generates Intermediate code.
Code Optimizer 				: Responsible for optimizing the Intermediate code which is generated above.
Target Code Generator 		: Responsible for generating Machine code or Native code.
Profiler 					: A Special componenet responsible for finding Hotspots i.e whether the method is called multiple times or not.

C)Garbage Collector :
---------------------
Garbage Collector collects and removes unreferenced Objects.
Garbage Collector can be triggered by calling Syste.gc() but the execution is not gauranteed.

D)Java Native Interface will be interacting with Native Method Libraries and provides the Native Libraries required for the Execution Engine.

########################################################## 10.Reference Types(Constantin Marian) ############################################################# 

Java has Automatic memory management and Garbage Collector that works in the background to clean up the unused Objects and free up some memory.
As a Java programmer we need not worry about destroying the Objects as they are not used any more.
However the process is Automatic in Java and it does not gaurantee the clean up of unused Objects. 
we could have the Objects that are not eligible for Garbage Collector and no longer used.

If we know how JMM actually works in Java, it gives the advantage of writing high performance code that will never-ever crash with an OutOfMemoryError.
Generally memory is divided into two parts i.e. Stack and Heap.
Heap has huge amount of memory compared to Stack.

Reference Types :
-----------------
In Java programming Language,we have different type of references that points from Stack memory to the Heap Memory.
Types of reference is that the Objects on the Heap they refer to are eligible for Garbage Collector.

Strong Reference :
------------------
Object on the Heap is not Garbage Collected when there is a Strong reference pointing to it.
It is strongly reachable through a chain of strong references.

Weak reference :
----------------
Weak reference to an object from the Heap is most likely not to survive after the next garbage collection process.
Best scenarion for Weak reference is Caching Mechanism.
If we want to retreive some data and want to store in memory as well.
Here the same data will be requested again.
If we put the weak reference and garbage collector runs then it destroys the object on the Heap.

Soft Reference :
----------------
Soft references are used for more memory sensitive scenarios.
These are going to be Garbage collected only when the application is running low on memory.
As long as there is no critical free up space,the Garbage Collector will not touch softly reusable objects.
Java Gaurantees that all the soft referenced objects are cleaned up before it throws an OutOfMemoryError.

Phantom Reference :
-------------------
Phantom reference are used to schedule post-mortem clean up actions.
Since we know for sure that Objects are no longer Live.
Phantom references are considered preferably as Finalizers.

How Strings are Referenced :
----------------------------
Strings are Immutable that means each time we do something with string,another object is created actually on the Heap.
For String Java manages a String Pool Memory.This means that Java Stores and reuse Strings whenever possible.
This is mostly true for String literals.

	String local_prefix="297";
	String prefix="297";
	
	if(""=="")
	{
		sysout("Strings are Equal");
	}
	else
	{
	sysout("Strings are Different");
	}

We can force the JVM to add the String to the SCP i.e String Content Pool we use intern().

Garbage Collection Process :
----------------------------
Depending on the type of reference that a variable from the stack holds to an object from the Heap,
At certain point in time,that object becomes eligible for Garbage Collector.








Garbage Collector Types :
-------------------------




Tips and Tricks For Java Memory Management :
--------------------------------------------



 
############################################################  11.Dynamic Class Loading (DZone) ###############################################################

Class.forName is used to load the class dynamically where we does not know the class name before hand.
Once the Class is loaded we will use newInstance() to create the object dyanmically.

############################################################ 12.JDK vs JRE vs JVM (guru99)  ##################################################################

JDK is a software Development Kit,JRE is a software bundle that allows us Java Program to run where as JVM is an environment for executing Byte Code.

JDK :
-----
JDK contains tools required to write Java Programs and JRE to execute them.Tools like Debugger,Compiler etc.
It includes Compiler,Application Launcher and AppletViewer etc.
Compiler converts the code written in Java into Byte Code.
Java Application Launcher opens JRE which loads the necessary Classes ane executes the Main Method.

JRE :
-----
JRE contains class libraries,JVM and other supporting files etc.
If we want to run any Java Program then JRE must be installed in our system.

JVM :
-----
JVM provides platform independent way of executing Java Source Code.






