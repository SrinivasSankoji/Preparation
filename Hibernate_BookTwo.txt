1.JDBC Disadvantages and Advantages									(Book Two)	[03-AUG-2021]  (Done)
2.Session Interface Methods                                         (Book Two)	[09-AUG-2021]  (Done)
3.SessionUtil File Creation using Singleton Pattern                 (Book Two)	[09-AUG-2021]  (Done)
4.First Level Cache                                                 (Book Two)	[09-AUG-2021]  (Done)
5.Second Level Cache                                                (Book Two)	[09-AUG-2021]  (Done)
6.Cascade                                                           (Book Two)	[12-AUG-2021]  (Done)
7.Fetching Strategies                                               (Book Two)	[12-AUG-2021]  (Done)
8.Table Per Class                                                   (Book Two)	[03-AUG-2021]  ()
9.Table Per Concrete Class                                          (Book Two)	[03-AUG-2021]  ()
10.Table Per SubClass                                               (Book Two)	[03-AUG-2021]  ()
11.Joins in Hibernate                                               (Book Two)	[12-AUG-2021]  (Done)
12.Derived Properties in Hibernate                                  (Book Two)	[12-AUG-2021]  (Done)
13.Performance Tuning in Hibernate                                  (Book Two)	[12-AUG-2021]  (Done)
14.Hibernate Mutable                                                (Book Two)	[12-AUG-2021]  (Done)
15.Relationship in Hibernate                                        (Book Two)	[03-AUG-2021]  ()

***************************************************** 1.JDBC Disadvantages and Advantages	*****************************************************

1.Large Projects are not suitable.
2.JDBC does not support Polymorphism,Abstraction and Polymorphism.
3.JDBC Exceptions are Checked Exceptions ie we need to handle Checked Exceptions.
Should be written in try catch block.
Exceptions in ORM are unchecked Exceptions.
4.SQLExceptionTranslator converts propriatory Database Vendor Exceptions into user defined Exceptions supported by ORM
where as it is not supported by JDBC.
5.In SIngleto Design Pattern we write the JDBC Code.

1.JDBC is suitable for small scale projects.
2.JDBC is limited for small no of functionalities
3.To access large data from database performance is good and simple syntax.

***************************************************** 2.Session Interface Methods *************************************************************

1.public Serialized Object save(Object obj) throws HibernateException :
-----------------------------------------------------------------------
Stores the data and returns the object with the identifier which is generated by the Generator Class.
Whenever we are using any Generator Class to generate the identifier,At that time If we want to know the identifier value we use save().

2.public void persist(Object obj) throws HibernateException :
-------------------------------------------------------------
Stores the data and returns void.
We cannot identify whether the record is inserted or not.
If we don't want to know the generated value we use persist().

3.public void update(Object obj) throws HibernateException :
------------------------------------------------------------
If the record is present then update() updates the record and it does not return any value.
It internally uses jdbc update().
If the record is not present then it will not throw any Exception.

4.public Object merge(Object obj) throws HibernateException :
-------------------------------------------------------------
If the record exists in the database the merge() performs the update operation.
Returns Persistent object which contains the Identifier value and updated values.
If the Record does not exists then merge() performs the insert operation.
merge() always returns the Object which contains updated or inserted Identity values.

Session session=SessionUtil.getSession();
session.getTransaction().begin();
Account account1=(Account)session.get(Account.class,1001); // Object with Id 1001 is placed into the Session.
Account account2=new Account();
account2.setAccointId(1001);
account2.setName("Bhaumik");
account2.setMonth("November");
session.update(account2);  // To resolve the Error we use merge()
session.getTransaction().commit();
session.close();

Here we will get org.hibernate.NonUniqueObjectException
A different Object with the same identifier is already available on the Session object.
we can't place two different Object's of same type with the same identifier in the Session Object.
To resolve this problem we go for merge().
If we use merge() we won't get any Exception and account2 Object will be updated with the Database.

Case 1 : merge() to insert the Data
Session session=SessionUtil.getSession();
session.getTransaction().begin();
Account account=new Account();
account.setAccointId(1001);
account.setName("Bhaumik");
account.setMonth("November");
session.merge(account);  
session.getTransaction().commit();
session.close();

Whenever we call merge() on the session Object,First it will try to update the Account Object with the identifier 1001.
As we don't have the Account Object with the Identifier 1001 in the database,it will insert the record into the database.

Case 2 :merge() to update the Data 
Whenever we call merge() on the session Object,First it will try to update the Account Object with the identifier 1001.
As we have the Account Object with the Identifier 1001 in the database,it will update the record into the database.

Case 3 : merge() to detached State into Persistent State
Session session=SessionUtil.getSession();
session.getTransaction().begin();
Account account1=(Account)session.get(Account.class,1001);
Account account2=new Account();
account2.setAccointId(1001);
account2.setName("Bhaumik");
account2.setMonth("November");
session.merge(account2);  
session.getTransaction().commit();
session.close();

Whenever we call merge() on the Session Object first it will check is there any Object associated with Identifier 1001 is available in the Session or Not.
Here Identifier with 1001 is already available.
Then copy the state of account2 Object into account1 Object.
It will execute the update Query to update the data into the Database.

5.public void saveOrUpdate(Object obj) throws HibernateException :
------------------------------------------------------------------
This method performs either insert or update operation.
In case of merge() If the record exists then it perfroms update operation.
If the record does not exists then it performs insert operation.
In case of saveOrUpdate() first it performs insert operation and 
If the record exists then it performs insert operation.

6.public Object get(java.lang.class,serializableId) :
-----------------------------------------------------
get() returns null If the Object is not found on Cache as well as database.
get() is also called as "Early Loading".
Whenever we call the get() on the Session Object Tt will hit the database,Get the Data from the Database and stores the data into the Entity Object.
and Entity Object will be cached on to the Session Object.
As session.get() returns a fully initialized instance so it is available in in any future detached state.
use get() If it is sure that the Object exists.

Case 1 : SingleSession and Single time calling the get() 
After get() is called and If we modify the record into the Database.
If we call the get() again,we will not get the updated and get the Session Cached Data.


Session session=SessionUtil.getSession();
session.getTransaction().begin();
Account account=(Account)session.get(Account.class,1001);
session.getTransaction().commit();
session.close();

Case 2 :SingleSession and Multiple times calling the get() 
Session session=SessionUtil.getSession();
session.getTransaction().begin();
System.out.println("Before updating the Database");
Account account=(Account)session.get(Account.class,1001);
// Modify the Data in the Database
Account account=(Account)session.get(Account.class,1001);
System.out.println("After updating the Database");
session.getTransaction().commit();
session.close();

After calling get() on the session object again If we call the get() on session object
It will check whether the object is available in session Object or not.
If the Object is available in session Object then it will not hit the database.
In the above case we won't get the updated Object because it is available in Session Object.

Case 3 : Creating multiple Sessions
Session session1=SessionUtil.getSession();
Session session2=SessionUtil.getSession();

Account account1=(Account)session.get(Account.class,1001);
//Modify the Data in the Database

If we call the get() on the session Object then it will check the Object is available in Session or not.
If the Object is available in Session then it won't hit the Database and gets the Data from the Session Object. 
Problem here is to get the updated record,every time we have to create new Session Object .
To resolve this problem we use refresh().

7.refresh() :
--------------
Whenever we call refresh() Hibernate compares Object data with the Database data.
If it finds any difference then it will again execute Select query and updates the Object data.

8.load() :
----------
throws org.hibernate.ObjectNotFoundException If the Object is not found on Cache as well as Database.
load() is Lazy Loading ie when we call load() on the Session Object It will not hit the Database and returns the Proxy Object.
When we try to access the non identifier property from the Proxy Object,then at that time it will hit the Database and
loads the Entity Object.
As Session.load() returns proxy instance it is not fully available in detached state.
Use Session.load() If a fully initialized instance is not needed which saves Database trip.

9.public Connection close() throws HibernateException :
-------------------------------------------------------
Once the transaction is completed we need to close the session.
When we close the session all the associatd objects with that Session is deassociated and associated Connection object is also closed.
It is not strictly necessary to close the session and atleast we must disconnect.

10.public void clear() :
-----------------------
This method is used to deassociate all the Objects from the Session Object ie
All the Objects are moved from Persistent State to Detached State.

11.public void evict(Object object) throws Hibernate Exception :
----------------------------------------------------------------
This method is used to deassociate the specified Object from the Session Object.

12.public boolean contains(Object obj) :
----------------------------------------
This method is used to check whether the Object is associated with Session or not.

13.public boolean isConnected() :
---------------------------------
This method is used to check whether the Connection Object is associated with Session or not.

14.public void flush() throws HibernateException :
--------------------------------------------------
This method is used to synchronize Session data with database.
Whenever we call session.flush() Hibernate compares Object data with the record in the database.
If it finds any difference then it will execute the update Query to update the data in the database.
whenver we call txn.commit() Hibernate also compares the Object data with the corresponding record in the Database.
If it finds any difference then it will execute the update Query to update the data in the database.
when txn.commit() is called Object is in sync with database.
session.flush() should not be called after txn.commit().

15.Difference between update() and merge() :
--------------------------------------------
If the Object is not associated with the session ie session Object does not contain an Entity with the Identifier and
has a matching record in the database the we call the update().
Irrrespective of the state of a session,If there is a need to save the modification in the databse,then we go for merge().

16.public Serializeable getIdentifier(Object obj) throws HibernateException :
-----------------------------------------------------------------------------
To know the Object Identifier value at runtime we need to call getIdentifier().

Account account=(Account)session.get(Account.class,1001);
Serializable id=session.getIdentifier(account); 

***************************************************** 3.SessionUtil File Creation using Singleton Pattern  *************************************

public Class SessionUtil
{
	private static SessionFactory sessionFactory;
	static{
	try{
	sessionFactory=new org.hibernate.cfg.configuration().configure().buildSessionFactory();
	}
	catch(Excception e)
	{
	}
	public static Session getSession()
	{
	return sessionFactory.openSession();
	}
}
 
***************************************************** 4.First Level Cache ********************************************************************

While working with web Application we will face so many problems due to Database,particularly when the Database traffic is very high.
Hibernate is well used because of its performance only.
Some techniques are necessary to maintain its performance and one of them is Caching.
Hibernate Caching is the best technique to solve the problem.
The Cache actually stores the data already loaded from the Database.
So that the traffic between the Application and Database will be reduced when the Appliction wants to access the data again.
Most of the times Application will work with the data in the Cache only and whenever other data is needed,Database will be accessed.

Hibernate uses two different Cache for Objects

First Level Cache
Second Level Cache

First Level Cache always associated with Session Object.
Hibernate uses this Cache by default.
Here it process one Transaction after another Transaction ie won't process one Transaction many times.
Reduces the no of SQL queries needs to be generated within the given transaction.
Instead of updating every modification done in one Transaction,
It updates the modification only at the end of the Transaction.

***************************************************** 5.Second Level Cache *******************************************************************

Second Level Cache always associated with SessionFactory Object.
While running the Transactions,In between it loads the Object at the SessionFactory Level so that 
Objects will be available to the entire Application and does not bound to a Single value.
Since the objects are already loaded in the Cache,whenever an Object has to be returned 
at that time no need to go for database transaction and gets from the Cache.

***************************************************** 6.Cascade  ****************************************************************************
 
According to Database rule a Table should not contain more than 250 Columns.
But in industries so many tables are there which Contains more than 250 Columns.
In this scenario we have to split the Table to satisfy the Database rules.

Consider the scenario of ACCOUNT Table and ACCOUNT_PLUS Table.
Whenever we are going to insert the Data in the ACCOUNT Table,first Child Table columns should be inserted by generating a unique number.
The same unique Number should navigate to the Parent to fill the Columns of the Parent Table for that Account.

Cascade attribute is mandatory whenever we are applying reltionship between Objects.
Cascade attribute transfers the operation done on one Object into its related Child class Objects ie delegating the operation to the Child Class.
Suppose If we are deleting an Account from Account Table,the same operation should also be affected to its Child nothing but ACCOUNT_PLUS Table.

If we write cascade=ALL ie Changes at Parent Class Object will be effected to the Child Class Object.
All the operations like insert,delete and update at Parent class object will be effected to the Child Class Object.
If we perform insert operation on Parent class object,then Child class object will also be inserted into the Database.

Default value of Cascade is none ie No operation will be transferred to the Child class.
Cascade has the values of

none
save
update
save-update
delete
all
all-delete-orphan
delete-orphan

all-delete-orphan :
-------------------
In Hibernate Relationship,If we delete the Parent Object from the Database then the Child Object related to the Parent Object
will also be loaded into Collection.
If we delete the Child Object form the Collection then the Relationship between Parent Object and Child Object will be removed.
But the reocrd in the Database remains as it is.
If we load the same Parent Object again then deleted Child Object will not be loaded and available in the Database.
All-Delete-Orphan means breaking the reltionship between Objects and also deleting the Objects from the Database.
In an Application If the Child record is removed from the Collection and If we want to delete the child record from the Database
we need to use the cascade attribute all-delete-orphan.

Orphan Record :
---------------
Orphan record means it is a record in the Child Table but it does not have any association with its Parent in the Child Application. 

***************************************************** 7.Fetching Strategies  *****************************************************

Hibernate uses fetching strategies to retreive its associated Objects If the Application needs to navigate within the Association.
Fetching Sretegies can be declared in the O/R mapping Data and can be overridden by a particular HQL query or Criteria Query.

If fetch=lazy means only identifier value of Child table ie ACCOUNT_PLUS is loaded into Session.
Whenver we are trying to access the non identifier values of ACCOUNT_PLUS,
then at that time Child Table values are loaded into the Session.
If we are getting the details from ACCOUNT Table then its Child Table Columns should also be loaded into the Session.
This can be decided by using fetch Attribute.

Join Fetching :
---------------
Hibernate retreives the associated instance or Collection in the same select Query using an Outer Join.

Select Fetching :
-----------------
Second select is used to retreive the associated instance or Collection unless we explicitly disable lazy fetching ie lazy=false.
Second select will only be executed when we access the association.

Subselect Fetching :
--------------------


Batch Fetching :
----------------
Batch Fetching is an optimization strategy for Select Fetching.
Hibernate retreives a batch of instances or Collection of instances in a SIngle select by specifying a list of primary keys or foreign keys.
Batch size is not how many records inside Collection are loaded but how many Collections it should be loaded.

Lazy fetching vs Eager Fetching :
---------------------------------
Select Fetching is the Lazy Fetching.
Purpose of Lazy Fetching is memory Optimization ie save from Heap Error.
If we are loading too many Objects into Session we should go for Lazy Fetching.

Join Fetching is the Eager Fetcing.
Purpose of Join Fetching is optiization in terms of time.
Here Associations are fetched right at the time of Fetching Parent Object.
In this we don't make Database Call again and again.



inverse=true

***************************************************** 11.Joins in Hibernate   ***************************************************************

We use joins to select the data from multiple Tables with the SIngle Query when there exists a relationship.
Hibernate supports 4 types of Relationships.

Left Join
Right Join
Full Join
Inner Join

With Left Join Objects from both sides are selected ie
Matched records from Left Side Table are selected and unmatched Records from Right Side are selected.

**************************************************** 12.Derived Properties in Hibernate *****************************************************

Hibernate provides us the ability to include properties that do not map to any column in the Database.
These are the fields that are calculated based on Formua applied on other Columns.

*****************************************************13.Performance Tuning in Hibernate *****************************************************

Dynamic insert attribute tells to Hibernate whether to include null properties in the SQL insert statement or not.
Default value of Dynamic insert is false ie include null properties in the Hibernate SQL insert statement. 
When dynamic-insert=true,It won't generate any unnecessary Columns and generates only necessary Coulmns for the insertion.

dynamic-update=true ie it won't include the unmodified properties in the Hibernate SQL Statement.
SQL Update statement Contains only modified fields.
Default value of dynamic-update is false ie it includes unmodified properties/fields.

***************************************************** 14.Hibernate Mutable  *****************************************************************              

In Hibernate mutable is set to true in Class and its related Collections.
It means the Class or Collection are allowed to add,update and delete.
On the Other hand If the mutable is changed to "false" it has different meaning in Class and its related Collection.

If mutable is set to false or @Immutable is declared in Class element,Updates to the Class will be ignored but
No Exception will be thrown and only add and delete operations are allowed.

If mutable is set to false or @Immutable is declared for Collection,
Add and delete-orphan are not allowed for the Collection and throws Exception.
Update and cascade-delete are allowed.
When we specify cascade delete ie Parent Class is deleted, all its Child class will be deleted.

***************************************************** 15.Relationship in Hibernate **********************************************************
