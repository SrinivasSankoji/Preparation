
Annotation List :
*****************
@Interceptor                  				(springframework.guru)             [17-OCT-2019]  (Done)
@ConfigurationProperties
@Conditional
@ConditionalOnClass
@ConditionalOnProperty
Service Locater Factory Bean	
@SpringBootApplication 						(howtodoinjava)
@AutoConfiguration							(howtodoinjava)									  

Spring Core Annotations :
*************************
@Bean									    [31-OCT-2019]  (Done)
@Value										[31-OCT-2019]  (Done)
@Autowired									[31-OCT-2019]  (Done)
@Qualifier									[31-OCT-2019]  (Done)
@Primary									[31-OCT-2019]  (Done)
@Required									[31-OCT-2019]  (Done)
@Configuration								[31-OCT-2019]  (Done)
@EnableAutoConfiguration
@ComponentScan

Spring Web Annotations :
************************
@ExceptionHandler
@Controller Advice
@RequestBody							    [17-OCT-2019]  (Done)		
@Response Body							    [17-OCT-2019]  (Done)
@RestController
@RequestBodyAdvice						    [18-OCT-2019]  (Done)
@ResponseBodyAdvice						    [18-OCT-2019]  (Done)

Spring Stereotype Annotations :
*******************************
@Component									[17-OCT-2019]  (Done)			
@Controller                                 [17-OCT-2019]  (Done)
@Service                                    [17-OCT-2019]  (Done)
@Repository                                 [17-OCT-2019]  (Done)

************************************ @Interceptor (springframework.guru and o7planning and javainuse) ****************************************************************

In Spring whenever a request is sent to the Controller,It will have to pass through the Interceptors(Zero or More) before being processed by the Controller.
Spring Interceptor is a concept similar to Servlet Filter.
Spring Interceptor is applied to all the requests that are sending to the Controller.
We can use Interceptors to do some activities such as writing Logs,adding or updating Configurations before request is being processed by the Controller.

Our Interceptor must implement org.springframework.web.servlet.HandlerInterceptor (or) org.springframework.web.servlet.hadler.HandlerInterceptorAdaptor Class.
We need to implement the abstract methods 

1.preHandle() :
---------------


2.postHandle() :
----------------


3.afterCompletion() :
---------------------



Difference between Filter and Interceptor :
-------------------------------------------
A Servlet Filter is used in the Web Layer only and we cannot use it outside of the Web Context.
Interceptors can be used any where.
For Authentication of Web Pages we use Servlet Filter where as for Security Stuff in the Business Layer or Logging/Bug Tracking we use Interceptors.
Interceptors does not rely on the Servlet Container where as filter depends on Servlet Container.
HTTP Specification does not openly prevent any HTTP Method for having a Request Body but It is wise not to use Get Method.
Because HTTP Servers and Proxy Servers may discard the Request Body for GET Request and fail in unexpected Ways.

**************************************   Spring Web Annotations  *****************************************************

@RequestBody (springframework.guru):
************************************
@RequestBody Annotation Indicates That a Method Parameter Should bound to the value of the HTTP Request Body.
HttpMessageConverter is Responsible for Converting from HttpRequest Message to Object and assigned to the Variable.
@RequestBody does not depend on the Media Type.

@ResponseBody (javabyexamples):
*******************************
@ResponseBody Annotation Indicates that The Result Type Should be Written Straight into the Response Body
In What Ever Format We Specify an Internally Uses HttpMessageConverter to Convert The HTTP Message Into Specified Format.
Here We Have to Annotate The Controller Method With @ResponseBody

@RequestBodyAdvice (javabyexamples):
************************************
@RequestBodyAdvice allows the Customization of The Request Body Before It is Converted into an Object.
Additionally We Can Modify The Converted Object Before It Is Passed into Our Controller Methods.

We Need To Implement all The Four Methods of Request Body Advice.
We Have supports()Method Which decides whether the Implementation should run for the Current Request.
We Have beforeBodyMethod() Method which runs before Spring MVC Reads The Request Body.
We Have afterBodyRead() Method which Runs After The Body is Read and Converted into an Object.
In After bodyRead() Method ,We Have an Access to The Converted Object and Cast Into an Appropriate Type
and We Can Also Modify The Fields.

Finally When The Request Body is Empty, We Can Put Our Custom Logic into handleEmptyBody() Method.
We Must Return a Value to Use ,Either Provide The Object or an Entirely New Object.

@ResponseBodyAdvice (javabyexamples):
*************************************
By Using @ResponseBodyAdvice We Can Modify the Response Before Spring MVC Writes it to the Response Body.
Since We are Annotating The Controller with @RestController all the End Point Methods Implicitly will have the 
@ResponseBody Annotation.
As A Result Spring MVC will Write the Method Return Value to the Response.
@ResponseBodyAdvice allows the Customization of the Response Object Before Spring MVC Writes it to the Response Body.
ResponseBodyAdvice has Two Methods :
Supports() decides whether the Implementation should run for the Current Response.To Perform This Decision Spring MVC 
Provides the Return Type and Converter Type.
beforeBodyWrite() runs after the Execution of the Controller Method But Before The Response is Written.
Here We Have The Chance Modify the Response Object.


**************************************   Spring Core Annotations  *****************************************************

@Configuration :
****************
@Configuration is defined on Classes that defines Beans.
@Configuration is an Analog for XML File i.e It is a Configuration Using Java Class.
Java Class Annotated with @Configuration is a Configuration by itself and will have methods to instantiate the configured Dependencies.

@Qualifier :
************
By using @Qualifier we can define which Beans we want to use.
Moreover Spring allows us to Create Custom Annotations for Qualifying the Beans.
There May Be Scenarios where we Create More than One Bean of the Same Type and Want to Wire them.
Here We Use @Qualifier Annotation along with the Autowired Annotation.

@Bean :
*******
@Bean is a Method Level Annotation and Supports Some of the Attributes such as init-method Using @Lazy,destroy-method,
Auto wiring Using @Autowired and Bean Name Using @Qualifier.
@Bean Annotation May Be Used on Any Class Directly or Indirectly Annotated with @Component.
Method Annotated With @Bean can be Used Any Where in the Application Using @Autowired Annotation.

@Required :
***********
@Required Annotation is a Method Level Annotation and Applies to Setter Method of a Bean.
This Annotation indicates that Setter Method Must be Configured to be Dependency Injected with a Value at Configuration Time.

@value :
********
@value Annotation is used to Assign Default Values to the Variables and Method Arguments.
We Can also Read Spring Environment Variables as well as System Variables Using @Value Annotation.
Spring @Value Annotation also Supports Spring Expression Language.
@Value Annotation Argument Can be String Only But Spring Tries to Convert into Specified Type.

@DependsOn :
************
By Using @DependsOn Annotation We Can Force Spring IOC Container to Initialize One or More Beans 
Before The Bean Which is Annotated With @DependOn
@DependsOn Annotation May Be Used on Any Class Directly or InDirectly Which has Annotated With @Component or
Methods Annotated With @Bean.

@Lazy :
*******
By Default Spring Container Creates and Initializes all Singleton Beans at the Time of Application Start Up.
We Can Prevent this PreInitialization of Singleton Bean By Using @Lazy Annotation.
@Lazy Annotation May Be Used on Any Class Directly or Indirectly Annotated with @Component or on Methods 
Which are Annotated with @Bean.

@Lookup :
*********


@Primary :
**********
@Primary Annotation can be used to give high preference to a Bean when there are multiple Beans of the same Type.

@Scope :
********
@Scope Annotation Can be Applied to Define The Scope of a Class Annotated With @Component or a Method Annotated With @Bean.
Here Scope Can be Singleton,Prototype,Request,Session,Global Session or Some Custom Type.

@Profile :
**********
By Default Spring Beans are loaded at the time of Application Start Up.
Here Class Can be Annotated with @Component or a Method can be Annotated With @Bean.
Here The Requirement is Spring has to load the particular @Component Class or @Bean Method when the particular Profile is Active then we use @Profile.
We Can Configure the name of the Profile with the value argument of the Annotation.

@Import :
*********
By using @Import Annotation we can Import one or more @Configuration Classes.
Here The @Beans are loaded from one configuration class to another Configuration class i.e 
To load the Bean definitions from One Configuration Class to another Configuration Class we use @Import Annotation.

@ImportResource :
*****************
@ImportResource Annotation can be Used to Load The Beans Which are Defined Inside application-context.xml into ApplicationContext.

@PropertySource :
*****************
@PropertySource Annotation Provides a Convenient and Declarative Mechanism For Adding Properties File
To The Spring Environment.
It has to be Used in Conjunction with @Configuration Class.
By Default Spring Identifies the application.properties and If We Want Spring to Identify the User Defined Properties File
We Use @PropertySource Annotation That Accepts the Location of The Properties File.

@PropertySources :
******************
If We Want to Identify Multiple User Defined Properties Files By Spring,We Use @PropertySources Annotation.


**************************************   Spring Stereotype Annotations  *****************************************************
 
@Component :
************
This Annotation is Used on Classes to Indicate that it is a Spring Component or Spring Class as a Bean.
By Adding @Component Annotation to the Class Component Scanning Mechanism of Spring Can add into the Application Context.

@Controller :
*************
@Controller Annotation is Used to Indicate the Class is a Spring Controller.
This Annotation is Used to Identify Controllers For Spring MVC or Spring Web Flux.

@Service :
**********
This Annotation is Used on Class.
@Service Marks a Java Class that Performs a Service Such as Executes The Business Logic,Perform Calculations and
Call External API's.
This Annotation is a Specialized Form of @Component Annotation intended to be Used in the Service Layer.

@Repository :
*************
This Annotation is Used on Classes Which Directly Access the Database.
@Repository Annotation Automatic Translation Feature.
For Example When an Exception Occurs in the @Repository,
There is a Handler For That Exception and there is no Need to Add Try Catch Block.
Here We Can Use DataAccessException or ExceptionTranslator to Handle The Exceptions Irrespective pf JPA Vendor.

