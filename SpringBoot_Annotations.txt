
Spring Core Annotations :
*************************
@Bean									    [31-OCT-2019]  (Done)
@Value										[31-OCT-2019]  (Done)
@Autowired									[31-OCT-2019]  ()
@Qualifier									[31-OCT-2019]  (Done)		(IOC)	
@Primary									[31-OCT-2019]  (Done)		(IOC)
@Required									[31-OCT-2019]  (Done)		
@Configuration								[31-OCT-2019]  (Done)		(IOC)
@EnableAutoConfiguration                    [18-NOV-2021]  (Done)
@ComponentScan                              [18-NOV-2021]  (Done)
@DependsOn                                  [31-OCT-2019]  (Done)		(IOC)
@Lazy                                       [31-OCT-2019]  (Done)		(IOC)
@Lookup                                     [31-OCT-2019]  ()
@Scope                                      [31-OCT-2019]  (Done)		(IOC)
@Profile                                    [31-OCT-2019]  (Done)
@Import                                     [31-OCT-2019]  (Done)	    (IOC)
@ImportResource                             [31-OCT-2019]  (Done)		(IOC)
@PropertySource                             [31-OCT-2019]  (Done)		(IOC)
@PropertySources                            [31-OCT-2019]  (Done)		(IOC)

Spring Stereotype Annotations :
*******************************
@Component									[17-OCT-2019]  (Done)			
@Controller                                 [17-OCT-2019]  (Done)
@Service                                    [17-OCT-2019]  (Done)
@Repository                                 [17-OCT-2019]  (Done)

Spring Web Annotations :
************************
@ExceptionHandler
@Controller Advice
@RequestBody							    [17-OCT-2019]  (Done)		
@ResponseBody							    [17-OCT-2019]  (Done)
@RestController
@RequestBodyAdvice						    [18-OCT-2019]  (Done)
@ResponseBodyAdvice						    [18-OCT-2019]  (Done)
@ResponseEntity

Annotation List :
*****************
@Interceptor                  				(springframework.guru)             [17-OCT-2019]  (Done)
@ConfigurationProperties
@Conditional
@ConditionalOnClass
@ConditionalOnProperty
Service Locater Factory Bean	
@SpringBootApplication 						(howtodoinjava)
@AutoConfiguration							(howtodoinjava)	
@EnableWebMVC
HTMLMessageConverter

**************************************   Spring Core Annotations  *****************************************************
@Bean :
-------
@Bean is a Method Level Annotation and is a direct analog of </bean> in XML.
@Bean Annotation is applied on a method to specify that it returns a bean to be managed by Spring Application Context.
@Bean Annotation may be used on any class directly or indirectly annotated with @Component.
Method annotated with @Bean can be used any where in the Application using @Autowired Annotation.

@value :
--------
@value Annotation can be used to assign default values to the variables and Method Arguments.
@value Annotation can also be used to read Spring Environment Variables as well as System Variables.
@Value Annotation also Supports Spring Expression Language.
@Value Annotation Argument can be String only but Spring tries to convert into specified type.

@Autowired :
------------

@Qualifier :
------------

		@Service("userServiceImpl")
		public class UserServiceImpl implements UserService {
			@Override
			public void enableUser() { }
		}
		@Service("defaultUserService")
		public class DefaultUserService implements UserService {

		  @Override
		  public void enableUser() {}
		}
		
There may be Scenarios where we create more than one bean of the same type and want to Autowire them.
By using @Qualifier Annotation we can define which beans we want to use.
Here we use @Qualifier Annotation along with the @Autowired Annotation.

		public class OrderFacade {
		  
		  @Qualifier("userServiceImpl")
		  @Autowired
		  private UserService userService;
		}
		
Note :
------
Without @Qualifier Annotation we can resolve ambiguity problem when we have more than one bean of the same type.
Spring framework uses the bean name as the default Qualifier value.

		@Service("userService")
		public class UserServiceImpl implements UserService {
			@Override
			public void enableUser() { }
		}
		
		@Service("defaultUserService")
		public class DefaultUserService implements UserService {

		  @Override
		  public void enableUser() {}
		}

		public class OrderFacade {
		  @Autowired
		  private UserService userService;
		}

@Primary :
----------
@Primary Annotation can be used to give high preference to a Bean when there are multiple beans of the same Type.
When we have multile beans of the same type we use @Qualifier("beanName") along with @Autowired Annotation.
Here @Qualifier won't be applicable at the Configuration time.
To resolve this issue we use @Primary Annotation.

@Primary Annotation can be applied on any Class diretly or indirectly anootated with @Component or methods annotated with @Bean.

@Required :
-----------
@Required Annotation is a method level annotation and is applied to the setter method of a Bean.
@Required annotation indicates that setter method must be configured to be dependency inejected with the value at Configuration time.

Note :
If we are using @Autowired Annotation on our setter Method we need not use @Required Annotation because by default @Autowired Annotation has true value for required Attribute.

	@Data
	public class Person implements Serializable{

	private static final long serialVersionUID = 1L;
	
	private College college;
	}

	@Configuration
	public class RequiredConfiguration {

	@Bean
	public College college() {
		College college = new College();
		college.setName("Partibha Degree College");
		college.setLocation("Siddipet");
		return college;
	}
	@Bean
	public Person person(College college) {
		Person person = new Person();
		person.setCollege(college);
		return person;
	}
	}
	
	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				RequiredConfiguration.class);
		Person person = context.getBean(Person.class);
		System.out.println(person.getCollege().getName());
		context.close();
	}
	
@Configuration :
----------------
@Configuration is an Analog for XML File i.e It is a Configuration using Java Class.
@Configuration is defined on Classes that defines one or more Beans.
Java Class Annotated with @Configuration is a Configuration by itself and will have methods to instantiate the configured dependencies.

@EnableAutoConfiguration :
--------------------------
@EnableAutoConfiguration enables automatic configuration features of SpringBoot Application based on the jars defined in the classpath.
@EnableAutoConfiguration also allows exclusion for us.

@ComponentScan :
----------------
@ComponentScan Annotation tells Spring where to pick the Spring Components explicitly.
The Classes Annotated with @Component,@Controller,@Service,@Repository,@Configuration,@RestController etc will be treated as Spring Components.

@DependsOn :
------------
By using @DependsOn Annotation we can force Spring Container to initialize one or more Beans before the bean which is Annotated with @DependOn
@DependsOn Annotation may be used on any Class directly or inDirectly which has Annotated with @Component or Methods Annotated with @Bean.

	@Bean
	@DependsOn(value = { "secondBean","thirdBean"})
	public FirstBean firstBean() {
		return new FirstBean();
	}

	@Bean
	public SecondBean secondBean() {
		return new SecondBean();
	}

	@Bean
	public ThirdBean thirdBean() {
		return new ThirdBean();
	}

@Lazy :
-------
Spring Container creates and initializes all the beans at the time of Application start up.
We can prevent this preInitialization of Singleton Bean by using @Lazy Annotation.
@Lazy Annotation may be used on Any Class directly or indirectly Annotated with @Component or on Methods which are Annotated with @Bean.

	@Bean
	@Lazy(value = true)
	public FirstBean firstBean() {
		return new FirstBean();
	}
	
	@Bean
	public SecondBean secondBean() {
		return new SecondBean();
	}   
	
	public static void main(String[] args) {
		AnnotationConfigApplicationContext context=new AnnotationConfigApplicationContext(LazyConfiguration.class);
		FirstBean firstBean=context.getBean(FirstBean.class);
		firstBean.test();
		context.close();
	}
	
At the time of Application Startup Only SecondBean is loaded and when we call the getBean() on FirstBean then FirstBean is loaded into ApplicationContext.

@Lookup :
---------

@Scope :
--------
@Scope Annotation can be applied to define the Scope of a Class Annotated with @Component or a Method annotated with @Bean.
Here Scope Can be Singleton,Prototype,Request,Session,Global Session or some Custom Type.

	@Bean
	@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)
	public UserService userService()
	{
		return new UserService();	
	}
	
	@Data
	@Service
	@Scope("prototype")
	public class UserService {

		private String name;
	}

@Profile :
----------
By Default Spring Beans are loaded at the time of Application Start Up.Here Class Can be Annotated with @Component or a Method can be Annotated With @Bean.
Here the Requirement is Spring has to load the particular @Component Class or @Configuration Class or @Bean Method when the particular Profile is Active then we use @Profile.
We Can Configure the name of the Profile with the value argument of the Annotation.

	@Configuration
	@Profile("dev")
	public class DevConfigurations {
		// Skipped Configurations
	}
	
Note :
Spring profiles helps in seggregating Application Configuration and make them available only in certain environments.

@Import :
---------
By using @Import Annotation we can Import one or more @Configuration Classes.
Here The @Beans are loaded from one configuration class to another Configuration class i.e 
To load the Bean definitions from One Configuration Class to another Configuration Class we use @Import Annotation.

@ImportResource :
-----------------
@ImportResource Annotation can be used to load the beans which are defined inside application-context.xml into ApplicationContext.

@PropertySource :
-----------------
@PropertySource Annotation provides a convenient and declarative mechanism for adding Properties File to the Spring Environment.
It has to be used in Conjunction with @Configuration Class.
By default Spring identifies the application.properties.
If we want Spring to identify the user defined Properties File we use @PropertySource Annotation that accepts the location of the Properties File.

	@Configuration
	@PropertySource("classpath:application.properties")
	public class PropertySourceConfiguration {

@PropertySources :
------------------
If we want to identify multiple user defined Properties Files by Spring we use @PropertySources Annotation.

**************************************   Spring Stereotype Annotations  *****************************************************
 
@Component  :
-------------
This Annotation is used on Classes to indicate that this is a Spring Component or Spring Bean.
When we add @Component Annotation,Spring Framework will add these Classes for Dependency Injection when Annotation based Configuration and Classpath scanning is used.

@Controller :
-------------
@Controller Annotation is used to indicate the Class is a Spring Controller.
This Annotation is used to identify Controllers for Spring MVC or Spring Web Flux.

@Service :
----------
This Annotation is used on Class.
@Service marks a Java Class that performs a service such as executes the Business Logic,perform calculations and call External API's.
This Annotation is a specialized form of @Component Annotation intended to be used in the Service Layer.

@Repository :
-------------
This Annotation is used on Classes which directly access the Database.
@Repository Annotation has Automatic Translation Feature.
For Example When an Exception Occurs in the @Repository There is a handler for that Exception and there is no need of Try Catch Block.
Here we can use DataAccessException or ExceptionTranslator to handle the Exceptions irrespective of JPA Vendor.

**************************************   Spring Web Annotations  *****************************************************

@RequestBody (springframework.guru) :
-------------------------------------
@RequestBody Annotation Indicates That a Method Parameter Should bound to the value of the HTTP Request Body.
HttpMessageConverter is Responsible for Converting from HttpRequest Message to Object and assigned to the Variable.
@RequestBody does not depend on the Media Type.

@ResponseBody (javabyexamples) :
--------------------------------
@ResponseBody Annotation Indicates that The Result Type Should be Written Straight into the Response Body
In What Ever Format We Specify an Internally Uses HttpMessageConverter to Convert The HTTP Message Into Specified Format.
Here We Have to Annotate The Controller Method With @ResponseBody

@RequestBodyAdvice (javabyexamples) :
-------------------------------------
@RequestBodyAdvice allows the Customization of The Request Body Before It is Converted into an Object.
Additionally We Can Modify The Converted Object Before It Is Passed into Our Controller Methods.

We Need To Implement all The Four Methods of Request Body Advice.
We Have supports()Method Which decides whether the Implementation should run for the Current Request.
We Have beforeBodyMethod() Method which runs before Spring MVC Reads The Request Body.
We Have afterBodyRead() Method which Runs After The Body is Read and Converted into an Object.
In After bodyRead() Method ,We Have an Access to The Converted Object and Cast Into an Appropriate Type
and We Can Also Modify The Fields.

Finally When The Request Body is Empty, We Can Put Our Custom Logic into handleEmptyBody() Method.
We Must Return a Value to Use ,Either Provide The Object or an Entirely New Object.

@ResponseBodyAdvice (javabyexamples) :
--------------------------------------
By Using @ResponseBodyAdvice We Can Modify the Response Before Spring MVC Writes it to the Response Body.
Since We are Annotating The Controller with @RestController all the End Point Methods Implicitly will have the 
@ResponseBody Annotation.
As A Result Spring MVC will Write the Method Return Value to the Response.
@ResponseBodyAdvice allows the Customization of the Response Object Before Spring MVC Writes it to the Response Body.
ResponseBodyAdvice has Two Methods :
Supports() decides whether the Implementation should run for the Current Response.To Perform This Decision Spring MVC 
Provides the Return Type and Converter Type.
beforeBodyWrite() runs after the Execution of the Controller Method But Before The Response is Written.
Here We Have The Chance Modify the Response Object.

************************************ @Interceptor (springframework.guru and o7planning and javainuse) ****************************************************************

In Spring whenever a request is sent to the Controller,It will have to pass through the Interceptors(Zero or More) before being processed by the Controller.
Spring Interceptor is a concept similar to Servlet Filter.
Spring Interceptor is applied to all the requests that are sending to the Controller.
We can use Interceptors to do some activities such as writing Logs,adding or updating Configurations before request is being processed by the Controller.

Our Interceptor must implement org.springframework.web.servlet.HandlerInterceptor (or) org.springframework.web.servlet.hadler.HandlerInterceptorAdaptor Class.
We need to implement the abstract methods 

1.preHandle() :
---------------


2.postHandle() :
----------------


3.afterCompletion() :
---------------------

Difference between Filter and Interceptor :
-------------------------------------------
A Servlet Filter is used in the Web Layer only and we cannot use it outside of the Web Context.
Interceptors can be used any where.
For Authentication of Web Pages we use Servlet Filter where as for Security Stuff in the Business Layer or Logging/Bug Tracking we use Interceptors.
Interceptors does not rely on the Servlet Container where as filter depends on Servlet Container.
HTTP Specification does not openly prevent any HTTP Method for having a Request Body but It is wise not to use Get Method.
Because HTTP Servers and Proxy Servers may discard the Request Body for GET Request and fail in unexpected Ways.