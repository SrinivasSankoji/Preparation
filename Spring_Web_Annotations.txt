
@ControllerAdvice							(howtodoinjava)					[05-DEC-2021]  (Done)
@ExceptionHandler							(learnjava)						[05-DEC-2021]  (Done)
@RequestBody								(websystique)					[17-OCT-2019]  (Done)		
@ResponseBody							    (websystique)					[17-OCT-2019]  (Done)
@RestController                             ()								[02-DEC-2021]  ()
@RequestBodyAdvice						    (javabyexamples)				[18-OCT-2019]  (Done)
@ResponseBodyAdvice						    (javabyexamples)				[18-OCT-2019]  (Done)
@ResponseEntity                             ()								[02-DEC-2021]  ()
@Interceptor                  				(springframework.guru)          [17-OCT-2019]  (Done)
@ConfigurationProperties					()								[02-DEC-2021]  ()
@Conditional                                ()                              [02-DEC-2021]  ()
@ConditionalOnClass                         ()                              [02-DEC-2021]  ()
@ConditionalOnProperty                      ()                              [02-DEC-2021]  ()
Service Locater Factory Bean	            ()                              [02-DEC-2021]  ()
@SpringBootApplication 						(howtodoinjava)                 [02-DEC-2021]  ()
@AutoConfiguration							(howtodoinjava)	                [02-DEC-2021]  ()
@EnableWebMVC                               (javapedia)                     [04-DEC-2021]  (Done)
HTMLMessageConverter                        (websystique)                   [05-DEC-2021]  ()
@Controller vs @RestController              (javacodegeeks)                 [02-DEC-2021]  (Done)
@Repository                                 ()                              [02-DEC-2021]  ()
CrudRepository vs JpaRepository             (netsurfingzone)                [03-DEC-2021]  (Done)
@EnableJpaRepositories                      ()                              [02-DEC-2021]  ()
@EntityScan                                 ()                              [02-DEC-2021]  ()
WebMvcConfigurationSupport                  ()								[02-DEC-2021]  ()

*************************************************** @ControllerAdvice(howtodoinjava) ********************************************************************************
If we want to centralize the Exception Handling logic to one class which is capable of handling the Exceptions thrown form any controller class/handler class
then we use @ControllerAdvice Annotation.
We can think of it as an Interceptors for Exception.

*************************************************** @ExceptionHandler(learnjava) ********************************************************************************
@ExcptionHandler Annotation can be applied to a Method in a Controller Class and handles only Excpeptions that occures in the Controller where it is sepcified.

*************************************************** @RequestBodyAdvice (javabyexamples) ***************************************************
@RequestBodyAdvice allows the customization of the Request Body before it is converted into an Object.
Additionally we can modify the converted object before it is passed into our controller Methods.

RequestBodyAdvice has 4 Methods :
We have supports() which decides whether the implementation should run for the Current Request or Not.
We have beforeBodyRead() which runs before Spring MVC reads the Request Body.
We Have afterBodyRead() which runs after the body is read and converted into an Object.
In After bodyRead() we have an access to the Converted Object and cast into an Appropriate Type.we can also modify the fields.

Finally when the Request Body is Empty,we can put our custom logic into handleEmptyBody().
We must return a value to use,either provide the Object or an entirely New Object.

*************************************************** @ResponseBodyAdvice (javabyexamples) **************************************************
@ResponseBodyAdvice allows the customization of the Response before Spring writes it to the Response Body.
Since we are Annotating the controller with @RestController all the End Point methods implicitly will have the @ResponseBody Annotation.
As a result Spring MVC will write the method return value to the Response.

ResponseBodyAdvice has 2 Methods :
supports() decides whether the implementation should run for the Current Response or Not.
beforeBodyWrite() runs after the execution of the Controller Method but before the Response is written.
Here we have the chance to modify the Response Object.

***************************************************  @RequestBody (springframework.guru/websystique) *************************************************
If the Method parameter is annotaed with @RequestBody,Spring will bind the incoming Request body to the parameter. 
Behind the scenes HttpMessageConverter can be used to convert the Request body into domain Object and assign it to a variable.
@RequestBody does not depend on the Media Type.

Note :
------
If the Post body contains Json or XML and Jackson Library is found in our Classpath,Spring will delegate the conversion to MappingJackson2HttpMessageConverter.
ResponseEntity represents the entire HTTP Response.

*************************************************** @ResponseBody (javabyexamples) *******************************************************
If a Method is annotated with @ResponseBody Spring will bind the response Object to the outgoing Response Body.
Behind the scenes HttpMessageConverter can be used to convert Object to the Response Body.
Here we have to Annotate the Controller method With @ResponseBody.

*************************************************** @Controller vs @RestController  *******************************************************
The Fundemental difference between Web Application and Rest API is that Web Application returns HTML+CSS+JavaScript where as Rest API returns the data in the form of JSON or XML.
Job of @Controller is to create a Map of Model Object and find a view.
But @RestController simply returns the Object and the Object data is directly written into HTTP Response as a Json or XML.

@RestController is @Controller + @ResponseBody and avoids the need of prefixing every method with @ResponseBody.

*************************************************** @EnableWebMVC  ************************************************************************
Noramlly we use @EnableWebMvc for Spring Application.
This marks the Application as Web Application and configurers all its related Classes like DispatcherServlet.
Spring Boot automatically adds the @EnableWebMvc on the classpath.This flags the Application as Web Application and activates the key behaviors such as 
setting up DispatcherServlet.

*************************************************** CrudRepository vs JpaRepository *******************************************************
CrudRepository :
----------------
CrudRepository extends JpaRepository Interface.
CrudRepository provides methods to perform CRUD Operations.
saveAll() of CrudRepository returns Iterable
If we want to perform only CRUD Operations use the CrudRepository Interface.

JpaRepository :
---------------
JpaRepository extends PagingAndSortingRepository and QueryByExampleExecutor Interface.
PagingAndSortingRepository further extends CrudRepository.
JpaRepository provides additional methods like flush(),saveAndFlush() and deleteInBatch().
saveAll() of JpaRepository returns List
If we want to perform CRUD operations as well as batch operations use the JpaRepository Interface.

*************************************************** @Interceptor (springframework.guru and o7planning and javainuse) **********************
In Spring whenever a request is sent to the Controller it will have to pass through the Interceptors(Zero or More) before being processed by the Controller.
Spring Interceptor is a concept similar to Servlet Filter.
Spring Interceptor can be applied to all the requests that are sending to the Controller.
We can use Interceptors to do some activities such as Authentication,writing Logs,validations of fields in the Header,inclusion of some fields in the Response
before request is being processed by the Controller.

Our Interceptor must implement org.springframework.web.servlet.HandlerInterceptor
We need to override the required methods

1.preHandle() :
---------------
This method will be invoked by the Container while sending the request to the Controller.
Typically used If we want to send some other data along with the request data or to modify the request data.

2.postHandle() :
----------------
This method will be invoked by the Container while sending the response from the Server.
We can write some custom logics inside the method If we want to modify the response data.

3.afterCompletion() :
---------------------
This method can be used to perform actions after request and response.
This method can alsobe used for clenup task.

			@Component
			public class RequestHandlerInterceptor implements HandlerInterceptor{

				@Override
				public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
						throws Exception {
					System.out.println("preHandle() is invoked");
					return true;
				}

				@Override
				public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
						ModelAndView modelAndView) throws Exception {
					System.out.println("postHandle() is invoked");
				}

				@Override
				public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
						throws Exception {
					System.out.println("afterCompletion() is invoked");
				}
			}

Create the Configuration class that extends WebMvcConfigurationSupport and add the Interceptors to the InterceptorRegistry.

			@Configuration
			public class InterceptorConfiguration extends WebMvcConfigurationSupport{

				@Autowired
				RequestHandlerInterceptor requestHandlerInterceptor;
				
				@Override
				protected void addInterceptors(InterceptorRegistry registry) {
					registry.addInterceptor(requestHandlerInterceptor);
				}
			}

Difference between Filter and Interceptor :
-------------------------------------------
A Servlet Filter is used in the Web Layer only and we cannot use it outside of the Web Context.
Interceptors can be used any where.
For Authentication of Web Pages we use Servlet Filter where as for Security Stuff in the Business Layer or Logging/Bug Tracking we use Interceptors.
Interceptors does not rely on the Servlet Container where as filter depends on Servlet Container.
HTTP Specification does not openly prevent any HTTP Method for having a Request Body but It is wise not to use Get Method.
Because HTTP Servers and Proxy Servers may discard the Request Body for GET Request and fail in unexpected Ways.
Filter gets configured in web.xml where as Ineterceptors are configured in the Application.

			@Component
			public class CustomFilter implements Filter{

				@Override
				public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
						throws IOException, ServletException {
					System.out
					.println("Hey i am Filter. I will get invoked before that Interceptors. doFilter() method is invoked");
					chain.doFilter(request, response);
				}
			}
			

