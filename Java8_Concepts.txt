1.For Each Method in Iterable Interface													[02-SEP-2021]
2.Default and Static Method in Interfaces   					(beginnersbook)     	[02-SEP-2021]  	(Done)
3.Functional Interfaces and Lambda Expressions                  (beginnersbook)         [03-SEP-2021]	(Done)
4.Java Stream API For Bulk Data Operations on Collections    	(beginnersbook)         [03-SEP-2021]	(Done)
5.Java Time API                                                                 		[02-SEP-2021]	()
6.Collection API Improvements                                                   		[02-SEP-2021]   ()
7.Concurrency API Improvements                                                  		[02-SEP-2021]   ()
8.Java IO Improvements                                                          		[02-SEP-2021]   ()
9.Miscellaneous Core API Improvements                                           		[02-SEP-2021]   ()
10.Method References                           					(beginnersbook)         [08-SEP-2021]   (Done)
11.spliterator                                                  ()                      [02-SEP-2021]   ()
12.Optional Class												(beginnersbook)         [08-SEP-2021]   (Done)
13.CopyOnWriteArrayList											(howtodoinjava)         [09-SEP-2021]   (Done)
14.Sort in Java 8   											(stackabuse)            [07-SEP-2021]	(Done)
15.StringJoiner   												(beginnersbook)         [07-SEP-2021]	(Done)
16.Comparators Java8                             				(javabrahman)           [07-SEP-2021]	(Done)
17.Function package 											(javabrahman)           [08-SEP-2021]	(Done)
18.Base64 Encode Decode                                                                 [02-SEP-2021]   ()
19.SOLID Principles												(javabrahman)			[02-SEP-2021]   ()
20.Streams                                                 		(winterbe)           	[08-SEP-2021]   (Done)
21.Map in Java8													(beginnersbook)         [08-SEP-2021]	(Done)

******************************************** 2. Default and Static Methods in Interface (beginnersbook) ********************************************

Before Java8,Interface can have only abstract Methods ie All the Methods of interface are by default public and abstract.
It was not possible to add new functionality to the existing interface without forcing all the Implementation classes to implement the interface.
It is also not possible to create interface with implementation.
From Java8 we have interfaces with default and static Methods.

default method :
----------------
By using default Method we can add new methods in the existing interface in such a way that they are Backward Compatible.
Backward Compatibility is adding new feature without breaking the Code.
default Methods are declared in the interfaces using default keyword and can be overridden and accessible by the instances of the implementation classes.
   
   interface Printer
   {
	default void print()
	{
		System.out.println("This is Interface Printer");
	}
   }
   
static Method :
---------------
static methods in interface are similar to default method except that we cannot override these methods in the implementation classes.
since these methods are static.
To call the static Method we use the interface name.
   
   interface Scanner
   {
      static void print()
	  {
		System.out.println("This is Interface Scanner");
	  }
	  
   }
   
   Scanner.print(); // calling static Interface Method
   
Java 8 â€“ Abstract classes vs interfaces :
-----------------------------------------
With the introduction of default methods in interfaces,abstract classes are similar to interfaces in Java8.
Eventhough it is true still we can have differences.
Abstract classes can have Constructors where as Interfaces can't have Constructors.
Main purpose of Interface is to provide full abstraction where as Abstract class purpose is to provide partial implementation.
With the introduction of default methods we can add additional fetaures to the interface without effecting the implementation Classes.

Default Method and Multiple Inheritance :
-----------------------------------------
When we have two interfaces with same default Method signature the Multiple inheritance problem can occur.
To resolve the issue override the default method in the Implementation class.

Java 8 Multiple Inheritance Conflict Resolution Rules and Diamond Problem (javabrahman) :
-----------------------------------------------------------------------------------------
Java8 resolves the Multiple inheritance by overriding the default Method in the Implementation Classes.
Problem is what if the multiple default inetrfaces have implemented by default methods with same signature then which default 
method is invoked by the implementation class.
Java8 designers thought of this conflict and have defined resolution rules for such scenario's.

Rule 1: Class takes higher precedence than interface.
Any method inherited from class or super class will be invoked before any default Method from  Interface.
Rule 2:
Derived Interfaces or sub Innterfaces takes higher precedence than Interface with higher hierarchy.
Rule 3:
If Rule 1 and Rule 2 are not able to resolve the conflict then implementing Class has to specifically override 
and provide a method with same Method definition.
We can invoke the specific implementation in Java8 using 

	Interface.super.method

***************************************** 3.Functional Interface and Lambda Expressions (beginnersbook) ***********************************************

An Interface with only one abstract Method and can have any number of default and static Methods is called Functional Interface.
We can either use the predefined Functional Interface provided by Java or we can create our own.
Functional interfaces has only single abstract method and also called as SAM interfaces.	
@FunctionalInterface is used to mark an interface as Functional Interface so that accidentally we cannot declare more than one abstract Methods.
Functional Interface provides the possibility to use Lambda Expressions to instantiate them.
We can instantiate an Interface with Anonymous Inner Class but the code looks bulky.
   
Thread :
--------

   Runnable runnable=new Runnable()
							  {
								@override
								public void run()
								{
								System.out.println("My Runnable")
								}
							  };
	
Since Functional Interfaces has only one method declaration,Lambda Expression can easily provide the Method Implementation.
	
Thread :
--------

	Runnable runnable=() -> {
							System.out.println("My Runnable");
							}
	
If the body of the expression is one line then we can remove the curly Braces.

	Interface i1=(s)->System.out.println(s);
	i1.void("Hello");
	
We have been using Functional interface prior to Java 8.
They wer created by using anonymous inner class using interfaces such as Runnable,Comparator etc.
Lambda Expressions are meant to create Anonymous Classes of Functional Interfaces easily.
To use Lambda Expressions in Java, we need to create our own functional interfaces or use the predefinded Functional Interfaces provided by Java.
Mark the Predefined Functional Interface by using @FunctionalInterface Annotation.
@FunctionalInterface is introduced in Java 8.
	
	@FunctionalInterface
	interface MyFunctioanlInterface
	{
		public int addMethod(int a,int b);
	}
	MyFunctioanlInterface myFunctioanlInterface=(a,b)->a+b;
	System.out.println("Result :"+myFunctioanlInterface.addMethod(12, 100));
	
********************************** 4.Stream API for Bulk Data Operations on Collections (beginnersbook) *********************************************

Java.util.stream has been introduced in Java 8 to perform filter/map/reduce like operations with Collection.
Stream API allows Sequential as well as Parallel Execution.
Collection Interface has been extended with stream() and paralellStream() default methods to get the stream for Sequential and Parallel Execution.

Stream does not store the Data.
Stream is not a DataStructure and it never modifies the underlying Data source.
java.util.stream supports functional style of Operations on Stream of elements like Map,Reduce and so on.
Stream has three Parts 
1.Data Source 
2.Zero or More Intermediate Operation and 
3.Zero or More Terminal Operation.

Intermediate Operations get the elements one by one and process them.
All Intermediate Operations are lazy and as a Result No Operations will be effective until the pipelIne start to work.
Terminal Operation means end of the Stream Life Cycle.

forEach() is a Terminal Operation and it loops over the Stream of elements calling the Supplied Function.
After the Operation is being performed,Stream pipeline is Considered to be Consumed and No Longer Used.

Map produces a new Stream after applying a Function to each element of the other Stream.
Here New Steam can be Different Type.

collect() is one of the common way to get the stuff out from the stream once done with the processing.
findFirst() is used to return the First Object from the Stream other wise it returns null.

If we want to get an Array form the Stream of Elements we use toArray(Employee[]::new)

FlatMap :
---------
A Stream can hold complex Data Structures like Stream<List<String>>.
FlaMap helps us to flatten the dataStructure to simplify further Operations.
FlatMap can be used for Asynchronous Operations.

	.flatMap(employeeId -> getEmployeeDetails(employeeId))
	.collect(Collectors.toList());

For Each :
----------
For Each is a Terminal Operation.
Some times we need to perform multiple operations on each element of the Stream before the Terminal Operation is applied.
In this case peek() can be Used.

Peek :
------
peek() performs specified Operation on each element of the stream and returns a new Stream which can be used further.
peek() is an Intermediate Operation.
peek() can be useful in visualizing how stream operations behave and understanding the complex of intermediate stream operations.
peek() is mainly used for debugging where we want to see the elements of the stream as they flow in the pipeline.
peek() can also be used to alter the inner state of the element.

Comparison based Stream Operations :
------------------------------------
we use sorted on stream of elements.

allMatch, anyMatch, and noneMatch :
-----------------------------------
allMatch() returns true if all the elements of the stream satisfies the condition.
It returns false as soon as it does not match the predicate.
anyMatch()  return true if it Matches any one of the element in the Stream.
nonMatch() returns true if none of the element in stream matches the Predicate.

Stream Specializations :
------------------------
We can also create IntStream,LongStream and DoubleStream respectively for int,long and double.
The Most common way of creating IntStream is to call mapToInt().

Specialized Operations :
------------------------
Specialized Streams provide the additional Operations as compared to the Standard Streams and which are quite convenient when dealing with Numbers.

	employeeList.stream()
	.mapToDouble(Employee::getSalary)
	.average();
	
The other specialized operations are sum(),range().

Reduction Operations :
----------------------
Reduce Operation combines all the elements of the stream into a Single Result.

	T reduce(T identity,BinaryOperator<T> accumulator)
	
Key concepts in reduce() are Identity,Accumulator and Combiner.

Identity : This is the initial value of the reduction Operation and is the default result If the Stream is Empty.
Accumulator : Function that takes two Parameters i.e Partial Result of the Reduction Operation and the Next Element of the Stream.


	employeeList.stream()
	.map(Employee::getSalary)
	.reduce(0.0, Double::sum);
	
	List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
		int result = numbers.stream()
				.reduce(0,(total,element)->total+element);
		System.out.println(result);
		
Here (total,element)->total+element is the accumulator Since it takes the partial sum of the Integer value and next element of the Stream.

Combiner : When a Stream is executed in Parallel,Java Runtime Split the Stream into Multiple Sub Streams and 
In that case we need to use function to combine the result of sub streams into a Single one.

	List<Employee> employees = Arrays.asList(new Employee(1, "Srinivas", 22000.00), new Employee(2, "Nandini", 27000.00));
	System.out.println(employees.stream()
	.reduce(0.0, (salary,element)->salary+element.getSalary() , Double::sum));
 

Advanced collect :
------------------

partitioningBy :
----------------
We can Partition a Stream into two based on whether the elements satisfy the certain criteria or Not.

	List<Integer> intList = Arrays.asList(2, 4, 5, 6, 8);
	Map<Boolean,List<Integer>> resultMap=intList.stream().collect(Collectors.partitioningBy(i-> i%2 ==0));
	resultMap.forEach((key,value)-> System.out.println(key +""+value));
	 
groupingBy :
------------
groupingBy offers advanced Partitioning compared to Partitioning.
we can partition the stream into more than two groups.
It takes the Classification Function as Parameter and applied to each element of the Stream.

	   Map<Character, List<Employee>> groupByAlphabet = empList.stream().collect(
       Collectors.groupingBy(e -> new Character(e.getName().charAt(0))));
	  
	   Map<Character, List<Integer>> idGroupedByAlphabet = empList.stream().collect(
       Collectors.groupingBy(e -> new Character(e.getName().charAt(0)),
       Collectors.mapping(Employee::getId, Collectors.toList())));
		
collectors.mapping :
--------------------
 List<String> employeeNames = employeeList
        .stream()
        .collect(Collectors.mapping(Employee::getName, Collectors.toList()));
    System.out.println("List of employee names:" + employeeNames);
	
collectingAndThen :
-------------------

Parallel Streams :
------------------

Infinite Streams :
------------------

File Operations :
-----------------


***************************************************** 10.Method References  (beginnersbook) ******************************************************

Method reference is an alternative way of writing Lambda Expression.
The :: operator is used in Method reference to seperate the class or Object from the Method Name.
Ther are four types of Method References.

1.Method Reference to an Instance Method of a Class.

	public class Example {

	public void myMethod(){  
		System.out.println("Instance Method");  
	}
	public static void main(String[] args) {
		Example example=new Example();
		
		
		
		MyInterface reference = () -> example.myMethod();
		// If the Lambda Expression does not accept any argument and executing a Method
		// then use the Method Reference.
		MyInterface reference1 = example::myMethod;
		
		reference.disply();
		reference1.disply();
	}
}

interface MyInterface{
	 void disply();
}

2.Method Reference to Statci Method of a Class.
3.Method Reference to the Constructors
4.Method Reference to an instance Method of an Arbitary Object of a particular Type.


***************************************************** 12.Optional Class (beginnersbook) ***********************************************************

Optional Class is present in java.util package whch is introduced in Java 8.
Optional Class is introduced to avoid NPE that we frequently encounter If we do not perform null check in our code.
Using Optional Class we can easily check whether a variable has null value or not and by doing we can avoid NPE.

ofNullable() :
--------------
ofNullable() of the Optional class returns the non empty Optional If the given Object has the value otherwise returns an empty Optional.

isPresent() :
-------------
we can check whether the Optional value is empty or not by using isPresent().

		//declaring the String Array and not initializing the values.By default it will be null.
		String[] result=new String[10];
		//String subResult=result[9].substring(2, 5);
		//System.out.println(subResult); // It will throw NPE as values are not initialized
		
		Optional<String> nullCheck=Optional.ofNullable(result[9]);
		if(nullCheck.isPresent())
		{
			String subResult=result[9].substring(2, 5);
			System.out.println(subResult);
		}
		else
		{
			System.out.println("Cannot be NUll");
		}

ifPresent() :
-------------
There is another method in Optional Class which only executes If the given Optional Object is non empty.

		Optional<String> valueOne=Optional.ofNullable("This is Non Empty checked using IfPresent Method");
		Optional<String> valuetwo=Optional.empty();
		valueOne.ifPresent(System.out::println);
		valuetwo.ifPresent(System.out::println);
		
orElse() and orElseGet() :
--------------------------
orElse() and orElseGet() returns the value of the Optional Object If it is non empty.
If the Object is empty then it returns the default value passed to this method as an argument.

		//Creating Optional object from a String
        Optional<String> GOT = Optional.of("Game of Thrones");        
        //Optional.empty() creates an empty Optional object        
        Optional<String> nothing = Optional.empty();
        
        System.out.println(GOT.orElse("Empty Value"));
        System.out.println(nothing.orElse("Empty Value"));
        
        System.out.println(GOT.orElseGet(() -> "Empty Value"));
        System.out.println(nothing.orElseGet(() -> "Empty Value"));

Note :
------
We can also use Map and filter with the Optional Class.
To filter out the null values from the Stream we use Objects::nonNull as Method reference.

***************************************************** 13.CopyOnWriteArrayList *********************************************************************

CopyOnWriteArrayList is a Thread Safe variant of ArrayList in which all the modifications are done by creating a fresh copy of the underlying Array.
CopyOnWriteArrayList implements List,Serializable,Cloneable and RandomAccess Interface.
Using CopyOnWriteArrayList for updates is very costly because each modification creates a cloned copy of the underlying Array.
The iterator we create is an immutable snapshot of the original List.
Each Thread accessing the List sees its own version of snapshot of backing Array created while initializing the iterator first.
CopyOnWriteArrayList gets the snapshot of underlying Array it won't throw ConcurrentModificationException.
Iterator on the CopyOnWriteArrayList does not allow mutation operations and throws UnSupportedOperationException.
 
***************************************************** 14.Sort in Java 8 (stackabuse) **************************************************************

	List<Integer> list1 = Arrays.asList(10, 23, -4, 0, 18);
	/**
	 * Sorting using Comparator
	 */
	list1.sort(Comparator.naturalOrder());
	System.out.println(list1);
	
	/**
	 * Sorting using stream.sorted
	 */
	List<Integer> list2=list1.stream().sorted(Collections.reverseOrder()).collect(Collectors.toList());
	System.out.println(list2);

***************************************************** 15.StringJoiner (beginnersbook) *************************************************************

StringJoiner is a class introduced in Java8.
Using StringJoiner we can join multiple Strings with the specified delimiter.
We can also provide prefix and suffix to the given String.

***************************************************** 16.Comparators Java8 (javabrahman) **********************************************************

Comparator befor Java8 has two methods ie compare() and equals().
Java8 Comparator has now 19 Methods.
Comparator is now an official Functional Interface.
Java8 Comparator now supports declarations via Lambda Expressions as it is a Functional Interface.
Comparator has now comparing() and comparingThen that supports multiple sorts.
Comparator also supports natural comparison order and also null handling.

	public class ComparatorOldWay {
	
	static List<Employee> employeeList = 
		      Arrays.asList(new Employee("Tom Jones", 45), 
		        new Employee("Harry Major", 35),
		        new Employee("Harry Major", 25), 
		        new Employee("Ethan Hardy", 65), 
		        new Employee("Nancy Smith", 15),
		        new Employee("Deborah Sprightly", 29));
	
	public static void main(String[] args) {
		Collections.sort(employeeList,new NameComparator());
		System.out.println(employeeList);
	}
	}
	class NameComparator implements Comparator<Employee>
	{
	@Override
	public int compare(Employee e1, Employee e2) {
		return e1.getName().compareTo(e2.getName());
	}
	}
	
Comparator using Lambda Expression ie 

	Comparator<Employee> nameComparator = (Employee e1, Employee e2) -> {
			return e1.getName().compareTo(e2.getName());
		};
		
Comparator using then Comparing
		 
		Comparator<Employee> nameAgeComparing=Comparator.comparing(Employee::getAge).thenComparing(Employee::getName);
		
We can also have

	Comparator.nullsFirst(String::compareTo) and
	Comparator.nullsLast(String::compareTo)

	Comparator<Employee> empNameComparator = Comparator.comparing(Employee::getName, Comparator.nullsFirst(String::compareTo));
	
*****************************************************  17.Function package (javabrahman)  *******************************************************************

For common use cases where a Lambda Expression or a Method Reference is needed these are generally assigned to a target type.
java.util.function package provides a set of reusable common functional interfaces and their corresponding Lambda  definitions 
which can be used by the programmer in  the code instead of creating new functional interfaces.
Consider the scenario where we need a function that accepts an argument and returns boolean.

	public interface Predicate<T>
	{
		boolean test(T t);
	}
	
Then function descriptor would 	

	(T) -> boolean
	
where T is the parameter and boolean is the return type.

Function :
----------
Function Interface represents a function that takes one type of argument and returns another type of argument.
Function Interface implementation is now inlined in the declaration of sum variable rather in seperate Class.
Function Interface definition would be
	
	interface Function<T,R>
	{
		public R apply(T parameter)
	}

	public class FunctionDemo {
	Function<Integer, Integer> sum= (value -> value+value);
	public static void main(String[] args) {
		FunctionDemo demo=new FunctionDemo();
		Integer addNumbers=demo.sum.apply(5);
		System.out.println(addNumbers);
	}
}

Predicate :
-----------
Predicate Interface represents a function that takes a single value as parameter and returns either true or false.
Predicate Interface definition would be

	public interface Predicate<T>
	{
		public boolean test(T t);
	}
	
	Predicate predicate =(value) -> value !=null;
	
	
Consumer :
----------
Consumer Interface represents a function that takes a single argument and returns no result.

	Consumer consumer= (value) -> (System.out.println(value));

Supplier :
----------
Supplier is a fucntion that does not take any argument and returns the result.

	Supplier supplier= () -> "Supplier Function Called";

***************************************************** 19.SOLID Principles	(javabrahman) *****************************************************

1.Single Responsibility Principle
2.Open Closed Principle
3.Liskov Substitution Principle
4.Interface Segregation Principle
5.Dependency Inversion Principle

1.Single Responsibility Principle :
-----------------------------------
A Class should have a Single Responsibility where Responsibility is nothing but reason to change.
When we design our Class we should take care that the Class should be responsible for doing one task among the whole set of responsibilities.
When there is a change needed in specific functionality Class needs to be changed.

2.Open Closed Principle :
-------------------------
A Module is said to be Open If it is still available for extension.
It should be possible to add fields to the data structure it contains or new elements to the set of functions it performs.

A Class is said to be closed If it is used by other modules.
This assumes that module has well definded,stable description.
One of the basic requirement for a class to be closed is attributes and methods are final because
If they change all the classes which inherit the base class will be changed.

A Class is said to be Open Closed If it is open for extension and closed for modification.
Modification means we should not change the original class rather we should override the original class.

3.Liskov Substitution Principle :
---------------------------------
As per Liskov substitution principle A Class can be replaced by its subClass.
Super class reference can be used to hold subClass Object.

4.Interface Segregation Principle :
-----------------------------------

***************************************************** 21.Map in Java8 (beginnersbook) ************************************************************

1.compute :
-----------
compute() of HashMap allows us to update the value with the specified key.
compute() has two parameters
1.key and 
2.reMapping Function ie computes a new value for the specified key.

Note:
reMapping function takes two arguments and is considered as BiFunction.
During computation reMapping function should no be able to modify the Map.
Returns the new value associated with the key or null If no value is associated with the key.
If the remapping function results null then mapping for the specified key is removed.

		Map<String,String> map=new HashMap<>();
		map.put("One", "Bhaumik");
		map.put("Two", "Aadvik");
		map.compute("One", (key,value)-> value=value+" Chary");
		map.compute("Two", (key,value)-> value=value+" Chary");
		
		/**
		 * Compute to sum the Values
		 */
		Map<String,Integer> map1=new HashMap<>();
		map1.put("One", 23);
		map1.put("One", 15);
		
		map1.compute("One", (key,value) -> (value == null) ? 1 : value + value);
		
2.computeIfAbsent :
-------------------
computeIfAbsent() computes a new value and associates with the specified key if the key is not present.
If the Key is present then computeIfAbsent does not effect the Map.

computeIfAbsent() takes two parameters
key
reMapping Function cannot take two arguments and takes single argument.

		HashMap<String, Integer> map = new HashMap<>();
		map.put("key1", 10000);
		map.put("key2", 55000);
		map.put("key3", 44300);
		map.put("key4", 53200);
		
		System.out.println(map);
		map.computeIfAbsent("key5", key -> 87000);

3.computeIfPresent :
--------------------
computeIfPresent() computes a new value and associates with the specified key if the key is present.
If the key is not present the computeIfPresent does not effect the Map.

computeIfPresent() takes two parameters
key
reMapping Function can take two arguments and is considered as BiFunction.
If the reMapping Function returns null then mapping for the specified key is removed.

		map.computeIfPresent("key4",(key,val)-> val+1);
		System.out.println(map);
		
4.merge :
---------
merge() is used to combine multiple mapped values for a given key using mapping function.

Note :
If the key is not present or associated with null,It simply outputs the key along with the corresponding value in the HashMap as a new Entry.
If the key already holds some value remapping function merges both the old and new value for the given key.
In case key is null,It always mapped to bucket 0 as hash is not calculated for null keys due to NPE.

		/**
		 * Merge to sum the Values
		 */
		Map<String,Integer> map1=new HashMap<>();
		map1.put("One", 22);
		map1.put("Two", 27);
		
		Map<String,Integer> map2=new HashMap<>();
		map2.put("One", 23);
		map2.put("Two", 15);

		map2.forEach((key,value) -> map1.merge(key, value, (v1,v2) -> v1+v2));
		System.out.println(map1);
		
5.getOrDefault() :
------------------
getOrDefault() of HashMap returns the specified default value If the mapping for the specified key is not found.

 
	

