1.For Each Method in Iterable Interface							(geeksforgeeks)			[13-DEC-2021]	(Done)
2.Default and Static Method in Interfaces   					(beginnersbook)     	[02-SEP-2021]  	(Done)
3.Functional Interfaces and Lambda Expressions                  (beginnersbook)         [03-SEP-2021]	(Done)
4.Java Stream API For Bulk Data Operations on Collections    	(beginnersbook)         [03-SEP-2021]	(Done)

5.Java Time API                                                 ()                  	[02-SEP-2021]	()
6.Collection API Improvements                                   ()              		[02-SEP-2021]   ()
7.Concurrency API Improvements                                  ()              		[02-SEP-2021]   ()
8.Java IO Improvements                                          ()              		[02-SEP-2021]   ()
9.Miscellaneous Core API Improvements                           ()              		[02-SEP-2021]   ()

10.Method References                           					(beginnersbook)         [08-SEP-2021]   (Done)
11.spliterator                                                  (ChatGPT)               [20-NOV-2025]   (Done)
12.Optional Class												(beginnersbook)         [08-SEP-2021]   (Done)

13.CopyOnWriteArrayList											(howtodoinjava)         [09-SEP-2021]   (Done)
14.Sort in Java 8   											(stackabuse)            [07-SEP-2021]	(Done)
15.StringJoiner   												(beginnersbook)         [07-SEP-2021]	(Done)
16.Comparators Java8                             				(javabrahman)           [07-SEP-2021]	(Done)

17.Function package 											(javabrahman)           [08-SEP-2021]	(Done)
18.Base64 Encode Decode                                         ()                      [02-SEP-2021]   ()
19.Streams                                                 		(winterbe)           	[08-SEP-2021]   (Done)
20.Map in Java8													(beginnersbook)         [08-SEP-2021]	(Done)

21.PermGen														()						[03-DEC-2021]	()
22.Atomic Integer												(Geekific)              [03-DEC-2021]	()
23.Cyclic Barrier 												()                      [03-DEC-2021]	()
24.HashMap Internal changes related to Java 8					()						[03-DEC-2021]	()
25.G1 Garbage Collector 										()                      [03-DEC-2021]	()



********************************************  1.For Each Method in Iterable Interface **************************************************************

Enhanced for-each  :
--------------------
Enhanced for-each is applicable only for Arrays and Iterable and not for arbitary sources like Streams.
The enhanced for-each is external iteration and we have complete control over the loop.
We can reassigning the loop variable does not change the element in the collection,but you can mutate the objects contained inside.
We cannot modify the collection structure via for-each.
If we try to structurally modify the collection directly inside the for-each, we get ConcurrentModificationException.
Enhanced for-each loop does not support Lambda Operations.
The operations can be applied on the variables outside the List that we are using for Iteration in the for-each loop.
"return" statement works within for-each loop i.e. function can return the value at any point of time.

stream.foreach() :
------------------
stream.forEach() can be used to access Arrays and Collections.
In stream.forEach() lambda's are used and thus operations on the variables outside the loop are not allowed.
operations on the variables outside the loop are allowed only if the variables are instance fields, static fields, or contained in mutable objects.
"return" statement doesn't work within the stream.foreach().
We cannot use return in forEach to break the whole processing the same way you do in a for-each loop.

******************************************** 2. Default and Static Methods in Interface (beginnersbook) ********************************************

Before Java8,Interface can have only abstract Methods i.e. All the Methods in the interface are by default public and abstract.
It is not possible to add any new functionality to the existing interface without forcing all the implementation classes to implement the interface.
It is also not possible to create an interface with an implementation.
From Java8 we have interfaces with default and static Methods.

default method :
----------------
By using default methods we can add new methods in the existing Interface in such a way that they are backward compatible.
Backward Compatibility is nothing but adding a new feature without breaking the existing code.
default methods are declared in the interfaces by using default keyword and can be overridden and accessible by the instances of the implementation classes.
   
   interface Printer
   {
	default void print()
	{
		System.out.println("This is Interface Printer");
	}
   }
   
static Method :
---------------
static methods in interface are similar to default method except that we cannot override these methods in the implementation classes,since these methods are static.
To call the static Method we use the interface name.
   
   interface Scanner
   {
      static void print()
	  {
		System.out.println("This is Interface Scanner");
	  }
	  
   }
   
   public class StaticImpl implements StaticInterface{

	public static void main(String[] args) {
		StaticInterface.staticMethod(); // Calling Static Method
	}
}
   
Java 8 – Abstract classes vs interfaces :
-----------------------------------------
With the introduction of default methods in an Interface,Abstract classes are similar to interfaces in Java8.
Eventhough it is true still we can have differences.
Abstract classes can have Constructors where as Interfaces can't have Constructors.
Main purpose of Interface is to provide full abstraction where as Abstract class purpose is to provide partial implementation.
With the introduction of default methods in an Interface,we can add additional fetaures to the interface without effecting the implementation Classes.

Default Method and Multiple Inheritance :
-----------------------------------------
When we have two interfaces which contains default() with the same signature then Multiple inheritance problem can occur.
To resolve the issue override the default method in the Implementation class.

Java 8 Multiple Inheritance Conflict Resolution Rules and Diamond Problem (javabrahman) :
-----------------------------------------------------------------------------------------
Java8 resolves the Multiple inheritance by overriding the default() in the Implementation Classes.
Problem is what If the multiple inetrfaces have default methods with same signature then which default method is invoked by the implementation class.
Java8 designers thought of this conflict and have defined resolution rules for such scenario's.

Rule 1: Class takes higher precedence than interface.
Any method inherited from class or super class will be invoked before any default Method from Interface.

interface InterfaceX {
    default void show() {
        System.out.println("InterfaceX show()");
    }
}

class Parent {
    public void show() {
        System.out.println("Parent show()");
    }
}

class Child extends Parent implements InterfaceX {
    // No override here
    public static void main(String[] args) {
        Child c = new Child();
        c.show(); //Parent show()
    }
}


Rule 2:
Derived Interfaces or sub Innterfaces takes higher precedence than Interface with higher hierarchy.

interface InterfaceP {
    default void greet() {
        System.out.println("Hello from InterfaceP");
    }
}

interface InterfaceC extends InterfaceP {
    @Override
    default void greet() {
        System.out.println("Hello from InterfaceC");
    }
}

class Impl implements InterfaceC {
    public static void main(String[] args) {
        Impl obj = new Impl();
        obj.greet();//Hello from InterfaceC
    }
}


Rule 3:
If Rule 1 and Rule 2 are not able to resolve the conflict then implementing Class has to specifically override and provide a method with same Method definition.
We can invoke the specific implementation in Java8 using 

public interface InterfaceA {
    default void commonMethod() {
        System.out.println("InterfaceA's commonMethod");
    }
}

public interface InterfaceB {
    default void commonMethod() {
        System.out.println("InterfaceB's commonMethod");
    }
}

public class ImplementationClass implements InterfaceA, InterfaceB {

	/* Mandatory override to resolve ambiguity */
    @Override
    public void commonMethod() {
        System.out.println("ImplementationClass's commonMethod");
    }

    /* Explicitly specify which default method to use */
    public void callInterfaceADefault() {
        InterfaceA.super.commonMethod();
    }

    /* Explicitly specify which default method to use */
    public void callInterfaceBDefault() {
        InterfaceB.super.commonMethod();
    }

    public static void main(String[] args) {
        ImplementationClass obj = new ImplementationClass();
        obj.commonMethod(); // Calls the overridden method in ImplementationClass
        obj.callInterfaceADefault(); // Calls InterfaceA's default method
        obj.callInterfaceBDefault(); // Calls InterfaceB's default method
    }
}

***************************************** 3.Functional Interface and Lambda Expressions (beginnersbook) ***********************************************

An Interface with single abstract method and can have any number of default and static Methods is called Functional Interface.
Since the Functional interface has single abstract method It is also called as SAM interfaces.	
We can use either predefined Functional Interface provided by Java or we can create on our own.
@FunctionalInterface can be used to mark an interface as Functional Interface so that accidentally we cannot declare more than one abstract Methods.
Functional Interface provides the possibility to use Lambda Expressions to instantiate them.

We have been using Functional interface prior to Java 8.
They were created by using anonymous inner class such as Runnable,Comparator etc.

	Runnable runnable=new Runnable()
							  {
								@override
								public void run()
								{
								System.out.println("My Runnable")
								}
							  };
   	
	@FunctionalInterface
	public interface StringFunctionInterface {

		 void displayMessage(String message);
	}

Functional Interface provides the possibility to use Lambda Expressions to instantiate them.
If the body of the expression is one line then we can remove the curly Braces.

	StringFunctionInterface stringFunctionInterface=(message) -> System.out.println(message);
	stringFunctionInterface.displayMessage("Hello World");
	
Lambda Expressions are meant to create Anonymous Classes of Functional Interfaces easily.

	Runnable runnable=() -> {
							System.out.println("My Runnable");
							}
							
	@FunctionalInterface
	public interface AddFunctionalInterface {

		public int add(int a, int b);
	}	
	
	AddFunctionalInterface addFunctionalInterface=(a,b) -> a+b;
	System.out.println(addFunctionalInterface.add(23,15));
	
********************************** 4.Stream API for Bulk Data Operations on Collections (beginnersbook) *********************************************

Java.util.stream has been introduced in Java 8 to perform operations like filter/map/reduce with Collection.
Stream API allows sequential as well as parallel execution.
Collection interface has been extended with stream() and paralellStream() default methods to get the stream for sequential and parallel execution.

Stream does not store the Data.
Stream is not a data structure and it never modifies the underlying data source.

java.util.stream supports functional style of operations on the stream of elements like Map,Reduce and so on.
Stream has three Parts 
1.Data Source 
2.Zero or More Intermediate Operations and
3.Zero or More Terminal Operations.


Intermediate operations get the elements one by one and process them.
All Intermediate Operations are lazy and as a result no operations will be effective until the pipelIne start to work.
Terminal Operation means end of the Stream Life Cycle.

stream.forEach() is a terminal operation and it loops over the stream of elements by calling the supplied Function.
After the operation is being performed,stream pipeline is considered to be consumed and no longer Used.

Map produces a new stream after applying a function to each element of the other Stream.
Here the new stream can be of different Type.

collect() is one of the common way to get the stuff out from the stream once done with the processing.
findFirst() is used to return the first Object from the Stream other wise it returns null.

If we want to get an Array from the stream of elements we use toArray(Employee[]::new)

FlatMap :
---------
A Stream can hold complex data structures like List<List<String>>.
FlaMap helps us to flatten the dataStructure to simplify further Operations.
FlatMap can also be used for Asynchronous Operations.

	.flatMap(employeeId -> getEmployeeDetails(employeeId))
	.collect(Collectors.toList());

forEach :
----------
forEach is a Terminal Operation.

Peek :
------
Some times we need to perform multiple operations on each element of the stream before the Terminal operation is applied.
In this case peek() can be used.

peek() performs specified operation on each element of the stream and returns a new stream which can be used further.
peek() is an Intermediate Operation.
peek() can be useful in visualizing how stream operations behave and understanding the complex of intermediate stream operations.
peek() is mainly used for debugging where we want to see how the elements of the stream flow in the pipeline.
peek() can also be used to alter the inner state of the element.

Comparison based Stream Operations :
------------------------------------
we use sorted on stream of elements.

allMatch, anyMatch, and noneMatch :
-----------------------------------
allMatch() returns true If all the elements of the stream satisfies the condition.It returns false as soon as it does not match the predicate.
anyMatch() returns true If it matches with any one of the element in the Stream.
noneMatch() returns true If none of the element in stream matches with the Predicate.

Stream Specializations :
------------------------
We can also create IntStream,LongStream and DoubleStream respectively for int,long and double.
The Most common way of creating IntStream is to call mapToInt().

Specialized Operations :
------------------------
Specialized Streams provide the additional Operations as compared to the Standard Streams and which are quite convenient when dealing with Numbers.

	employeeList.stream()
	.mapToDouble(Employee::getSalary)
	.average();
	
The other specialized operations are sum(),range().

Reduction Operations :
----------------------
Reduce Operation combines all the elements of the stream with the given function and returns Single Result.

	T reduce(T identity,BinaryOperator<T> accumulator)
	
Key concepts in reduce() are Identity,Accumulator and Combiner.
Identity : This is the initial value of the reduction operation and is the default value If the Stream is Empty.
Accumulator : Function that takes two parameters i.e partial result of the reduction operation and the next element of the stream.

	employeeList.stream()
	.map(Employee::getSalary)
	.reduce(0.0, Double::sum);
	
	List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
		int result = numbers.stream()
				.reduce(0,(total,element)->total+element);
		System.out.println(result);
		
Here (total,element)->total+element is the accumulator since it takes the partial sum of the Integer value and next element of the stream.

Combiner : When a stream is executed in parallel,java runtime split the stream into multiple sub streams.
In that case we need to use the function to combine the result of sub streams into a single one.

	List<Employee> employees = Arrays.asList(new Employee(1, "Srinivas", 22000.00), new Employee(2, "Nandini", 27000.00));
	System.out.println(employees.stream()
	.reduce(0.0, (salary,element)->salary+element.getSalary() , Double::sum));
 

Advanced collect :
------------------

partitioningBy :
----------------
We can partition a stream into two based on whether the elements satisfy the certain criteria or not.

	List<Integer> intList = Arrays.asList(2, 4, 5, 6, 8);
	Map<Boolean,List<Integer>> resultMap=intList.stream().collect(Collectors.partitioningBy(i-> i%2 ==0));
	resultMap.forEach((key,value)-> System.out.println(key +""+value));
	 
groupingBy :
------------
groupingBy offers advanced partitioning compared to partitioning.
we can partition the stream into more than two groups.
It takes the classification function as parameter and applied to each element of the stream.

	   Map<Character, List<Employee>> groupByAlphabet = empList.stream().collect(
       Collectors.groupingBy(e -> new Character(e.getName().charAt(0))));
	  
	   Map<Character, List<Integer>> idGroupedByAlphabet = empList.stream().collect(
       Collectors.groupingBy(e -> new Character(e.getName().charAt(0)),
       Collectors.mapping(Employee::getId, Collectors.toList())));
		
collectors.mapping :
--------------------
 List<String> employeeNames = employeeList
        .stream()
        .collect(Collectors.mapping(Employee::getName, Collectors.toList()));
    System.out.println("List of employee names:" + employeeNames);
	
collectingAndThen :
-------------------

Parallel Streams :
------------------

Infinite Streams :
------------------

File Operations :
-----------------


***************************************************** 10.Method References  (beginnersbook) ******************************************************

Method reference is an alternative way of writing Lambda Expression.
The :: operator is used in Method reference to seperate the class or Object from the Method Name.
There are four types of Method References.

	interface MyInterface{
	 void disply();
	}

1.Method Reference to an instance method of a Class.

	public class Example {


	public void myMethod(){  
		System.out.println("Instance Method");  
	}
	public static void main(String[] args) {
		Example example=new Example();
		
		
		
		MyInterface reference = () -> example.myMethod();
		// If the Lambda Expression does not accept any argument and executing a method then we can use the Method Reference.
		MyInterface reference1 = example::myMethod;
		
		reference.disply();
		reference1.disply();
	}
}

2.Method Reference to Static Method of a Class.

	interface Calculator {
    void calculate();
}

class MathUtil {
    public static void square() {
        System.out.println(5 * 5);
    }
}

public class Test {
    public static void main(String[] args) {
        // Lambda
        Calculator lambda = () -> MathUtil.square();

        // Method reference
        Calculator ref = MathUtil::square;

        lambda.calculate();
        ref.calculate();
    }
}

interface MathOperation {
    int operate(int a, int b);
}

public class Demo {
    public static int addition(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        // Lambda
        MathOperation lambda = (x, y) -> Demo.addition(x, y);

        // Method reference
        MathOperation ref = Demo::addition;

        System.out.println(ref.operate(10, 20)); // 30
    }
}

3.Method Reference to the Constructors.

interface MyInterface {
    Example getInstance();
}

class Example {
    Example() {
        System.out.println("Example object created");
    }
}

public class Test {
    public static void main(String[] args) {
        // Lambda
        MyInterface lambda = () -> new Example();

        // Method reference
        MyInterface ref = Example::new;

        lambda.getInstance();
        ref.getInstance();
    }
}

interface MessageCreator {
    Message create(String msg);
}

class Message {
    Message(String msg) {
        System.out.println(msg);
    }
}

public class Test {
    public static void main(String[] args) {
        // Lambda
        MessageCreator lambda = (text) -> new Message(text);

        // Method reference
        MessageCreator ref = Message::new;

        ref.create("Hello from constructor reference!");
    }
}

4.Method Reference to an instance Method of an Arbitary Object of a particular Type.

public class Test {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Mary", "Bob");

        // Lambda
        names.forEach(s -> System.out.println(s));

        // Arbitrary instance method reference
        names.forEach(System.out::println);
    }
}

***************************************************** 11.spliterator (ChatGPT) ********************************************************************

Split Iterator stands for Split and Iterator.
We can think of Split Iterator as the Itearator that will split into multiple parts so that those parts can be processed in paralell.
It is a special iterator introduced in Java 8 to support parallel processing in streams.

Why Spliterator was introduced :
--------------------------------
We had Iterator and ListIterator that only works sequentially.
They did not support paralell processing or splitting of data.
Paralell straems require a way to process the data paralelly, thus SplitIterator is added.

	
	public class BasicSpliterator {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A", "B", "C", "D");
        Spliterator<String> spliterator = list.spliterator();
        spliterator.forEachRemaining(System.out::println);
		}
	}

***************************************************** 12.Optional Class (beginnersbook) ***********************************************************

Optional Class is present in java.util package whch is introduced in Java 8.
Optional Class is introduced to avoid NPE that we frequently encounter If we do not perform null check in our code.

ofNullable() :
--------------
ofNullable() returns the non empty Optional If the given Object has the value otherwise returns an empty Optional.

isPresent() :
-------------
we can check whether the Optional value is empty or not by using isPresent().

		//declaring the String Array and not initializing the values.By default it will be null.
		String[] result=new String[10];
		//String subResult=result[9].substring(2, 5);
		//System.out.println(subResult); // It will throw NPE as values are not initialized
		
		Optional<String> nullCheck=Optional.ofNullable(result[9]);
		if(nullCheck.isPresent())
		{
			String subResult=result[9].substring(2, 5);
			System.out.println(subResult);
		}
		else
		{
			System.out.println("Cannot be NUll");
		}

ifPresent() :
-------------
There is another method in Optional Class which executes only If the given Optional Object is non empty.

		Optional<String> valueOne=Optional.ofNullable("This is Non Empty checked using IfPresent Method");
		Optional<String> valuetwo=Optional.empty();
		valueOne.ifPresent(System.out::println); //This is Non Empty checked using IfPresent Method
		valuetwo.ifPresent(System.out::println); //No Output
		
orElse() and orElseGet() :
--------------------------
orElse() and orElseGet() returns the value of the Optional Object If it is non empty.
If the Object is empty then it returns the default value passed to this method as an argument.

		//Creating Optional object from a String
        Optional<String> GOT = Optional.of("Game of Thrones");        
        //Optional.empty() creates an empty Optional object        
        Optional<String> nothing = Optional.empty();
        
        System.out.println(GOT.orElse("Empty Value")); //Game of Thrones
        System.out.println(nothing.orElse("Empty Value")); //Empty Value
        
        System.out.println(GOT.orElseGet(() -> "Empty Value"));  //Game of Thrones
        System.out.println(nothing.orElseGet(() -> "Empty Value")); //Empty Value

Note :
------
We can also use Map and filter with the Optional Class.
To filter out the null values from the Stream we use Objects::nonNull as Method reference.

***************************************************** 13.CopyOnWriteArrayList *********************************************************************

CopyOnWriteArrayList is a Thread Safe variant of ArrayList in which all the modifications are done by creating a fresh copy of the underlying Array.
CopyOnWriteArrayList implements List,Serializable,Cloneable and RandomAccess Interface.
Using CopyOnWriteArrayList for updates is very costly because each modification, it creates a cloned copy of the underlying Array.

The iterator we create using CopyOnWriteArrayList is an immutable snapshot of the original List.
i.e. When we call iterator() or use for-each, it takes a snapshot of the array at that moment.
Each Thread accessing the List sees its own version of snapshot of backing Array created while initializing the iterator first.

As CopyOnWriteArrayList gets the snapshot of underlying Array, It won't throw any ConcurrentModificationException.
Iterator’s remove() on the CopyOnWriteArrayList does not allow mutation operations and throws UnSupportedOperationException.

ArrayList :
-----------
	List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
	Iterator<Integer> it = list.iterator();
	list.add(4);  // structural modification
	while (it.hasNext()) {
		System.out.println(it.next()); // may throw ConcurrentModificationException
	}
	
CopyOnWriteArrayList :
----------------------
	CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(1, 2, 3));
	Iterator<Integer> it = list.iterator(); // Here Iterator conatians immutabe snapshot of the original List
	list.add(4); // creates a new internal array, but iterator still uses old snapshot
	while (it.hasNext()) {
		System.out.println(it.next()); // prints 1, 2, 3 only, no exception
	}
	it.remove(); // throws UnsupportedOperationException

Internal Implementation :
-------------------------
Step 1: We prepare a list and an iterator snapshot.

		CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(new String[]{"A", "B", "C"});
		// Create an iterator snapshot of the current array ["A", "B", "C"]
		Iterator<String> itr = list.iterator();
		
At this moment,
The internal array = ["A", "B", "C"]
The iterator’s snapshot = ["A", "B", "C"]

Step 2: Add an element to the list
list.add("D");

OLD array = ["A", "B", "C"]
1. Create NEW array = ["A", "B", "C", null]
2. Insert "D" → ["A", "B", "C", "D"]
3. Replace internal reference to NEW array

Internal array becomes → ["A", "B", "C", "D"]
Iterator’s snapshot remains → ["A", "B", "C"]

Step 3: Read from the iterator snapshot

System.out.println("Iterator snapshot");
while (itr.hasNext()) {
    System.out.println(itr.next());
}
Output:
Iterator snapshot
A
B
C

Step 4: Read the list after modification

System.out.println("List content");
for (String s : list) {
    System.out.println(s);
}

Output:
List content
A
B
C
D

***************************************************** 14.Sort in Java 8 (stackabuse) **************************************************************

Before Java 8 :
---------------
1.Collections.sort(List)
2.Collections.sort(List, Comparator)
3.Arrays.sort(T[] array)
4.Implementing Comparable<T> (natural order)
5.Implementing Comparator<T> (custom order), often with anonymous inner classes.

Java 8 and later :
-------------------

All of the above plus

1.list.sort(Comparator)
2.stream.sorted() and stream.sorted(Comparator)
3.Comparator.comparing(...)
4.thenComparing(...)
5.reversed()
6.Method references and lambdas to make Comparators much cleaner
7.Arrays.parallelSort(...) for parallel sorting of arrays


Sorting Before Java 8 :
#######################

Natural ordering with Collections.sort :
----------------------------------------

	List<Integer> numbers = Arrays.asList(10, 3, -1, 7);
	Collections.sort(numbers);  // uses natural order (Integer implements Comparable)
	System.out.println(numbers); // [-1, 3, 7, 10]
	
Custom order with Comparator (anonymous class) :
------------------------------------------------

	List<String> names = Arrays.asList("John", "Alexander", "Bob");
	Collections.sort(names, new Comparator<String>() {
		@Override
		public int compare(String s1, String s2) {
			return Integer.compare(s1.length(), s2.length());
		}
	});
	System.out.println(names); // [Bob, John, Alexander]
	
Arrays sorting :
----------------

	int[] arr = {5, 2, 9, 1};
	Arrays.sort(arr);   // ascending order
	System.out.println(Arrays.toString(arr)); // [1, 2, 5, 9]
	
Sorting After Java 8 :
######################

Using List.sort(Comparator) :
-----------------------------

	List<Integer> list1 = Arrays.asList(10, 23, -4, 0, 18);
	// Natural order (ascending)
	list1.sort(Comparator.naturalOrder());
	System.out.println(list1); // [-4, 0, 10, 18, 23]
	list1.sort(Comparator.reverseOrder());
	System.out.println(list1); // [23, 18, 10, 0, -4]

Custom logic with lambdas :
---------------------------

	// Sort by absolute value
	list1.sort((a, b) -> Integer.compare(Math.abs(a), Math.abs(b)));
	System.out.println(list1); // e.g., [0, -4, 10, 18, 23]
	
Using Collections.sort with lambdas (still valid in Java 8) :
-------------------------------------------------------------

	List<String> names = Arrays.asList("John", "Alexander", "Bob");
	// Sort by length
	Collections.sort(names, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
	System.out.println(names);
	
Using stream().sorted() :
-------------------------

	List<Integer> list1 = Arrays.asList(10, 23, -4, 0, 18);
	/**
	 * Sorting using Comparator
	 */
	list1.sort(Comparator.naturalOrder());
	System.out.println(list1);
	/**
	 * Sorting using stream.sorted
	 */
	List<Integer> list2 = list1.stream()
			.sorted(Collections.reverseOrder())
			.collect(Collectors.toList());
	System.out.println(list2);
	List<Integer> sorted = list1.stream()
                            .sorted()  // natural order
                            .collect(Collectors.toList());
							List<String> names = Arrays.asList("John", "Alexander", "Bob");
	List<String> sortedByLength = names.stream()
			.sorted((s1, s2) -> Integer.compare(s1.length(), s2.length()))
			.collect(Collectors.toList());

	System.out.println(sortedByLength); // [Bob, John, Alexander]


Using Comparator.comparing and thenComparing :
----------------------------------------------

	class Person {
    private String name;
    private int age;
		// constructor, getters
		public Person(String name, int age) {
			this.name = name;
			this.age = age;
		}
		public String getName() { return name; }
		public int getAge() { return age; }

		@Override
		public String toString() {
			return name + "(" + age + ")";
		}
	}
	
	List<Person> persons = Arrays.asList(
        new Person("Alex", 30),
        new Person("Bob", 25),
        new Person("Chris", 25),
        new Person("David", 35));
	
Before Java 8 

	Collections.sort(persons, new Comparator<Person>() {
		@Override
		public int compare(Person p1, Person p2) {
			return Integer.compare(p1.getAge(), p2.getAge());
		}
	});
	
Using Comparator.comparing

	persons.sort(Comparator.comparing(Person::getAge));
	System.out.println(persons); // [Bob(25), Chris(25), Alex(30), David(35)]
	persons.sort(
    Comparator.comparing(Person::getAge).thenComparing(Person::getName));
	System.out.println(persons);// [Bob(25), Chris(25), Alex(30), David(35)]
	
	persons.sort(Comparator.comparing(Person::getAge).reversed());


Arrays.sort :
-------------

	int[] arr = {5, 1, 4, 2};
	Arrays.sort(arr);
	System.out.println(Arrays.toString(arr)); // [1, 2, 4, 5]
	
Object arrays with custom comparator :
--------------------------------------

	String[] arr = {"John", "Alexander", "Bob"};
	Arrays.sort(arr, (a, b) -> Integer.compare(a.length(), b.length()));
	System.out.println(Arrays.toString(arr)); // [Bob, John, Alexander]

Arrays.parallelSort :
---------------------

	int[] arr = {5, 1, 4, 2, 9, 7, 6, 3};
	Arrays.parallelSort(arr);  // may be faster for large arrays
	System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 9]

Sorting Maps using Streams :
----------------------------

	Map<String, Integer> scores = new HashMap<>();
	scores.put("Alex", 85);
	scores.put("Bob", 75);
	scores.put("Chris", 90);

	LinkedHashMap<String, Integer> sortedByValue = scores.entrySet().stream()
        .sorted(Map.Entry.comparingByValue())  // ascending by value
        .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (e1, e2) -> e1,
                LinkedHashMap::new   // maintain order
        ));
	System.out.println(sortedByValue); // {Bob=75, Alex=85, Chris=90}


***************************************************** 15.StringJoiner (beginnersbook) *************************************************************

StringJoiner is a class introduced in Java8.
StringJoiner can be used to join more than one String with the specified delimiter.
We can also provide prefix and suffix to the given String.

	public class StringJoinerDemo {
	public static void main(String[] args) {
		/**
		 * Joining with Comma Separated Values
		 */
		StringJoiner joiner = new StringJoiner(" ");
		joiner.add("Srinivas");
		joiner.add("Chary");
		joiner.add("Sankoji");
		System.out.println(joiner);
		}
	}

***************************************************** 16.Comparators Java8 (javabrahman) **********************************************************

Comparator before Java8 has two methods ie compare() and equals().
Java8 Comparator has now 19 Methods.
Comparator is now an official Functional Interface.
Java8 Comparator now supports declarations via Lambda Expressions as it is a Functional Interface.
Java8 Comparator has now comparing() and comparingThen() that supports multiple sorts.
Comparator also supports natural comparison order and also null handling.

	public class ComparatorOldWay {
	
	static List<Employee> employeeList = 
		      Arrays.asList(new Employee("Tom Jones", 45), 
		        new Employee("Harry Major", 35),
		        new Employee("Harry Major", 25), 
		        new Employee("Ethan Hardy", 65), 
		        new Employee("Nancy Smith", 15),
		        new Employee("Deborah Sprightly", 29));
	
	public static void main(String[] args) {
		Collections.sort(employeeList,new NameComparator());
		System.out.println(employeeList);
	}
	}
	class NameComparator implements Comparator<Employee>
	{
	@Override
	public int compare(Employee e1, Employee e2) {
		return e1.getName().compareTo(e2.getName());
	}
	}
	
Comparator using Lambda Expression ie 

	Comparator<Employee> nameComparator = (Employee e1, Employee e2) -> {
			return e1.getName().compareTo(e2.getName());
		};
		
Comparator using then Comparing
		 
		Comparator<Employee> nameAgeComparing=Comparator.comparing(Employee::getAge).thenComparing(Employee::getName);
		
We can also have Comparator.nullsFirst(String::compareTo) and Comparator.nullsLast(String::compareTo)

	Comparator<Employee> empNameComparator = Comparator.comparing(Employee::getName, Comparator.nullsFirst(String::compareTo));
	
	String[] strArray = { "aman", "suvam", null, "sahil", null };
	
	/**
	 * nullsFirst for primitive Types
	 */
	Arrays.sort(strArray, Comparator.nullsFirst(Comparator.naturalOrder()));
	Arrays.stream(strArray).forEach(System.out::println);
	
	/**
	 * nullsFirst for Custom Object
	 */
	User u1 = new User("Aaman", 25);
	User u2 = new User("Joyita", 22);
	User u3 = new User("Suvam", 28);
	User u4 = new User("mahafuj", 25);

	System.out.println("******************");
	List<User> list = Arrays.asList(u1, u2, u3, null, u4);
	
	list.sort(Comparator.nullsFirst(Comparator.comparing(User::getName)));
	list.stream().forEach(System.out::println);
	System.out.println("******************");
	Collections.sort(list,Comparator.nullsLast(Comparator.comparing(User::getAge)));
	list.stream().forEach(System.out::println);
	
*****************************************************  17.Function package (javabrahman)  *******************************************************************

For common use cases where Lambda Expression or a Method Reference are needed, Functions are generally assigned as a target type.
java.util.function package provides a set of reusable Functional interfaces which can be used by the programmer instead of creating new Functional interfaces.

Consider the scenario where we need a function that accepts an argument and returns boolean.

	public interface Predicate<T>
	{
		boolean test(T t);
	}
	
Then function descriptor would 	

	(T) -> boolean
	
where T is the parameter and boolean is the return type.

Function :
----------
Function Interface represents a function that takes one type of argument and returns another type of argument.
Function Interface definition would be
	
	interface Function<T,R>
	{
		public R apply(T parameter)
	}
	
Function Interface implementation is now inlined in the declaration of same variable rather in seperate Class.

	Function<Integer, Integer> sum = (value -> value + value);

	public class PredefinedFunctionDemo {
	static Function<Integer, Integer> sum = (value -> value + value);
	static Predicate<String> nullCheck = (value -> value != null && value != "");
	static Consumer<String> display = (value -> System.out.println(value));
	static Supplier<String> fetch = () -> "Get the Value from Supplier";

	public static void main(String[] args) {
		PredefinedFunctionDemo demo = new PredefinedFunctionDemo();

		// Calling Function Interface
		System.out.println(demo.sum.apply(23));

		// Calling Predicate Interface
		System.out.println(demo.nullCheck.test(""));

		// Calling Consumer Interface
		demo.display.accept("Srinivas Sankoji");

		// Calling Supplier Interface
		System.out.println(demo.fetch.get());
	}
	}

Predicate :
-----------
Predicate represents a function that takes a single value as parameter and returns either true or false.
Predicate definition would be

	public interface Predicate<T>
	{
		public boolean test(T t);
	}
	
	boolean result = PredicateInterfaceDemo.nullCheck.test("");
    System.out.println(result);
	
Consumer :
----------
Consumer Interface represents a function that accepts an argument and returns no result.

	Consumer<String> display =(value -> System.out.println(value));
	PredefinedFunctionDemo demo = new PredefinedFunctionDemo();
	demo.display.accept("Srinivas Sankoji");

Supplier :
----------
Supplier is a fucntion that does not take any argument and returns the result.

	Supplier<String> fetch=() -> "Get the Value from Supplier";
	PredefinedFunctionDemo demo = new PredefinedFunctionDemo();
	System.out.println(demo.fetch.get());
	
	
*****************************************************  18.Base64 Encode Decode  ******************************************************************

                                                                
*****************************************************  19.Streams (winterbe)  ********************************************************************

Done

***************************************************** 20.Map in Java8 (beginnersbook) ************************************************************

1.compute :
-----------
compute() of HashMap allows us to update the value with the specified key.
compute() has two parameters
1.key and 
2.reMapping Function i.e. computes a new value for the specified key.

Note:
reMapping function takes two arguments and is considered as BiFunction.
During computation reMapping function should not be able to modify the Map.
Returns the new value associated with the key or null If no value is associated with the key.
If the remapping function results null then mapping for the specified key is removed.

		Map<String,String> map=new HashMap<>();
		map.put("One", "Bhaumik");
		map.put("Two", "Aadvik");
		map.compute("One", (key,value)-> value=value+" Chary");
		map.compute("Two", (key,value)-> value=value+" Chary");
		System.out.println(map); //{One=Bhaumik Chary, Two=Aadvik Chary}
		
		/**
		 * Compute to sum the Values
		 */
		Map<String,Integer> map1=new HashMap<>();
		map1.put("One", 23);
		map1.put("One", 15);
		
		map1.compute("One", (key,value) -> (value == null) ? 1 : value + value);
		System.out.println(map1); //{One=30, Two=23}
		
2.computeIfAbsent :
-------------------
computeIfAbsent() computes a new value associated with the specified key if the key is not present.
If the Key is present then computeIfAbsent does not effect the Map.

computeIfAbsent() takes two parameters
key
reMapping Function cannot take two arguments and takes single argument.

		HashMap<String, Integer> map = new HashMap<>();
		map.put("key1", 10000);
		map.put("key2", 55000);
		map.put("key3", 44300);
		map.put("key4", 53200);
		
		System.out.println(map);
		map.computeIfAbsent("key5", key -> 87000);
		System.out.println(map); //{key1=10000, key2=55000, key5=87000, key3=44300, key4=53200}

3.computeIfPresent :
--------------------
computeIfPresent() computes a new value and associates with the specified key if the key is present.
If the key is not present the computeIfPresent does not effect the Map.

computeIfPresent() takes two parameters
key
reMapping Function can take two arguments and is considered as BiFunction.
If the reMapping Function returns null then mapping for the specified key is removed.

		map.computeIfPresent("key4",(key,val)-> val+1);
		System.out.println(map); // {key1=10000, key2=55000, key5=87000, key3=44300, key4=53201}
		
4.merge :
---------
merge() can be used to combine multiple mapped values for a given key using mapping function.

Note :
If the key is not present,It simply outputs the key along with the corresponding value in the HashMap as a new Entry.
If the key already holds some value remapping function merges both the old and new value for the given key.
In case key is null,It always mapped to bucket 0 as hash is not calculated for null keys due to NPE.

		/**
		 * Merge to sum the Values
		 */
		Map<String,Integer> map1=new HashMap<>();
		map1.put("One", 22);
		map1.put("Two", 27);
		
		Map<String,Integer> map2=new HashMap<>();
		map2.put("One", 23);
		map2.put("Two", 15);

		map2.forEach((key,value) -> map1.merge(key, value, (v1,v2) -> v1+v2));
		System.out.println(map1); //{One=45, Two=42}
		
5.getOrDefault() :
------------------
getOrDefault() of HashMap returns the specified default value If the mapping for the specified key is not found.

 
***************************************************** 21.PermGen () *************************************************************************	 					

