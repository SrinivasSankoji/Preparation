References :
------------

http://www.mkjava.com/tutorial/spring-session/
https://www.javadevjournal.com/spring/spring-session/
https://www.journaldev.com/21748/spring-session-management-spring-session-jdbc
https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/
https://www.javainuse.com/spring/springboot_session



1.Building a Horizontally Scalable Cloud Native Application :

 Cloud Native Application Architecture assumes that application will be scaled by 
 running more no of Instances of the Application in the Linux Containers on a Large
 Pool Of Virtual Machines.
 For Example It Is easy to deploy a War File to Tomacton Cloud Foundry or Heroku and then Sacale 
 to 100 app instances with 1 GB Ram per Instance in a few Seconds.
 We Can Also increase the Cloud Platform to Increase or decrease the Number of 
 Application Based on Our Demand.
 
 Many Application Servers Store Http Session State in the Same JVM That is running the
 Application Code Sinc it Is Easy and Fast to Implement.
 When an New App Server Joins or Leaves the Cluster then Http Sessions are Rebalanced over the
 Remaining App Server Instances.
 In a Elastic Cloud Environment Where we are Running Hundreds of App Server Instances and 
 there may be chance adding or deleting the New App Server Instances and there would be adding
 Problem.
 
 Rebalancing Http Session Can become a performance bottleNeck.
 Large HeapSize needed for String Large Number of Sessions and can cause to Garbage Collector.
 TCP Multicast is Usually Prohibited by Cloud Infrastructure and these are Used by  Http Session 
 to identify which new App Server Instances are Joined or Left From the Cluster.
 
 Therefore it is more efficient to store the Http Session state in a Data Store Outside the JVM Running 
 the Application Code.
 For Example 100 Instances of Tomcat Can be Configured to Redis For Storing the Session data and
 If the Number of Instances in the Tomacat Increased or Decreased the Session in Redis are Unaffected.
 
 For Open Source Servers Like Tomcat It Is easy to find Alternative Implementation Of Session Manager
 that uses data store like Redis and MemCached.
 However the Configuration Process is Compleax and Is Specific to each Application Server.
 For Closed Source Products such as WebLogic and WebSphere finding an Alternative For Session Managers
 is not only Difficult but also Impossible.
 
 Spring Session Provides an Application Independent way to configure Pluggable Data Store 
 Within the bounds of the Servlet Specification and Without having any rely on Application Server
 API's.
 This Means That Spring Session works with all App Servers that Implement The Servlet 
 Specification and is very easy to Cofigure on the Applivation Servers.
 We also get to choose whatevre External Data Store we want to Choose.
 
 2.Multiple Accounts per user :
 
 When We Use Http Session to Track Application State,Such as Currently Logged In User 
 And If I Wnat to switch from one Application to Another Application we need to Log out and then Log In.
 With Spring Session it is trivial to configure Multiple Http Sessions Per User ,enabling the
 User to Switch Between the Multiple Acccounts without need of Logout and Log In.
 
 3.Multi-level Security Preview :
 Typical Web Application stores the Identity of the Current User and their roles in the Http Session.
 Since Web Application Can Have Only One Session Per Logged in User We wont be able to switch from One Account 
 to Another Account.
 With Spring Session We Can Easily Create Multiple Sessions per Logged In User and Each of those Session 
 Is completely Independent of the other Session.
 So Preview Functionality for Multiple users Can be Easily Acheived.
 
 4.Staying Logged In While Using Web Sockets :
  According to Servlet Specification Requests arriving over Web Socket Cant Make the Http Session Alive.
  When the user Starts Chatting,Session CountDown Timer Starts and When the  Http Session Expires then 
  the Web Socket Connection is also Closed.
  With Spring Session We Can Eventually Make Sure That both Web Socket Request and Regular Http Requests 
  keep Http Session alive for our users.
  
  5.Accessing Session Data for non web requests :
  
  We Can Access the Spring Session from Any Non Web Application as Long as we know the Session Id.
  Spring Session has More Rich API Then Regular Servlet Http Session API.
  So we Can Retrieve Very Specific Session Just by Knowing The Session ID.
  
  6.Spring Session Architecture :
  
  While Implementing Session Manager Two Key Problems Must be Solved.
  How to Create a Clustered High Availaibility Session that can Store Data Reliably and Efficiently.
  How to determine 	which Session Instance is Associated with which request i.e whether the request is Http,
  WebSocket,AMQP or some other Protocol.
  
  i.e How the Session ID Is Transmitted over the Protocol That is used for Making The Request.
  
  For The First Problem i.e Storing Data in a High Availaibility Scalable Cluster is already well Solved by
  Various Data Stores Like Redis,GemFire,APache Geode etc.
  Spring Session has Defined standard Set of Interfaces that has to be implemeneted by various data stores
  to mediate Acces to the Data Store.
  Interfaces Are
  
  Session  Interface
  ExpiringSession Interface
  SessionRepository Interface
  
  
  Spring Session Assumes that the problem of Associating a request to specific Instance is protocol Specific
  because the client and the server need to agree on a way to transmitt the sessiod over 
  the request and response Cycle.
  
  If the Request are arriving over Http then Session can be associated with a request by using 
  Http Headers or Http Cookies.
  If the Request are Arriving Over HttpS then the Session can be associated with a request by using 
  SSL SessionId.
  If JMS is Used the JMS Header Can be used to store the sesson Id Between the Request and Response.

  For Http Protocol Spring Session Defines HttpSessionStrategy Interface With two Default Implementations :
  CookieHttpSessionStrategy which uses HttpCookie to Associate a Request with Session Id.
  HeaderHttpSessionStrategy which use HttpHeaders to associate a request with Session Id.
  
  
  Spring Session Over Http :
  
  Spring Session Ships with Built in Support For Redis.
  
  Tc Configure Spring Session in Spring Boot We need to add two Dependencies.
  
  spring-session and
  spring-boot-starter-redis.
  
  Configuring Connectivity From Spring Session to Redis can be done by Adding Properties 
  in th application.properties file.
  
  By Default Spring Session Uses HttpCookie to Store the Session Id and we can also Configure Spring Session 
  to use a Custom Http Header Such As x-auth-token.
  
  
  Multiple Sessions Per Browser :
  
  Spring Session Keeps Track of Multiple Users By Using  Session Alias Parameter i.e _s Paramter.
  If The Request has no _s Parameter then Spring Session treats that as the Default Session.
  
  In order to create a new Session Per Browser 
  call the request.getSession()
  
  

  
  
	
  
  
  
  
  
  
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 