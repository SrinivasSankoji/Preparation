References :
************
https://www.devglan.com/spring-cloud/spring-cloud-gateway
https://www.devglan.com/spring-cloud/spring-cloud-gateway-example
https://medium.com/@niral22/spring-cloud-gateway-tutorial-5311ddd59816
https://medium.com/@niral22/spring-cloud-gateway-tutorial-5311ddd59816
https://github.com/TechPrimers/spring-cloud-gateway-example-1

1.Micro services Communication:Zuul API Gateway Dzone :
*******************************************************
The Crux of Micro Service Pattern is that create an Independent Service which has to be scaled and deployed Independently.
So In a Complex Business Domain,we Have More than 50 to 100 Micro Services.

Lets Imagine a System Where We Have to Implement a UI Which is a Kind of Dash Board,
which calls these 50 to 100 Micro Services to fetch the Information and Show it to the UI.

From a UI Developer Perspective,It has to call these 50 to 100 Micro Services and he has to Maintain All the details of Micro Services
like URL,Port and RestEnd Point.
More over The Common Aspects of a Web Program are CORS,Authentication,Authorization,Security and Monitoring  etc.
Here Micro Service has to develop all the Aspects on its Own and Same Code has to be replicated over Fifty Micro Services.
To Make it Robust,Code has to Be Changed in Such a Way that we have Only One Entry Point,
where all the Common Aspects of the Code is Written and Client Communicates with that Service.
The Concept of ZUUL Comes into the Picture.

ZUUL Acts as an API Gateway.It Receives all the Request Coming from the UI and then delegates the Request to the Internal Micro Service.
So we have to Create a Brand new Service which is Zuul Enabled and this Service Sits on Top of all Micro Services.
It Acts as an Edge Service or Client Facing Service and it Should be exposed to the Client UI.
Client Calls this Service as a Proxy For an Internal Micro Service and this Service Delegates the Request to the Appropriate Service.
We Can also Implement routing Rules and Filter Implementation.
We can also Perform Load Testing to the ZuuL Service as it is Independently Scalable and Deployable.

Spring Netflix Zuul :
*********************
ZuuL Proxy Can be used to Route to different Micro Services.
When We have Multiple Micro Services Running,ZuuL Proxy does the Intelligent Routing based on Requested Resource.
We can also perform some Filters to the requests and perform some operations before the execution of actual Request.

API Gateway means Single Point of Entry for all the Requests.
We have Single Interface Exposed on behalf of all the Micro Services Running.
This gateway at run time will identify the correct service to be invoked.
To achieve this routing we will have Netflix ZUUL Proxy.
ZUUL is and Edge Service that provides Dynamic Routing,Monitoring,Resiliency,Security and So On.

Zuul Filter Implementation :
****************************
Some Times it is Required to intercept the Request and Response that is passed through the Gateway.
Doing So We can add Some Validations or Modify Headers of Request Response.
For This Zuul Provides Filter Implementation and this Filter Implementation has full control of how to proceed with request and response.
We Have 4 Types of Filters :

1.PreFilter is executed Before the request is Routed to the Actual Request.
2.Route Filter To redirect the Request
3.Post Filter that is executed after the Request is Routed.
4.ErrorFilter that is executed when any error is occurred during routing.


*********************************************************  Spring Cloud Gateway Concepts (Devglan) *********************************************************

0.Introduction
1.Blocking vs Non-Blocking Gateway
2.Spring Cloud Gateway Architecture
3.Handler Mapping
4.Web Handler Filters
5.Post Filters


0.Introduction :
----------------
API Gateway Provides a Single Point of Entry for all the Micro Services Running downStream.
There are Many Gateway Solutions Available Such as Zuul,Linkered,Nginix,Spring Cloud Gateway etc.
Spring Cloud Gateway - A Reactive Gateway Built Upon Project Reactor,Spring WebFlux and Spring Boot 2.0.

1.Blocking vs Non-Blocking Gateway :
------------------------------------
Blocking Gateway Such as Zuul requires request Per Thread to handle the Requests that are Coming From API Gateway.
Hence Lot of Resources Required to Handle these Requests.
Any Extra Request Simply Sit in the Queue and will wait Until a Working Thread Complete its Execution.
Where as In Case of Non Blocking ,A Main Thread will always will be Available to Serve the Request 
and Other Multiple Threads will process those Request Asynchronously in the Background.
Once The Request is Completely Processed Then The Response is Returned.
Hence the Non Blocking Gateway requires less No of Resources to Serve the Same Amount of Requests Compared to Blocking Gateway.
Spring Cloud Gateway is a Non Blocking Reactive Gateway Similar to Zuul2 But Spring Cloud Does Not Provide any Out Of Box Integration with Zuul2.

2.Spring Cloud Gateway Architecture  :
--------------------------------------
Once a Request Reaches to the Gateway,First thing The Gateway does is It matches the Request with each of the available routes based on the predicate Defined.
Once The Request has been Matched,request Moves to the Web Handler and the filters will be applied to the Request.
There are Many out of Box Filters Provided by the Gateway itself to Modify the Request Header as well as the Body.
PreFilters are applied Specifically to a Route Where as Global Filters can be applied to all the Route Requests.
Global Filters can be applied to Perform Authentication and Authorization of all the Requests at one Place.
Once the Response is generated by the downStream Service,Post Filter can be used to modify the response
such as to apply the Checksum in the Response Header to all the Responses to ensure Response is not tampered due to Middle Man Attack.

Reverse Proxy :
***************
Reverse Proxy is Something That It is Making Requests on behalf of Something Else.
It Acts More Like Simple Routing.
It can add Basic Security and Monitoring But Cannot do Some of the Advanced Things Like Mediation and Orchestration.
Nginix is one of the Well Known Reverse Proxy Server.

API Gateway :
*************
API Gateway is enhanced reverse proxy with More Advanced Capabilities Like Mediation and Orchestration.
Some of The Gateway are Netflix Zuul,Amazon API Gateway,Apigee,Spring Cloud Gateway.

Spring Cloud Gateway :
**********************
Spring Cloud Gateway is an API Gateway Implemented By Spring Team on top of Spring Cloud Reactive Eco System.
It Provides a Simple and effective Way to route incoming Requests to The appropriate destination Using Gateway Handler Mapping.
Spring Cloud Uses Netty Server to Provide Non Blocking Asynchronous Request Processing.

Spring Cloud Gateway Consists of 3 Main Building Blocks 

Route :
-------
Routes are the basic building block of an API Gateway.It is Defined by an ID,Destination URI,Collection of Predicates and Collection of Filters etc.
Based on Predicates,Gateway Routes to a Particular Request.
Spring Cloud Gateway provides many built in Routes,Predicate Factories Such as Path,Host,Date/Time,Method,Header etc.

Predicate :
-----------
Nothing But Condition to Match.Based on Condition it will Route to the Particular Service.

Filter :
--------
These are the Instances of Spring Framework Web Filter.
This is the Place where we can Modify the Request or Response.

Spring Cloud Gateway vs Zuul :
******************************
ZuuL 1.x is Not Reactive and it is Blocking.
If We Want to Improve the Performance of MicroServices We can Use Spring Boot 2 With Reactor.
We can use Zuul 2.0 which does Have Reactive Non Blocking Support with Netty.
Spring Eco System Does Not Have In Built Support like Zuul 2.x.
If we want to get The Features of Authentication and Other Security Features Use Spring Cloud Gateway.

We Can do Route Configuration in Spring Cloud Gateway Using Two Approaches :
1.Programatically Using Spring Route Locater
  The Problem with Approach is that When we Update the Route We need Redeploy the Whole Application.
2.Using application.properties 


3.Handler Mapping (Route):
**************************
This is the First Component Where all the Requests Hit.
Handler Mapping looks into each route that is defined and tries to Match With The each Predicate defined inside the route.
After the Match,Handler Mapping routes The request to The Particular Route.

Predicates :
------------
Path Predicate
Host Route Predicate
Date/Time Route Predicate
Method Route Predicate
Header Route Predicate
Query Parameter Route Predicate
Cookies Route Predicate

4.Web Handler Filters :
***********************
We Have PreFilters,Post Filters and Global Filters.
There are Many Filters Provided By Gateway Out Of Box.
It Also Provides the Flexibility to define Our Custom Filters That Can be Either Applied to a Specific Route or to all the Request Coming to the Gateway.

PreFilters :
------------
AddRequestHeader WebFilter
ReWritePath WebFilter
RateLimiting WebFilter
Hystrix WebFilter
Modify Request Body Filter

GlobalFilters :
---------------
Netty Router
Web Sockets
Load Balancer
Metrics

Post Filter :
-------------
Add Response Header Filter
Remove Response Header Filter

		http://localhost:8096/api/v1/first/getRequestHeaderOld
		
		http://localhost:8096/api/v1/second/getRequestHeader

*********************************************************  Spring Cloud Gateway Example (Tech Primers) ******************************************************

http://httpbin.org/get   Dummy Rest Service
https://spring.io/guides/gs/gateway/   Gateway Configuration
actuator/hystrix.stream  To Check Enable Hystrix Stream
Hystrix DashBoard :  /hystrix

Routing Information We add in the Gateway Configuration File.
We can also add Routing Information Using yml Configuration File.
Use the Example in the Spring Cloud Guide and Copy in the Configuration File.

URL For Jokes Service :
https://rapidapi.com/LemmoTresto/api/joke3

Here We are Hard Coding the URL of the Services Instead of that We Can use Service Discovery to identify the Services along with the Gateway.
Now the Two Services i.e Countries Service and Jokes Service are Working Fine Now.
Now We Need to Enable Hystrix Service.
For That We Need to Add the Actuator Dependency and run With the End Point actuator/hystrix.stream

 i.e http://localhost:9031/actuator/hystrix.stream
 
For this to Work we need to add the Below Property in  the Application.properties 
management:
  endpoints:
    web:
      exposure:
        include: hystrix.stream
		
		
How Long can I Wait Before I Time Out i.e 

If I Enable Hystrix on Particular Service i.e Countries Service and If the Countries Service Takes More Than 5 Seconds then It Should Fail.
By Default Hystrix Takes One Second and It Fails Here.
Here We need To Mention it in the Properties File.

Now Start the Hystrix DashBoard Service 
and Run With The URL  http://localhost:9032/hystrix

To The DashBoard We Need to Give The URL Of The Stream which Connects to any Hystrix Stream.
We can Have a Central Hystrix DashBoard that Plug in Different Gateway Services which we have in our Project.
Now Add the URL Of The Service With Stream i.e http://localhost:9031/actuator/hystrix.stream to the Hystrix DashBoard and Monitor It.
Now To Work This Add the Hystrix COnfiguration to the Gateway Using Filters.
The Hit The Countries Service and Refresh The DashBoard.
We Can also Have FallBack Mechanism in the Gateway Configuration.

********************************************************* Spring Netflix ZUUL API Gateway Example (Devglan) ************************************************

By Default Zuul routes request by Service Name which is resolved by Discovery Server.
If the request is like http://localhost:8092/first-service/getRequestHeader then Zuul discovers the Service Name with first-service and 
routes the request to it for url mapping first.

Basically Zuul Strips the prefix and route it to the corresponding service.


********************************************************* Spring Netfilx ZUUL API Gateway (levelup) ********************************************************

Gateway acts as a Middleware between the UI and MicroService.

The two Advantages of Gateway approach are
1.UI does not need to be aware of the Network Location of the individual Micro Service and needs to know only the Network Location of the 
Gateway MicroService.
Gateway will route the incoming request to the relevant Backend Services.

2.Cross Cutting Concerns such as Authentication,Security,Monitoring,CORS etc will be handled by the Gateway.
Whenever Change is required in any of these aspects,that Change can be made in Single Place to affect all the Micro Services.

ZUUL is an API Gateway or an Edge Server developed by Netflix and is capable of performing the below Tasks.

1.Authentication and Security
Identifying Authentication requirements for each resource and rejecting request that do not satisfy them.

2.Insights and Monitoring
Tracking Meaningful data and statistics at the edge in order to give us an accurate view of Production

3.Dynamic Routing
Dynamically routing Request to different Backend Services as needed.

4.Stress Testing
Gradually increasing the traffic to a Cluster in order to Gauge Performance

5.Load Shedding 
Allocating Capacity for each type of Request and dropping request that go over the Limit.

6.Static Response Handling
Building some responses directly at the Edge instead of forwarding them to an Internal Cluster

Integration with Eureka :
-------------------------
In a real MicroService Systems ZUUL works hand in hand with Service Discovery Tools like Eureka.
ZUUL does not maintain hard coded network Locations (HostName and Port Number) of back end Micro Services.
Instead ZUUL Intercats with Service Registry and dynamically obtains the target Network Locations.

Following are the important properties which Enable ZUUL to perform the Request Routing.

	zuul.routes.courseservice.path=/course-service/**
	zuul.routes.courseservice.serviceId=course-service
	
If the request comes to the URL path /course-service/** that request will be redirected to the service registered with service id  course-service.
While Redirecting ZUUL will by default strip the /course-service/ portion of the URL.


********************************************************* Spring Cloud API Gateway (javainuse) ******************************************************

Spring Cloud Gateway has the following building blocks.

1.Route
2.Predicate 
3.Filter

Route is the basic building block of API Gateway and it consists of ID,destination URI and Collection of predicates and Filters.
Predicate is similar to Java 8 and it can be used to match  http requests such as Headers,URL or Cookies parameters.
Filters can be used to modify the request or response as per the requirement.

When the Client makes a request to the Gateway Gateway HandlerMapping checks whether the request matches to a route or not.
This can be done by using Predicates.If it matches the predicates then it forwards the request to the Filter.

Routes can be created in either of the two following ways
1.Java based Configuration
2.Property based Configuration

	http://localhost:8096/consumer/message
	
	http://localhost:8096/emloyee/message
	





 

 

 













