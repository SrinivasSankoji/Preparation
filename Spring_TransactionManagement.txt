1.Transaction Management									(oracle docs)   [29-NOV-2021]	(Done)
2.Spring Transaction Management								(marcobehler)   [30-NOV-2021]	(Done)	
3.Spring Boot Transaction Management						(javainuse)   	[30-NOV-2021]	(Done)
4.Spring Boot Transaction Management Isolation				(javainuse)   	[30-NOV-2021]	()
5.Spring Boot Transaction Management Propogation			(javainuse)   	[30-NOV-2021]	()
6.Spring Boot Transaction Management Rollback				(javainuse)   	[30-NOV-2021]	()

*****************************************************  1.Transaction Management (oracle docs) *******************************************************************

Transaction can be considered as one or more statements that are executed as a single unit.either all the statements are executed or none of the statements are executed.
When a Connection is created by default it is auto commit mode.
This means each individual statement is treated as a Transaction and is automatically committed right after it is executed.
The way to allow one or more statements to be grouped into a Transaction is to disable the auto commit mode.

	connection.setAutoCommit(false);
	
After the auto commit mode is disabled No SQL statements are committed untill we call the commit() explicitly.

Dirty Read :
------------
Accessing an updated value that has not been committed is considered as Dirty Read.
It is possible for that value to be rolled back to its previous value.

If the Transcation isolation level is set to TRANSACTION_READ_COMMITTED then DBMS does not allow dirty reads to occur 
ie it does not allow the value to be accessed untill it has been committed.

rolllback() terminates the transaction and returns any values that were modified to their previos values.

***************************************************** 2.Spring Transaction Management (marcobehler) **************************************************************

In order to understand what Spring Transaction Management does is we need to have rough understanding of what Database Transactions are and why to use them.

How plain JDBC Transaction Management works :
---------------------------------------------
We need a connection to the Database to start the Transaction.In most of the Enterprise Applications we get the Connection from the Datasource.
When a Connection is created by default it is auto commit mode.This means each individual statement is treated as Transaction.
We need to set the auto commit to false so that we are the master of the Transaction.
Plain JDBC Transaction Management code looks like this.

			import java.sql.Connection;
			Connection connection=datasource.getConnection();
			try(connection){
				connection.setAutoCommit(false);
				//Execute SQL Statements
			}
			catch(SQLException e)
			{
				connection.rollback();
			}

How Spring’s or Spring Boot’s Transaction Management works :
------------------------------------------------------------
Transaction Management in Spring means how does Spring start,commit or rollback the JDBC Transactions.
With plain JDBC we only have one way to manage the Transactions ie connection.setAutoCommit(false).
With Spring we have many different and more convenient ways to achieve the same.
We define Transaction Management in Spring programatically either by using TransactionTemplate or by using PlatformTransactionManager.

			@service
			public class UserService
			{
				
				@Autowired
				private TransactionTemplate template;
				
				public Long registerUser(User user)
				{
					Long id=template.execute(status	-> {
					//execute SQL statements
					//inserts the user into the database and returns the autogenerated id
					return id;
					}
				});
			
			}

Here we don't have to mess with opening or closing Database Connection.
No need to cathc SQLException as Spring converts these into RuntimeException.
TransactionTemplate internally uses TransactionManager which internally uses 

How to use Spring’s @Transactional Annotation (Declarative Transaction Management ) :
-------------------------------------------------------------------------------------
Spring Transaction Management using @Transactional Annotation will be like below.

	public class UserService
	{
		@Transactional
		public Long reegisterUser(User user)
		{
			//executes SQL statements
			//inserts the user deatils into the database and returns the generated id
			//userDao.save();
			return id;
		}
	}
	
Make sure Spring Configuration is annotated with @EnableTransactionManagement Annotation.
Also specify the Transaction Manager in Spring Configuration file.

	@Configuration
	@EnableTransactionManagement
	publci class DatabaseConfiguration
	{
	
		@Bean
		public PlatformTransactionManager platformTransactionManager()
		{
			return transactionManager;
		}
	}
	
Whenever we are using @Transactional on any Bean,It not only insantiates the UserService but also creates the transactional proxy for that user service.
The different Propogation Levels used for the Transaction are

Required : This method needs a Transaction either open one for me or use an existing one.
Supports : This metho does not care If a Transaction is opened or not.It can work either way.
Mandatory
Require_new
Not_Supported
Never
Nested

How Spring and JPA / Hibernate Transaction Management works :
-------------------------------------------------------------
If Spring Application wants to integrate with any other ORM vendor then the code would be

		public class UserDao{
		
		@Autowired
		private SessionFactory sessionFactory;
		
		public void registerUser(User user){
			Session session=sessionfactory.openSession();
			session.beginTransaction();
			session.save(user);
			session.getTransaction().commit();
			session.close();
			}
		}
		
With Spring and Hibernate to integrate with each other as they know about theit Transactions the above code can be replaced by 

		public class UserDao{
		
		@Autowired
		private SessionFactory sessionFactory;
		
		@Transactional
		public void registerUser(User user){
			sessionfactory.getCurrentSession().save(user);
			}
		}
	
To achieve this instead of using DataSourcePlatformTransactionManager use the HibernateTransactionManager(Plain Hibernate) or 
JpaTransactionManager(Hibernate with JPA)

********************************************** 3.Spring Boot Transaction Management (javainuse)  *************************************************************

Application Transaction is a sequence of Application actions that are considered as a single logical unit by the Application.
For example joinOrganization() will be considered as one complete Transaction.
joinOrganization() consists of two actions.

Persist Employee Information
Persist Health Insurance Information

Due to any reason If any one of the above action fails then other actions hould also be failed.

********************************************** 4.Spring Boot Transaction Management Isolation  ****************************************************************

	


********************************************** 6.Spring Boot Transaction Management Rollback ******************************************************************

For an Application Transaction If any action fails then all other actions gets rolled back.
In the previous example we tested the rollback by throwing an unchecked Exception.
In practical it is checked Exception that gets thrown.
These are business Exception's based on logic.
In case of checked Exception previously executed transactions do not get roll back automatically even If we use @Transactional Annotation.
We need to inform the Application how to handle roll back in case of checked Exception.
This can be achieved by using RollBackFor Annotation.

Create the custome Exception named InvalidInsuranceAmountException according to our Business Logic.

	void registerEmployeeHealthInsurance(HealthInsurance healthInsurance) throws InvalidInsuranceAmountException;
	
	@Override
	public void registerEmployeeHealthInsurance(HealthInsurance healthInsurance) throws InvalidInsuranceAmountException {
		if (healthInsurance.getCoverageAmount() < 0) {
			throw new InvalidInsuranceAmountException("Coverage Amount Should not be negative");
			}
		healthInsuranceDao.registerEmployeeHealthInsurance(healthInsurance);
	}
	
	@Override
	@Transactional(rollbackFor = InvalidInsuranceAmountException.class)
	public void joinOrganization(Employee employee, HealthInsurance healthInsurance) throws InvalidInsuranceAmountException
	{
		employeeService.insertEmployee(employee);
		//For Unchecked Exception and @Transactioal Annotation works
		/**if (employee.getEmpId().equals("emp1")) {
			throw new RuntimeException("thowing exception to test transaction rollback");
		}**/
		try {
			healthInsuranceService.registerEmployeeHealthInsurance(healthInsurance);
			} catch (InvalidInsuranceAmountException e) {
			throw new InvalidInsuranceAmountException("Exception is thrown");
			}
	}
	




