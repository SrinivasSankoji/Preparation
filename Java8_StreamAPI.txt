1.Java 8 Stream											(winterbe)     			[08-SEP-2021]  	(Done)
2.colelct                                               (winterbe)     			[03-DEC-2021]  	(Done)
3.FlatMap                                               (winterbe)     			[03-DEC-2021]  	(Done)
4.Reduce                                                (concretepage)     		[03-DEC-2021]  	(Done)


************************************************************ 1.Java 8 Stream  ************************************************************

Streams are Monads thus playing a big part in bringing Functional Programming to Java.
Stream represents a sequence of elements and supports different kind of operations to perform computation on those elements.
Stream operations are either Intermediate or Terminal.
Intermediate Operations returns a Stream so that we can chain multiple Intermediate operations without using Semi Colon.
Where as Terminal Operations either return void or Non Stream result.
Filter,Map and Sorted are Intermediate Operations where as forEach is Terminal Operation.
Most Stream Operations accept some kind of Lambda Expression as a Parameter ie Functional Interface specifying the exact behavior of the Operation.
These Operations must be Non Interfering ans Stateless.
Non Interfering means it does not modify the underlying datasource of the stream.
Stateless means it does not depend on any mutable variables.

		List<String> myList=Arrays.asList("a1", "a2", "b1", "c2", "c1");
		 myList.stream().filter(s -> s.startsWith("a"))
		 .map(String::toUpperCase)
		.sorted()
		.forEach(System.out::println);
		
In the above example filter,map and sorted are Intermediate operations where as forEach is a Terminal operation.

Ways of creating a Stream :
---------------------------
Streams can be created fromm various sources like Collections,Arrays,Stream.generate() and Stream.iterate().
List and Set supports new Methods like stream() and paralellStream() to create Sequential Stream and Parallel Stream.
Parallel Streams are capable of operating on Multiple Threads.

Stream.of() can be used to create the Stream of Objects.

	Stream.of("a1","a2","a3").findFirst().ifPresent(System.out::println);
	
	String[] stringArray={"program","creek","java"};
	Stream<String> arrayStream=Arrays.stream(stringArray);
	
	Stream<Double> generate=Stream.generate(Math::random).limit(10);
		Double[] strArray=generate.toArray(Double[]::new);
		System.out.println(Arrays.toString(strArray));
		
	Stream<Integer> intStream=Stream.iterate(0, n -> n+1).limit(10);
		Integer[] intArray=intStream.toArray(Integer[]::new);
		System.out.println(Arrays.toString(intArray));
		
Java8 comes with the special kind of streams to work with primitive data types.
IntStream,LongStream,DoubleStream etc.

	IntStream.range(1, 4).forEach(System.out::println);

To convert IntStream to the Stream we used boxed().

	List<Integer> intList=IntStream.range(1, 4).boxed().collect(Collectors.toList());
	
Primitive Streams support the Additional Aggregation Operations like average() and sum().

	Arrays.stream(new int[] { 1, 2, 3 }).map(n -> 2 * n + 1).average().ifPresent(System.out::println);
	
SomeTimes it is useful to transform a regular Object Stream to Primitive Stream or vice Versa.
Here we use mapToInt,mapToLong,mapToDouble.

	Stream.of("a1", "a2", "a3").map(value -> value.substring(1)).mapToInt(Integer::parseInt).max()
				.ifPresent(System.out::println);
		
Processing Order In Streams :
-----------------------------
Important characteristic of Intermediate operation is Laziness.
An Intermediate Operation will only be executed when the Terminal Operation is present.
In native Approach elements would be executed one after Other.

Why Order Matters :
-------------------
Use Filter First and Then Map.
Filter will always be executed If it doesn't match the condition also.
If we are using any Stateless Operation like sorted then the Order would be Filter,Sorted,Map and Terminal Operation.

Reusing Streams :
-----------------
Java 8 Streams cannot be reused once we call the Terminal Operation.
		
		Stream<String> stream = Stream.of("a1", "b2", "c3", "d4").filter(s -> s.startsWith("a"));
		stream.anyMatch(s -> true);
		//stream.noneMatch(s -> true);//Streams cannot be reused and throws IllegalStateException stream has already been operated upon or closed

To overcome this we have to create a New Stream Chain for every Terminal Operation.
We have to create a Stream Supplier to construct a new Stream with all Intermediate operations already Set Up.

		private static void exampleThirteen() {
		System.out.println("Example Thirteen --> Stream Supplier With get --> Start ");
		Supplier<Stream<String>> streamSupplier = () -> Stream.of("a1", "b2", "c3", "d4");
		// .filter(s->s.startsWith("b"));
		streamSupplier.get().filter(s -> {
			System.out.println("Filter " + s);
			return true;
		}).map(s -> {
			System.out.println("Map " + s);
			return s.toUpperCase();
		}).anyMatch(s -> {
			return s.startsWith("B");
		});
		streamSupplier.get().anyMatch(s -> {
			System.out.println("AnyMatch " + s);
			return s.startsWith("a1");
		});
		System.out.println("Example Thirteen --> Stream Supplier With get --> End ");
	}
		
************************************************************ 2.Collect ************************************************************

Collect is an extremely useful Terminal Operation to get the stuff out from the Stream once donw with the peocessing.
collect accepts Collectors which consists of four different arguments ie Supplier,Accumulator,Combiner and Finisher.
collect is used to perform many operations like Summation,Grouping,Joining etc.
Java8 supports various built in Collectors via the Collectors Class.
For the most common operations we don't need to implement Collectors ourself.

1.To Transform the Stream of elements into another kind of result and get the data out from the Stream ie basic collect

	List<Person> persons = Arrays.asList(new Person("Max", 18), new Person("Peter", 23), new Person("Pamela", 23),
				new Person("David", 12));
	List<Integer> result = persons.stream().map(Person::getAge).collect(Collectors.toList());
	
2.To group the elements of the Stream based on condition we use groupingBy.

	Student s1 = new Student("Ram", 20, "A");
	Student s2 = new Student("Shyam", 22, "B");
	Student s3 = new Student("Mohan", 22, "A");
	Student s4 = new Student("Mahesh", 20, "C");
	Student s5 = new Student("Krishna", 21, "B");
	List<Student> list = Arrays.asList(s1, s2, s3, s4, s5);
	Map<String, List<Student>> result = list.stream().collect(Collectors.groupingBy(Student::getClassName));
	List<Student> results = result.entrySet().stream().map(Map.Entry::getValue).flatMap(List::stream).collect(Collectors.toList());
	results.forEach(s -> System.out.println(s));

3.Collectors are extremely versatile .We can also create aggregations on the stream ofelements.

	List<Integer> list = Arrays.asList(1,2,3,4);
		Double average=list.stream().collect(Collectors.averagingInt(number->number*2));
		
	List<Integer> integerArray=Arrays.asList(25,36,81);
		IntSummaryStatistics statistics=integerArray.stream().collect(Collectors.summarizingInt(number->number+number));

joining :
---------
We can convert the List into String format that can be passed as argument to IN parameter of SQL Statement.
This can be done by using joining method of Collectors Class.
To the joining() we can pass the delimiter,prefix and suffix too in concatenation.

	List<String> names=Arrays.asList("Ram","Shyam","Shiv","Mahesh");
	String result=names.stream().collect(Collectors.joining("','", "['", "']"));
	System.out.println(result);

Collect to Map :
----------------
In order to transfrom the stream of elements into Map,we have to specify both keys and values.
Here keys must be unique otherwise we get IllegalStateException.

	List<Person> list = new ArrayList<>();
	list.add(new Person("Mohan", 100));
	list.add(new Person("Sohan", 200));
	list.add(new Person("Mahesh", 300));
	Map<Integer, String> result=list.stream().collect(Collectors.toMap(Person::getAge, Person::getName));


************************************************************ 3.FlatMap ************************************************************

Map can be used to transform the elements of the Stream into another Type of Objects.
Map is limited because Object can only be mapped to exactly another Object.

FlatMap can be used to flatten/convert the Stream of Collections to a Stream of Objects.
The Objects are combined from all the Collections into the Original Stream.
Consider the scenario of conevrting List of List to List.

	List<Integer> list1 = Arrays.asList(1, 2, 3);
	List<Integer> list2 = Arrays.asList(4, 5, 6);
	List<Integer> list3 = Arrays.asList(7, 8, 9);
	List<List<Integer>> listOfLists = Arrays.asList(list1, list2, list3);
	List<Integer> result = listOfLists.stream().flatMap(List::stream).collect(Collectors.toList());

************************************************************ Reduce **************************************************************

reduce() combines all the elements of the Stream with the given function.The result is an Optional holding the reduced value.
reduce() can be used to get the sum of numbers Stored in the Collection,Concatenate the String with the Separator.

Java 8 supports 3 different kind of reduce() methods.

reduce(BinaryOperator accumulator) :
------------------------------------
reduce() accepts a Binary Operator i.e BiFunction where both operands share the same type.
BiFunctions are like functions but accept two arguments.

	Arrays.stream(intArray).reduce((x,y) -> x+y).ifPresent(System.out::println);

reduce(T Identity, BinaryOperator<T> accumulator) :
---------------------------------------------------
Second reduce() accepts both an Identity Value and a Binary Operator.
This way can be used to construct a new Object from the other objects of the Stream.

	int sum=0;
	int[] intArray= {23,43,56,97,32};
	sum=Arrays.stream(intArray).reduce(100,Integer::sum);
	System.out.println(sum);

reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner) :
---------------------------------------------------------------------------------------
reduce() accepts three parameters i.e Identity Operator,Binary Operator and Combiner Type Binary Operator,.
Here Identity Value type is not restricted to particular Object.


