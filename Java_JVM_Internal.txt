1.JVM  Architecture 					(DZone)						[29-NOV-2020]  (Done)	
2.Java Memory Management 				(DZone)						[30-NOV-2020]  ()
3.Dynamic Class Loading					(DZone)						[30-NOV-2020]  (Done)
4.Detailed Breakdown of the JVM			(DZone)						[18-NOV-2020]  ()
5.Evolution Java Memory Architecture	(DZone)						[18-NOV-2020]  ()
6.JVM Architecture						(Guru99)					[18-NOV-2020]  ()
7.JVM Architecture						(howtodoinjava)				[23-JAN-2021]  ()
8.JDK vs JRE vs JVM 					(guru99)					[23-JAN-2021]  ()


Delegation Heirarchy
Class Level Data
Stack Frame / Stack Area
Operand Stack
Frame Data 

************************************************************  1.JVM  Architecture (DZone) ********************************************************************

Java was developed with the concept of WORA i.e Write Once and Run Anywhere which runs on the JVM.
Compiler compiles the .java File and generates the .class file ie Byte Code.
Byte Code which is an input to the JVM will be executed by the JVM.
As a Java Developer If we know the Architecture of JVM,it enables us to write the code more efficiently.

What is JVM :
-------------
JVM is an engine that provides runtime Environment to drive the Java Code or Applications.
JVM converts the Byte Code into Machine Language.
JVM is a part of JRE.It cannot be seperately downloaded or installed.
To install JVM we need to install JRE.

In Many other programming languages,Compiler produces the Machine code for a specific System.
However Java Compiler produces a code for Virtual Machine which is called JVM.

JVM is divided into 3 main sub Systems.

1.Class Loader Subsystem
2.Runtime Data Area
3.Execution Engine

1.Class Loader Subsystem :
**************************
Dynamic Class Loading(Class.forName) functionality is handled by using Class Loader Subsystem.
Class Loader Subsystem loads,links and initializes the .Class file when it refers to a .class for the first time i.e at runtime and not compile time.
Class Loader Subsystem will follow the delegation hierarchy Algorithm while loading the Class Files.

A) Loading :
------------
Class Loading will be done by the 3 Class Loaders.

A.Bootstrap Class Loader :
--------------------------
Responsible for loading the Classes from bootstrap Classpath i.e rt.jar and highest priority is given to the Bootstrap Class Loader.

B.Extension Class Loader :
--------------------------
Responsible for loading the Classes which are inside ext folder i.e jre/lib.

C.Application Class Loader :
----------------------------
Responsible for loading the Classes at Application Level i.e path mentioned in the Environment Variable etc.

B) Linking :
------------
Verify :
Bytecode verifier will verify whether the generated byte code is proper or not and if the verification fails we wiil get the verification error.

Prepare :
For all the static variables memory will be allocated here and assigned with default values.

Resolve :
All Symbolic memory references are replaced with original references from method Area.

C) Initialization :
-------------------
This is the final phase of Class Loading.
Here all the static variables will be assigned with original values and static block will be executed.

2.Runtime Data Area :
*********************

A) Method Area :
----------------
All the Class level data including static variables are stored here .
There is only one Method area per JVM and is a shared resource.

B)Heap Area :
-------------
All the Objects and their corresponding instance variables are stored here.
There is only one Heap area per JVM and is a shared resource.

Since the Method Area and Heap Area shares memory for Multiple Threads,Data stored here is not Thread Safe.

C)Stack Area :
--------------
All Local Variables will be created in the stack Area.Stack Area is Thread safe since it is not a shared Resource.
For Every Thread seperate runtime stack will be created.
For every Method Call performed by the Thread,One entry will be stored in the Stack which is called Stack Frame.
Stack Frame is divided into 3 sub entities.

1.Local Variable Array :
Related to Method how many local variables are involved,corresponding values will be stored here.
2.Operand Stack :
If any Intermediate Operation is required to perform,Operand stack acts as runtime workspace to perform the operation. 
3.Frame Data :
All Symbols corresponding to the methods are stored here.

In case of any Exception,catch block information will be maintained in the frame data.

D)PC Registers :
----------------
Each Thread will have seperate PC Registers to hold the address of the current executing instruction. 
Once the instrcution is executed the PC Register will be updated with the next instruction.

E)Native Method Stacks :
------------------------
Native Method stack holds native method infromation.
For every Thread Seperate Native method stack will be created.

3.Execution Engine :
********************
Byte Code which is assigned to the Runtime Data Area will be executed by the Execution Engine.
Execution Engine reads the Byte Code and executes it piece by piece.

A)Interpreter :
---------------
Interpreter interprets the byte code faster but executes slowly.
Disadvantage of Interpreter is that when one method is called multiple times,every time a new interpretation is required.

B)JIT Compiler :
----------------
JIT Compiler neutralizes the disadvantage of Interpreter.
With the help of Interpreter,Execution Engine interprets the byte Code.
When the Execution Engine finds repeated code,it uses JIT Compiler which compiles the entire Byte Code and converts it into native code.
This native code will be used directly for the repeated method calls,which improoves the performance of the system.

Intermediate Code Generator : Generates Intermediate code.
Code Optimizer 				: Responsible for optimizing the Intermediate code which is generated above.
Target Code Generator 		: Responsible for generating Machine code or Native code.
Profiler 					: A Special componenet responsible for finding Hotspots i.e whether the method is called multiple times or not.

C)Garbage Collector :
---------------------
Garbage Collector collects and removes unreferenced Objects.
Garbage Collector can be triggered by calling Syste.gc() but the execution is not gauranteed.

D)Java Native Interface will be interacting with Native Method Libraries and provides the Native Libraries required for the Execution Engine.

************************************************************  2.Java Memory Management (DZone)   ************************************************************* 

Java has Automatic Memory Management and Nice Garbage Collector that works in the background to clean up the unused Objects and free up some Memory.
As a Java Programmer we do not need to bother with the problems like destroying Objects as they are not used any more.
However if the process is automatic in java It does not Gaurantee anything.
By not knowing how the Garbage Collector and Java Memory Management is designed,we could have Objects that are not Eligible for Garbage Collector,
even if it is no Longer Used.

By knowing how Memory actually works in java,as it gives the advantage of writing high performance and Optimized Applications that will never ever crash with an OutOfMemoryError.
Generally Memory is divided into two parts i.e Stack and Heap.Heap has huge amount of Memory compared to Stack.

Stack :
-------
Stack Memory is responsible for holding reference to heap objects and also for storing primitive types which holds the value itself
rather than reference to an object from the heap.
In addition variables on the stack have certain visibility also called as Scope.Only objects from the active scope are used.
Consider the scenario where we don't have global variables and only Local variables are present.
If the Compiler executes a method body,it can access only variables from the stack that are within the method body.
It cannot access other local variables as there are out of scope.
Once the method completes and returns,Top of the stack pops out and the active scope changes.

Stack Memory in Java is allocated per Thread.
Each time a Thread is created and started,it has its own stack Memory and cannot access another Thread's Stack Memory.

Heap :
------
Actual Object is stored inside the Heap Memory which is referenced by the vraiables from the stack.
Consider the scenario of creating a new Object.

	StringBuilder builder = new StringBuilder();
	
"new" keyword is responsible for ensuring that there is enough space on the Heap,creating an object of the type StringBuilder and assigned to the reference variable "builder" 
which goes to the stack.
For each Running JVM process there exists only one Heap Memory regardless of how many threads are running.
Heap Memory itself is divided into few  parts which facilitates the process of Garbage Collection.
Maximum stack and Heap sizes are not pre defined and depends on the running Machine.


Reference Types :
-----------------
In Java programming Language,we have different type of references that points from Stack memory to the Heap Memory.
Types of reference is that the Objects on the Heap they refer to are eligible for Garbage Collector.

Strong Reference :
------------------
Object on the Heap is not Garbage Collected when there is a Strong reference pointing to it.
It is strongly reachable through a chain of strong references.

Weak reference :
----------------
Weak reference to an object from the Heap is most likely not to survive after the next garbage collection process.
Best scenarion for Weak reference is Caching Mechanism.
If we want to retreive some data and want to store in memory as well.
Here the same data will be requested again.
If we put the weak reference and garbage collector runs then it destroys the object on the Heap.

Soft Reference :
----------------
Soft references are used for more memory sensitive scenarios.
These are going to be Garbage collected only when the application is running low on memory.
As long as there is no critical free up space,the Garbage Collector will not touch softly reusable objects.
Java Gaurantees that all the soft referenced objects are cleaned up before it throws an OutOfMemoryError.

Phantom Reference :
-------------------
Phantom reference are used to schedule post-mortem clean up actions.
Since we know for sure that Objects are no longer Live.
Phantom references are considered preferably as Finalizers.

How Strings are Referenced :
----------------------------
Strings are Immutable that means each time we do something with string,another object is created actually on the Heap.
For String Java manages a String Pool Memory.This means that Java Stores and reuse Strings whenever possible.
This is mostly true for String literals.

	String local_prefix="297";
	String prefix="297";
	
	if(""=="")
	{
		sysout("Strings are Equal");
	}
	else
	{
	sysout("Strings are Different");
	}

We can force the JVM to add the String to the SCP i.e String Content Pool we use intern().

Garbage Collection Process :
----------------------------
Depending on the type of reference that a variable from the stack holds to an object from the Heap,
At certain point in time,that object becomes eligible for Garbage Collector.








Garbage Collector Types :
-------------------------




Tips and Tricks For Java Memory Management :
--------------------------------------------
	

************************************************************  3.Dynamic Class Loading (DZone) ***************************************************************

Class.forName is used to load the class dynamically where we does not know the class name before hand.
Once the Class is loaded we will use newInstance() to create the object dyanmically.

************************************************************ 8.JDK vs JRE vs JVM (guru99)  ******************************************************************

JDK is a software Development Kit,JRE is a software bundle that allows us Java Program to run where as JVM is an environment for executing Byte Code.

JDK :
-----
JDK contains tools required to write Java Programs and JRE to execute them.Tools like Debugger,Compiler etc.
It includes Compiler,Application Launcher and AppletViewer etc.
Compiler converts the code written in Java into Byte Code.
Java Application Launcher opens JRE which loads the necessary Classes ane executes the Main Method.

JRE :
-----
JRE contains class libraries,JVM and other supporting files etc.
If we want to run any Java Program then JRE must be installed in our system.

JVM :
-----
JVM provides platform independent way of executing Java Source Code.






