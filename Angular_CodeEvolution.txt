1.Introduction														[18-FEB-2019]  (Done)										
2.Getting Started													[18-FEB-2019]  (Done)							
3.Hello World														[18-FEB-2019]  (Done)
4.Components Detail													[19-FEB-2019]  (Done)
5.Interpolation														[19-FEB-2019]  (Done)
6.Property Binding													[19-FEB-2019]  (Done)
7.Class Binding														[15-FEB-2019]  ()
8.Style Binding														[15-FEB-2019]  ()
9.Event Binding														[20-FEB-2019]  (Done)
10.Template Reference Variables										[20-FEB-2019]  (Done)
11.Two Way Binding													[20-FEB-2019]  (Done)

12.ngIf																[19-FEB-2019]  ()
13.ngSwitch															[19-FEB-2019]  ()
14.ngFor															[19-FEB-2019]  ()

15.Component Interaction											[21-FEB-2019]  (Done)

16.Pipes															[21-FEB-2019]  ()

17.Services															[21-FEB-2019]  (Done)
18.Dependency Injection												[21-FEB-2019]  (Done)
19.Using Service													[21-FEB-2019]  (Done)
20.HTTP and Observables												[21-FEB-2019]  (Done)
21.Fetch Data Using HTTP											[21-FEB-2019]  (Done)

22.HTTP Error Handling												[21-FEB-2019]  ()

23.Routing and Navigation											[06-APR-2020]  (Done)
24.Wild Card Route and Redirecting Routes							[06-APR-2020]  (Done)
25.Route Parameters													[12-APR-2020]  (Done)
26.ParamMap Observable												[12-APR-2020]  (Done)
27.Optional Route Parameters										[28-MAY-2020]  ()
28.Relative Navigation												[28-MAY-2020]  ()
29.Child Routes														[28-MAY-2020]  ()

30.Angular 6 Features												[10-MAR-2023]  ()
31.Updating App to Angular 6										[13-MAR-2023]  ()
32.Angular 8 Features                                               [13-MAR-2023]  ()


################################################### 1.Introduction	####################################################################

Angular is a JavsScript Framework and is used to build Client Side Applications.
Angular is specially used to build Single Page Applications i.e without refreshing the entire page.
Angular Provides Modular Approach and hence the Application we build has a Clear Structure.
By making use of Components which is a feature in Angular we have lot of reusability of Code.
Angular has so many features like Routing which makes the development quicker and faster.
Angular even provides support for Unit Testing.
Angular is from Google and uses MicroSoft Typescript Language.

######################################################### 2.Getting Started #########################################################

PreRequisite for Angular are basics of HTML,CSS and JavaScript.
We need to Setup the Development Environment i.e  install

	Node
	Npm
	Angular CLI
	Visual Studio Code

Install Node JS and when we Install Node,NPM (Node Package Manager will also be Installed)
Once the Node is Installed,In the Command Prompt run the Command 
	
	node -v
	npm -v
	
Install the Angular CLI i.e Command Line Interface.
Angular CLI generates the building Block of Angular Application by typing the Commands.
Angular CLI makes the development quicker and easier by following best practices.
To install Angular CLI 

	npm install -g @angular/cli
	
To Check whether the Angular CLI is installed or not,run the command

	ng - v
	
To Uninstall Angular CLI :

	npm uninstall -g @angular/cli
	npm cache clean --force
	
To Uninstall node and npm 
	
To Install Specific version of Angular 

	npm install -g @angular/cli@^8.0.0

To install the latest version of Angular 

	npm install --no-save @angular/cli@8.3.15
	ng update @angular/cli @angular/core --next
	
############################################# 3.Hello World #############################################

To create Hello World Angular Application we make use of Angular CLI.
In Visual Studio Code we have an Integrated Terminal where we can run the Commands.

	View -> Terminal -> Make sure we are inside the Angular Folder.
	
To create New Angular Project we use the Command
	
	ng new Angular

Here the above command takes time to run and once it is completed it will create the folder Angular.
Now change the Application folder to Angular

	cd Angular

To run the Application run the Command 

	ng serve

To check the Application in the Browser

	localhost:4200
	
Flow of Execution :
-------------------
Angular apps are modular in nature i.e Angular Application is a collection of many individual modules.
Every module represents the feature area in the Application and also Angular Modules are imported and exported.

	User Module 
	Admin Module
	
Every Angular Application has one Module which is the root Module & by naming convention it is App Module.
Each Module inturn consists of Components and Services.
Component controls a portion of the view in the Browser.

		(Component 1)        Navigation Bar
					
										
				
							 Main Board
		Side Bar			(Component 3)
		(Component 2)
				
Every Angular Application has one Component which is the root Component and by naming convention it is is App Component.
All other Components will be nested inside the App Component.
Each Component will have HTML Template and Class.
HTML Template to represent the view in the Browser and Class that Contains the logic of that particular view.

Modules can also have Services i.e. The class that contains the Business Logic of an Application.
In Addition to Components and Services,Module also has some more features.
Modules can be exported and imported as and when required and render the view to the Browser.

File Structure :
----------------
package.json contains the dependencies,development dependencies (which are nothing but libraries) and Modules which are required for an Angular Application to work.
Packages listed in the development dependencies are installed when we run the command

	ng new Helloworld (While Creating an Angular Application)
	
All the Packages are installed in the Node Modules.
package.json has some scripts that can be used to run the Application.
	
		ng serve
		
src Folder :
------------
In the src folder we have main.ts which is an entry Point for an Angular Application.
we also have app Folder inside src folder.
app Folder contains app.module.ts which is the Root Module for an Angular Application.
app Folder also contains app.component.ts which is the Root Component for an Angular Application.

Flow of Execution :
-------------------
When we run the below command to start an Angular Application i.e 

	ng serve 

Execution starts from main.ts i.e. main.ts bootstrap the App Module and App Module in turn bootStrap the App Component.
App Component has two things i.e HTML template to represent the view in the browser and Class that controls the logic of that particular view.

  import {Component } from '@angular/core'
  @Component({
  selector:'app-root',
  templateUrl:'./app.component.html',
  styleUrl:'./app.component.css'
  }
  )
  export class AppComponent
  {
	title ='Helloworld';
  }
  
At runtime HTML property gets replaced by Class Property.
Whenever we change the value in the Class it will automatically reflects in the Browser.

Note :
Component renders different portions of the view in the Browser.

######################################################## 4.Component Detail  ######################################################################


	Template   +  Class  + Meta Data
	
Template represents the view in the browser and is created by using HTML.
Template will be the User Interface for an Application.

Class supports the view in the Browser and is created by using TypeScript.
Class in Angular is similar to any other Programming Language Class that contains properties and methods to control the logic of the View.

Example :
We have a Class that contains a method to show or hide the element based on the value of the Property.

A Component can also have Metadata Attached to it.
This is the information that the Angular needs to decide whether particular Class is an Angular Component or Not.
Metadata is defined using Decorator Annotation and is a feature in TypeScript.

Decorator Annotation provides information about the Class Attached to it.
For Component we use Component Decorator.

Example :
---------
In the app.component.ts we have one Class named AppComponent and it Contains one data Property

	@Component({
	  selector: 'app-root',
	  templateUrl: './app.component.html',
	  styleUrls: ['./app.component.css']
	})
	export class AppComponent
	{
		title='Code Evolution';
	}

To the above class we have attached the Meta Data in the form of Component Decorator.
@Component tells the Angular that this is not the plain Class and is a Angular Component.

@Component attaches the Meta Data to the Class right below it.
Component Decorator Pattern contains both the Metadata and the class that supports the view.
As part of Metadata we have 

Selector 
TemplateUrl
StyleUrls

Selector  :
-----------
Selector is a custom HTML Tag that can be used in HTML to represent that this is an Angular Component.
When we specify the Selector in the HTML, Angular renders the Component Template in its View.

	<Body>
	<app-root></app-root>
	</Body>

But what Component is can be specified by using templateURL.
TemplateUrl points to the HTML file that represents the Component.
In app.component.html we have title and title is the Property in the Class app.component.ts.

To Create a new Component from Angular CLI we use the command

	ng g c Helloworld
	
When we run the above Command,new files will be created and it will update the App Module.
In the app Folder,Hellworld Folder has been Created and it Contains HTML,CSS,TS and spec.ts Files.
When we Create a Any Component,Angular Should aware of this i.e In the App Module import the Helloworld Component and add it to the Declarations Array.

Declaration array Contains all the Components used by the Application.
To include this Component in the HTML,Just add Custom HTML tag that represents the Selector in app.component.html.

	<app-hello-world></app-hello-world>

Changes that can be made to any of the Component are selector and templateUrl.
There are 3 ways to Specify the Selector :

1.selector:'app-test'
This can be used as a Custom HTML Tag in the HTML.
	
	<app-test></app-test>

2.selector : '.app-test'
If we begin the selector with . then this can be used as a Class Name in Custom HTML Tag.
	
	<div class="app-test"></div>
	
3.selector:'[app-test]'
We can also have the selector between the Square Brackets.
This can be used as an Attribute in custom HTML Tag.

	<div app-test></div>
	
Template :
----------
We have a TemplateUrl property that points to the HTML file that represents the Component.

Case 1 :
--------
In Any Component it is possible to specify the Template InLine i.e in the same Type Script File.
For that Purpose we use template Property.

	template : '<div>InLine Template</div>'
	
case 2: 
-------
Some Times our Inline Template might Span couple of lines and for that we make use of ` Symbol.

	template:	`
				<div>
				InLine Template
				</div>
				`
Similar is the case with Styles.

################################################### 5.Interpolation ####################################################################

Generate the Component Named Interpolation

In the Interpolation Component Use the In line Template  i.e

  @Component({
  selector: 'app-interpolation',
  template: `
  <h2>
  Welcome Interpolation
  </h2>            
  `,
  styleUrls: ['./interpolation.component.css']
  })
  
 
Change the app.component.html i.e add the interpolation Selector in app.component.html.
The Problem here is Interpolation is Dynamic.
Here Interpolation may come from Web service or Web API and value may change at any point of time.
To make the value dynamic,we create the new property in the Class.

  public name ="Interpolation by Srinivas";
  
we get the value into HTML Template by using Interpolation i.e {{}}

  Welcome {{name}}
  
By using Interpolation we are asking the Angular to evaluate the Content inside the curly braces and display the value when the Content is rendered to the Browser.

Consider the scenario {{2+2}}
Angular evaluates the expression and displays the result in the browser. i.e 4
Consider the scenario  {{"Welcome " + name}} here it performs String Concatenation.
Consider the scenario where we are using Java Script properties and methods in the curly braces.

	<h2>{{name.length}}</h2> 
	<h2>{{name.toUpperCase()}}</h2> 
	 
Apart from Built in Java Script Methods we can also use User defined methods defined in Component Class.
	
  <h2>{{greetUser()}}</h2>  
  greetUser()
  {
    return "Hello " +this.name;
  }

Drawback of Interpolation :
---------------------------

We cannot Assign expression to a Variable using Interpolation i.e  
	
	 <h2>{{a=2+2}}</h2> 

and in the Browser we get Compile Time Error saying Template Parsing Error.

Another Drawback of Interpolation is access to Global Variables like Window,Screen and so on.

	<h2>{{window.location.href}}</h2>
	
Here Template is not aware of Global Java Script Variables.
To access the Global Variable,Create the Local Variable and assign the Global Variable to it.
	public siteUrl=window.location.href;
	<h2>{{siteUrl}}</h2>

################################################### 6.Property Binding ####################################################################

Before understanding Property Binding it is important to understand the difference between HTML Attribute and DOM Property.

	@Component({
  selector: 'propertybinding',

  template: `
  <h2> welcome {{topicName}}
   <input type="text" value="Vishwas"/>
  `,
  styleUrls: ['./propertybinding.component.css']
	})

Inspect the Element in the Browser then 

$0.getAttribute('value') --> Vishwas
$0.value --> Vishwas

If I Change the Text from Vishwas to CodeEvolution in the Input element of the Browser i.e. in the Text Box

$0.getAttribute('value') --> Vishwas
$0.value --> CodeEvolution

Attribute Property won't change where as the property value changes.

Points To Remember :
--------------------
Attributes and Property both are not same.
Attributes are defined by using HTML where as Property are defined by using Document Object Model.
Attributes initialize DOM Properties and they are done and Attribute value cannot change once they are initialized.
Property value however can change.
HTML attribute value specifies the initial value.DOM value property value is the current value.
Attribute value remains the same where as DOM value will change.
With Property Binding It looks like we are binding the property to the HTML Property but actually we are binding the property of the DOM Element.

Consider the Example :
Create a Property in the Class i.e 

	public myId="TestId";
	
We need to bind this myId value to the HTML id property of the input Element.

	<input [id]="myId" type="text" value="Vishwas"/>
	
If we inspect the element id is set to TestId which is the Value of the myId Property.
We can also use Interpolation for Property Binding.

	    <input id={{myId}} type="text" value="Vishwas"/>
	
Problem with Interpolation is that it only works with String Elements.
There are some HTML properties that we may need to bind to.
Consider an Example of disabled attribute of an HTML Element and by default it is set to false.

	<input disabled id={{myId}} type="text" value="Vishwas"/>

If we make the disabled attribute to true,Then the value in the Text Box is disabled.

	  <input disabled="true" id="{{myId}}" type="text" value="vishwas">

	  <input disabled="false" id="{{myId}}" type="text" value="vishwas">
	  
Here Setting the value to false has No Effect and still the value in the Text Box is disabled.
Here the Problem is disabled attribute expects the boolean value and it is getting the String Value.
Even Interpolation does not work here.

	<input disabled="{{false}}" id="{{myId}}" type="text" value="vishwas">
	
Solution here is to use Property Binding.

	<input [disabled]="false" id="{{myId}}" type="text" value="vishwas">

Now the value in the Text Box is enabled.	
from the above use case hard coding true or false is not recommended and use the Property Variable.
Declare the variable 

	public isdisabled=false;

	<input [disabled]="isDisabled" id="{{myId}}" type="text" value="vishwas">
	
There is an Alternate Syntax for Property Binding instead of []
We can also use bind-attributeName

Example :

	 <input bind-disabled="isDisabled" id="{{myId}}" type="text" value="Srinivas">


################################################### 7.Class Binding ####################################################################



################################################### 8.Style Binding ####################################################################


################################################### 9.Event Binding ####################################################################

Till now we have seen the data flow from Component class to HTML Template.
Any update to the Class property will reflect in the HTML Template.
Sometimes to respond to the User Events like Mouse click ,Key Board Events we need the data to be flown in the other direction as well 
i.e from HTML Template to Component Class.
To capture events we use Event Binding.

	<button>Greet</button>

When the user clicks on the button we want to display Hello User in the Console.
Here we need to listen to the click event on the Button.
Events in Angular are enclosed within ()

	<button (click)="onclick()">Greet</button>
	 
	onclick()
	{
    console.log("Welcome Event Binding");
	}
	
It is also Possible to set the Properties to the Events i.e Click Events.

	Declare the Variable with default Value
	public name ="";
	 
	Define the Function 
	greet()
    {
    this.name="Srinivas Event Binding";
    }
	
	In the HTML Template 
	{{name}}
	
Some times we may also want to know the information about the event itself.
For example Information about the Click Event.
For that Simply Send the Parameter in the Event Handler. i.e $event and is a Special Variable for Angular.

	 <button (click)="greetEvent($event)">Greet</button>
	 
	greetEvent(event)
	{
		console.log(event)
	}
	
In the Console It displays all the Information About the Event.
Finally sometimes when we are working with Event Binding,separate Event Handler may not be necessary.
In the above example Method body is very Small.
We can have this as Template Statement in the HTML itself.

<button (click)="name ='Template Statement'">Greet</button> {{name}}

Event Binding Captures some event and displays the information about the Event.


################################################### 10.Template Reference Variables ###################################################

Whenever there is a user Interaction where we might want some data to be flown form view to the Class to perform some operation.
We may require a value from an input field to perform validations.
To easily access DOM elements and their properties Angular provides Template Reference Variables.
  
Consider the Scenario	

  <input type="text">
  <button>Template Reference Variable</button> 	
  
Here whatever the User enters we need to display it into the Console.
For that we need to bind the click event to the button.
Declare the event for click and pass the value that user has entered.
The way we pass the user entered Text is by using Template Reference Variables.

	<input #userInput type="text">
	
	<button (click)="logMessage(userInput.value)">Log</button> {{input}}

	public logMessage(value)
	{
    this.input=value;
	}

Case : When we pass only userInput then input Element is Passed.

################################################### 11.Two Way Binding ####################################################################

When ever we want to work with Angular Forms,Model and View are in sync.otherwise data might not be consistent.
Consider the case where
View has User name and Password.
Class has User name and Password.

Whenever user updates input text,Model and Property should automatically receive those values.
Similarly when there is an update in the Model or Property value,View Should automatically reflect the updated value.
This can be achieved by using Two Way Binding.
Two Way Binding allows us to update the property and at the Same Time displays the value of the property.
We can achieve two way Binding by using ngModel directive.

	<input type="text">
	{{name}}
	
	public name="";
	
Here Whenever user enters Some Text in the Text Box,automatically it has to be displayed in the Browser.
From the above code it does not work and we need to use ngModel Directive.
Angular is not aware of ngModel directive because it is in separate module called Forms Module.


Add Forms Module in app.module.ts 

	import { FormsModule} from '@angular/forms'

and add it to the imports Array 
	
	FormsModule

	<input [(ngModel)]="name" type="text"> {{name}}
	

################################################### 12.ngIf #####################################################################################

Structural Directives can be used to add or remove HTML Elements from the DOM.
3 common built in structural directives are 

	ngIf
	ngSwitch
	ngFor
	
ngIf and ngSwitch can be Used to Conditionally render the HTML Elements.
ngFor is used to render the List of Elements.





################################################### 13.ngSwitch ####################################################################################



################################################### 14.ngFor #####################################################################################


################################################### 15.Component Interaction ####################################################################

From the last few examples we are working on some Components and that Component are nested inside App Component.
Here App Component is the Parent Component and the other Component is the Child Component.
Some times we may get a requirement that two Components needs to interact with each Other.
Parent Component might send some data to the Child Component similarly Child Component might send some data to the Parent Component.
Here Components interact with each other using @Input and @Output Decorator.
Using @Input Decorator Child Component will accept the input from the Parent Component.
Similarly using @Output Decorator Parent Component will accept the data from the Child Component.
Using @Output Decorator Child Component will send some events to the Parent Component to indicate Something.

Consider the Scenario :

Case 1 :
--------
Parent Component sends some data to the Child Component i.e name  and in the Child Component display the name Send by the Parent Component.
To Send the Data from Parent Component to Child Component i.e app Component to parentchild Component.

Create Variable in the app Component i.e 
	
		public name="Srinivas Sankoji";

In the app.component.html where we bind the Child Component i.e 
where we include the Child Component Selector in the Parent Component HTML.


	 <parentchild [parentData]="name"></parentchild>
	 
Now declare the same Variable in the Child Component that we have declared in the Parent Component.

Here In the Child Component we need to provide information about the variable that it is not a normal variable and we are receiving it from the Parent Property.
This can be done by using @Input Decorator in the ts file.

		 @Input() public parentData;
		 
		 <div>
		 <h2>{{"Hello "+parentData}}</h2>
		 </div>
	
Some times we have a requirement of using different name which is coming from Parent Component.
In this case we use alias Name of @Input Decorator.

		 @Input('parentData') public name;

Case 2: 
-------
Child Component sending  some data to Parent Component.

In Case of Parent to Child Component,Parent Component HTML will have the Child Component selector so that we can easily bind the Parent Component data to the Child Component.
Where as in the Child Component HTML we don't have any Parent Component Selector.
The way a Child Component sends the data to the Parent Component is by using Events.

Create an Event by using EventEmitter Class so that we can send an Event to the Parent.

	 public childEvent= new EventEmitter(); 
	 
To send the Child Component data to the Parent Component we use @Output Decorator.

	@Output() public childEvent= new EventEmitter();

Now we have added an Event and fire this event on button click.

	<button (click)="sendEvent()">Send Event</button>
	
	sendEvent()
	{
		this.childEvent.emit("Hi Parent From Child");
	}

Now the Event is emitted from the Child Component.
We need to capture in the Parent Component.

	<parentchild (childEvent)="message=$event" [parentData]="name"></parentchild>

Also declare the variable in the Parent Component i.e public message="";


################################################### 16.Pipes #####################################################################################

Pipes allow us to transform the data before displaying it to the View.





################################################### 17.Services #####################################################################################

Lets Create a Employee List Component and Employee Detail Component and include it in the app.component.html.
In Employee List Component we have an Array of Employees.
	
	public employees=[
    {"id":22,"name":"srinivas","salary":22000.00},
    {"id":27,"name":"Nandini","salary":27000.00},
    {"id":23,"name":"Bhaumik","salary":23000.00}
  ]

In the Employee List Component to render the Name of Employees  

	<ul *ngFor ="let employee of employees" >
      <li>{{employee.name}}</li>
    </ul>
	
To get the Employee name in the Employee Detail Component again we have to write the same code.
Here we are violating the principle of DRY i.e Do Not Repeat Your Self and Single Responsibility Principle.
Here Component Class should have only one responsibility i.e To control the view Logic.
In Our case it is also responsible for creating an Employee Array  i.e. both in Employee List and Employee Detail Component.

The solution is service and advantage of Services are 
A Class with specific service
To share the data across multiple Components
To implement Business Logic
To connect with Database.

We can implement services by using Dependency Injection.

################################################### 18.Dependency Injection ####################################################################

Dependency Injection can be implemented in 3 Ways

1.Code without DI and its drawbacks
2.DI as Design Pattern
3.DI as Framework

1.Code Without DI and its drawbacks :
-------------------------------------

	Class Engine 
	{
		constructor(parameter)
	}
	
	Class Tyre
	{
		constructor(parameter)
	}
	
	Class Car 
	{
		Engine;
		Tyree;
		constructor()
		{
			this.Engine=new Engine();
			this.Tyree=new Tyree();
		}
	}

To create an Object of Car we need to pass the parameter of type Engine.	
The problem with this approach is If the Engine has extra parameters then we cannot create the Object of Car .
Similar is the case with Tyre.
Here the code is not flexible because If dependencies has changed dependent has to be changed.
Also we get the same kind of Object every time.

2.DI as a Design Pattern :
--------------------------
In case of Dependency Injection as Design Pattern a class receives its dependencies from external resources rather than craeting itself.

	Class Car 
	{
		Engine;
		Tyree;
		constructor(Engine engine,Tyree tyree)
		{
			this.Engine=engine;
			this.Tyree=tyree;
		}
	}
	
Problem with Dependency Injection as a Design Pattern is as a Developer we have to manually create the Dependency and Dependent Objects.
If the number of Objects increases,Maintenance will be difficult for the Developer.
Solution is DI as a Framework.

3.DI as Framework :
-------------------
Dependency Injection as a Framework has something called Injector which registers all the dependencies.
Injector acts like a Container for all the dependencies.
Injector manages all the dependencies and makes the developer job more Simple.

If the Component depends on number of Services,we register all the Services with Injector.
When the Component is initialized all the dependencies will be initialized automatically.

Create Employee Service Class
Register with Injector
Declare as a dependency in Employee List and Employee Detail Component.

################################################### 19.Using Service ###########################################################################

Define Employee Service 

Step 1 :
To generate the Service run the Command 

	ng g s employee

	@Injectable({
	  providedIn: 'root'
	})
	export class EmployeeService 
	{
	  constructor() { }
	}
	
This Service is Responsible to Provide Employee Data.

	 getEmployees()
	{
    return
      [
      {"id":22,"name":"srinivas","salary":22000.00},
      {"id":27,"name":"Nandini","salary":27000.00},
      {"id":23,"name":"Bhaumik","salary":23000.00}
      ]
	}
	
To use this Service in the Component Declare as an Array i.e 

	public employees =[];
	
Step 2 :
Now Register the Service with Angular.
If we don't register the Service,then service is like regular Class in Angular.
There are multiple places where we can register the Service and is important because Angular has hierarchical Dependency Injection System.

If we register in Employee List Component then it is applicable to Employee List Component and its Dependent Components.
If we register in App Component it is applicable to its dependent Components and not applicable for other Modules.
Here each Module is a feature area in our Application.It is better to register the Service in app Module.

If we register the Service in App Module,Components under the App Module can use the Service.
To register the Service we use the Providers Metadata.
Add the Service to the Providers Metadata.
	
	 providers: [EmployeeService]
	
import the Employee Service 
	
	import {EmployeeService} from './employee.service';

Step 3:
Declare as dependency in the Employee List and Employee Detail Component.
Dependency is specified in the Constructor.

	constructor(private _employeeservice: EmployeeService) 
	{ 
	}
	
and we are going to use EmployeeService in ngOnInit().
It is a Life Cycle Method and will be Called when Component has been initialized.

	 ngOnInit() {
    this.employees=this._employeeservice.getEmployees();
	}
	
@Injectable Decorator :
-----------------------
Injectable tells Angular that this Service might itself has Injected Dependencies.
So If we want to inject service into another Service Injectable Decorator is must.

Right now Employee Service does not have any dependencies and Injectable Decorator is not Necessary.
But Employee Service might have Dependencies in the future and in that Case Injector is Mandatory.
It is recommended to add Injectable Decorator as soon as when we create the Service.

Here we are not using Injectable Decorator in Employee List and Employee Detail Classes and these Class still makes use of Employee Service.
This is because of Component Decorator and it tells Angular that It may or may not Use Dependency Injection System.
But for Service We don't have Component Decorator.
If we remove Injectable then the Service becomes plain typescript Class.
Injectable is required only for Service and not for Component.


################################################### 20.HTTP and Observables ####################################################################

In real world Application we need to fetch the data from the Web Server / Web Service.
We make a HTTP request to the API.The response we get from the HTTP is Observable.

Here Employee Service makes an HTTP Request to the API and we get the Observable as Response.
We need to cast an Observable into an Array of Employees and return the same to the Component.

Observable is nothing but a sequence of items that arrive asynchronously over time.
But from the HTTP call we get the single item instead of sequence of items.
Here Single item is nothing but HTTP Response.

An Observable is nothing but an HTTP Response that arrives asynchronously.
Observable is not in format that we can use it readily in our Application.
Once we receive the Observable we need to convert into an Employee Array.
After Conversion the data is ready to provide for the Component.
We only provide the data for the Component that subscribes the Service.

################################################### 21.Fetch Data Using HTTP ####################################################################

Steps to fetch the data Using HTTP 

1.Get request from Employee Service
2.Receive the Observable and cast it into Employee Array
3.Subscribe to the Observable from the Component
4.Assign the Employee to the Local Variable

Step 1:
-------
Till Angular 4 we are using HTTP Module but from Angular 5 we are using HTTPClient Module.
In the App Module add the HTTP Client Module and it to the import Statement
By importing HTTP Client module we are also registering the HTTP Service with Angular Injector.

Here we don't have Web Service now.Lets create a new Folder named Data inside assets and add the Employee JSON.
We call the data from this file instead of actual service.

To use the HTTP Service in the Employee Service,declare as a dependency in the Employee Service Constructor.

	constructor(private http:HttpClient) { }
	
	 getEmployees()
	{
    return this.http.get(this.url);
	}
	
Step 2:
-------	
Here get() returns an Observable and for our Application Observable needs to be cast into format that represents an Employee Array.
For that we need to create an Employee Interface.
In the App Folder create a new File employee.ts and then add the code for an Employee Interface.	
	
	app -> employee.ts
	
	export interface IEmployee
	{
    id:number,
    name:string,
    salary:number
	}
	
Then in the Service Change the return type of Service.

	  private url="/assets/data/employee.json";

	 getEmployees():Observable<IEmployee[]>
	{
		return this.http.get(`${this.url}`);
	}
	
Step 3 :
--------
Subscribe the Observable from the Component and assign them to a local variable.

	public employees=[];
	
	constructor(private employeeservice:EmployeeService) { }

	ngOnInit(): void {
     this.employees=this._employeeservice.getEmployees().subscribe( (data: any) => this.employees =data);
	}

################################################### 22.HTTP Error Handling ####################################################################

As we know that Observable returns an HTTP Response and we need to handle the error returned by the Observable.
Here we make use of Catch Operator.

We need to import catch Operator and catch Operator takes Method as an Argument.

	import 'rxjs/add/operator/catch';
	

################################################### 23.Routing and Navigation ####################################################################

Any Angular Application we build have Multiple Componenets and each Component has its own View.
We need to navigate between these Components as and when user performs the action.
Here we make use of Angular Router.

Consider the Scenario where we need to navigate between two different views based on Button Click.

		Departmet Employee
		
If we Click on Department it has to Show Department List 
similarly If we Click on Employee List it has to Show Employee List.

Steps for the above Requirement are 
1.Generate the Project with Routing Options using Angular CLI.
2.Generate the Department List and Employee List Component.
3.Configure the Routes i.e allows us to navigate the Routes from the URL.
4.Add Buttons and use directives to navigate to the Configured Routes.

we might not generate the project always with Routing Option and we may want to add the Routing to an existing application as well.
If we want what the Routing Application does then Replicate the Same code in the Existing Application.

Step 1: 
include the base tag in the index.html

	<base href="/">
	
This is Required because the Application knows how to construct the url while Navigating.

Step 2 :
In the App Folder create the File 

	app-routing.module.ts
	
This is the File were we configure the Different Routes.

Step 3 :
import app-routing.module.ts in the app module and add it to the Declarations Array.

Step 4 :
Generate the Department and Employee List Component that we will be navigating to.

Step 5 :
Configure the Routes and that we will do in the app-routing.module.ts

	const routes : Routes = [];
	
Here routes is Strongly typed to the Route from the Router Package.
Here we define all Possible Routes for our Application and each Route is nothing but an Object.
Object contains a Path which is reflected in the URL and Component that has to be Rendered when we are Navigating to the Corresponding URL.


	const : routes : Routes = [
	{ path:'departements',component:Department-component},
	{path:'employees',component:Employee-component}
	];

But by doing so we are duplicating the import statement in the app module and app-routing Module.
Possible Solution is to create an Array of all Routing Components in app-routing module and  import it in the app module.
In app-routing module 

	export const routingComponents =[Department-component,Employee-component];
	
and in app-module import it.
remove the Routing in the declarations Array and any time if we want to add the Routing Components then add it to  the app-routing .module.ts

In the app-component.html we have 

	<router-outlet></router-outlet>
	
Here we are Specifying where the components have to be displayed using router outlet Directive.
Finally Add the Buttons to Navigate from one Component to another Component in app.component.html

	<nav>
	<a>Department</a>
	<a>Employee</a>
	</nav>
	
To Make Router Possible for these Anchor Tags we use two Special Directives from the Router Package.

	<nav>
	   <a  routerLink='/departmentlist'>Departmet</a><br>
	   <a  routerLink='/employees'>Employee</a>
	</nav>

routerLink Directive Specifies the Path where we want to navigate to.
routerLinkActive Specifies one or more css Classes that will be applied to the Component when corresponding Router Link is Active.	
 

###########################################  24.Wild Card Route ################################################################################

So far we Have Created 2 Routes in Our Application. i.e Departments and Employees.
The Problem is User tries to Navigate to the Route and is Not Configured then the Application throws an Error.

  localhost:4200/test and in the Console we get "Cannot Match Any Route"
  
Better Way to Handle Invalid URL is by using Wild Card Route.
By Making use of Wild Card Routes we can Navigate the User to the Page Not Found Component for Invalid URL's.

Wild Card Route should be the Last Route in the Configuration in the app-routing.module .
Here Router Tries to Match the Pattern from the Top then add the pagenotfound componenet at the bottom.

 {path:"**",component:PagenotfoundComponent}
 
Add it to the List of Routing Components.
The Problem with Wild Card Route is that Once We Configure the Wild Card Route then By Default localhost:4200 will Navigate to 
Page Not Found Component.
This is Because URL is Not Matched to Any of the Configured Routes 
and as a Result Router falls through Wild Card Route and Displays Page Not Found Component.

Here Requirement is our Application Needs Default Route.
In Case of Empty Path Redirect to Another Route i.e 

		{path:'',component:DepartmentlistComponent}
  
Redirection can also be done by Using redirectTo Attribute along with pathMatch parameter with Value "prefix" or "Full".
Path Match Attribute tells the Router that how to Match the URL Segment with the Configured Routes.
If the Path is the Prefix of the URL then Redirect to the Departments i.e path:''
pathMatch parameter with Value "prefix" will not Work because any URL will be Empty by Default.

		{path:'',redirectTo :'/departments',pathMatch:'prefix'}

Here it always redirect to the DepartmentList Component.
pathMatch Parameter with Full URL will Work.

		{path:'',redirectTo :'/departments',pathMatch:'full'}
		
i.e redirect only if the Full URL is Empty.


################################################### 25.Route Parameters #######################################################################

In the Department Component we have list of Departments i.e 

	Angular 
	Node
	MongoDB
	Ruby
	Bootstrap
	
If we Click on Department navigate to the DepartmentDetail Component by passing id of the Department as Route Parameter.
In the DepartmentDetail Component we will read the id Parameter and display the id in the Department Detail Component.
If we Click on Angular then in the DepartmentDetail Component Display "Selected Department with id 1"
To achieve the above add the code in the DepartmentList Component.

	departments = [
    {"id":"1","name":"Angular"},
    {"id":"2","name":"Node"},
    {"id":"3","name":"MongoDB"},
    {"id":"4","name":"Ruby"},
    {"id":"5","name":"Bootstrap"}
  ];
 
Iterate the Department List in the Template.

  <ul class="items">
  <li *ngFor="let department of departments">
  <span class="badge">{{department.id}}</span>{{department.name}}
  </li>
  </ul>

Now the requirement is when we click on Angular,URL should change to departments/1 and should be redirected to DepartmentDetailComponent View 
with the Messae "Selected Department with id 1".
Generate the DepartmentDetail Component ,add it to the app-routing.module const and Configure the Route i.e 

	 {path:'departments/:id',component:DepartmentDetailComponent},

Here :id is a place Holder for a Route Parameter

Next Step is to Navigate to the Route when we Click on the Department.
In the DepartmentList Component bind the Click event on Each Department.

	<li (click)=onSelect(department) *ngFor="let department of departments">
	
From the onSelect Method Navigate to the New Route.
To Navigate from Code we make use of Routers Service i.e import Router from angular/route and Inject in to the Constructor.
Argument to the navigate Method is Link Parameter Array and it needs all the Information to COnstruct the URL.
The Path we want to navigate to and the other one is Route Parameter.

	onSelect(department)
	{
      this.router.navigate(['/departments',department.id]);
	}
	
Now we are able pass the Parameter to the URL.
The other part is to read the Parameter and Display the Parameter.
For this we make use of activated Route Service.
impprt and Inject it to the Constructor in Department Detail Component.
Then in the ngOnInt() of Department Detail Component,we read the Route Parameter.
Here activatedRoute gives the snapShot of the Current Route.
From the SnapShot we use paramMap API which helps us to read the parameter of the URL.

	 ngOnInit(): void {
    let id=parseInt(this.activatedRoute.snapshot.paramMap.get('id'));
	}


################################################### 26.ParamMap Observable ####################################################################

To Read the Route Parameter we used the snapshot of the activatedRoute.

	let id=parseInt(this.activatedRoute.snapshot.paramMap.get('id'));

But this Sceanrio has one drawback.
Here we are navigating from from DepartmentList Component to DepartmentDetails Component  
Consider the Scenario where we add the Previous and Next Button in the DepartmentDetail Component.
When we click on Next it has to go back to the Next Department and if we click on Previous it has to go to the Previous Department.

  template:`
  <h3>Selected Department is {{departmentId}}<h3>
  <a>Previous</a>
  <a>Next</a>
  `
  
To Navigate from Previous and Next we make use of Router Component.

	 constructor(private activatedRoute:ActivatedRoute,private router:Router) 
	 { 

	 }
To get the previosId ,Get the departmentId using snapShot of the ParamMap and subtract with 1.
Once we have a previousId, we pass it as the parameter to the navigate method of Router Service.

	public goPrevious()
	{
      let previousId=this.departmentId-1;
      this.router.navigate(['/departmentdetail',previousId]);
	}
Similar is the Case with NextId.
	 
Here the Problem is in the URL id Value is Updated and in the View it is not Updated.
This is the drawback of snapshot Approach.
whenever we are navingating from one Component to another Component and  back to the same Component snapshot approach will not work.
Angular is going to figure out whether it needs to initalize the new Component or reuse the same Component.
When we are navigating back to the Same Component Angular re uses the same Component 
and it does not apply the initialization i.e ngOnInit() is not called Here.

Possible Solution is to use paramMap Observable.
paramMap returns an Observable and we get the data only when we subscribe.
argument to the subscribe() is an arrow Fucntion.
Observable provides the paramMap which we Strongly type to the params.

	ngOnInit(): void {
    this.activatedRoute.paramMap.subscribe((params :ParamMap) => {
      let id=parseInt(params.get('id'));
      this.departmentId=id;
    });
  }

Here Any Time parameter Value Changes even when navigating back to the Same Component,ParamMap Observable can detect and read It.


################################################### 27.Optional Route Parameters ##############################################################

In the Department Detail Component we need to add the Back Button and when we Click on the Back Button,Previously Selected Department has to be highlighted.
This can be achieved by Using Optional Route Parameter.
Here we need to assign the Handler on the Button Click.

	<div>
		<button (clcik)="goToDepartment()"></button>
	</div>
	
Now capture the DepartmentId and store inside the variable SelectedId.
Then SelectedId becomes currentdepartmentId.
once we have selectedId we can Navigate back to the DepartmentList View by Passing it as an Optional Parameter to the Link Parameter Array.

	public goToDepartment()
    {
    let selectedId = this.departmentId ? this.departmentId : null;
    this.router.navigate(['/departments', {id:selectedId}]);
    }
	
When we click on Back Button the Parameter will be passed to the URL as an Optional Parameter.
It is Optional because its existence does not effect the View.
Optional Parameter can be used to apply some Logic to the View.
Here we are going to read the id Parameter and compare with the List of Departments and if the Id Matches then we Highlight the Department.

In the DepartmentList Component read the id Parameter.
To read the route paramtere we need to import the ActivatedRoute and Inject it in the DepartmentList Componenet.
Then in the ngOnInit() we are going to retreive the id Parameter by Using paramMap Observable.
	
	ngOnInit(): void {
    this.activatedRoute.paramMap.subscribe((params:ParamMap) => {
      let id=parseInt(params.get('id'));
      this.selectedId=id;
    });
  }
  
Now Compare the selectedId with the DepartmentId and if it Matches then Highlight the Department.

	isSelected(department)
	{
		return department===this.selectedId;
	}
	
Optional Parameter does not require a place Holder like any Other Parameter.
We can also pass Multiple Parameters to the Optional Parameter.


################################################### 28.Relative Navigation ####################################################################

So Far we have used absolute paths for Navigation and can be Identified by Using /.
In the Department List Component we are using /departments to navigate to the DepartmentDetail Component.
And in the DepartmentDetail Component we used /departments to navigate back to the DepartmentList Component.
When we use absolute path,then there will be a lack of Flexibility using Routes.
If we want to change the URL in the route Module we need to change it in the app-routing.module.ts and its affected Components.
To add little more Flexibility to the Routing Module we use Relative Navigation.

Here we will add Link Parameter Array with two arguments.
parameter and the relativeTo i.e to the Current path Add the Parameter.

	this.router.navigate([department.id],{relativeTo:this.activatedRoute});


################################################### 29.Child Routes ###########################################################################

In an Angular Application Some Routes may only be viewed within other Routes.
In such Scenario we create Child Routes.
Consider the Scenario In the Department Detail Component We want to show only overview and contact info.
overview and  contact info are Features of each Department and these should be viewable only when we navigate to the Department Detail Component.
This can be achieved by Using Child Routes.

Generate the Two Components ie Contact Info Component and Overview Component.




################################################### 30.Angular 6 Features ####################################################################


  












 