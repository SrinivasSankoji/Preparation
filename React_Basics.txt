1.Introduction														(Code Evolution)   			[02-NOV-2023]  (Done)
2.Hello world                                                       (Code Evolution)   			[05-NOV-2023]  (Done)
3.Folder Structure                                                  (Code Evolution)   			[05-NOV-2023]  ()
4.Components                                                        (Code Evolution)   			[09-NOV-2023]  (Done)
5.Functional Components                                             (Code Evolution)   			[09-NOV-2023]  (Done)
6.Class Components                                                  (Code Evolution)   			[10-NOV-2023]  (Done)
7.Hooks update                                                      (Code Evolution)   			[10-NOV-2023]  ()
8.React JSX                                                         (Code Evolution)   			[10-NOV-2023]  (Done)
9.Props                                                             (Code Evolution)   			[10-NOV-2023]  (Done)
10.State                                                            (Code Evolution)   			[10-NOV-2023]  (Done)
11.setState                                                         (Code Evolution)   			[12-NOV-2023]  (Done)
12.Destructuring Props and State                                    (Code Evolution)   			[12-NOV-2023]  (Done)
13.Event Handling                                                   (Code Evolution)   			[12-NOV-2023]  (Done)
14.Binding Event Handlers                                           (Code Evolution)   			[14-NOV-2023]  (Done)
15.Methods as Props                                                 (Code Evolution)   			[14-NOV-2023]  (Done)
16.Conditional Rendering                                            (Code Evolution)   			[18-NOV-2023]  (Done)
17.List Rendering                                                   (Code Evolution)   			[18-NOV-2023]  (Done)
18.Lists and Keys                                                   (Code Evolution)   			[18-NOV-2023]  (Done)
19.Index as Key Anti Pattern                                        (Code Evolution)   			[18-NOV-2023]  ()
20.Styling and CSS Basics                                           (Code Evolution)   			[18-NOV-2023]  ()
21.Basics of Form Handling                                          (Code Evolution)   			[19-NOV-2023]  (Done)
22.Component Life Cycle Methods                                     (Code Evolution)   			[19-NOV-2023]  (Done)
23.Component Mounting Lifecycle Methods                             (Code Evolution)   			[21-NOV-2023]  (Done)
24.Component Updating Lifecycle Methods                             (Code Evolution)   			[23-NOV-2023]  (Done)
25.Fragments                                                        (Code Evolution)   			[23-NOV-2023]  (Done)
26.Pure Components                                                  (Code Evolution)   			[23-NOV-2023]  (Done)
27.Memo                                                             (Code Evolution)   			[23-NOV-2023]  (Done)

28.Refs                                                             (Code Evolution)   			[23-NOV-2023]  (Done)
29.Refs with Class Components                                       (Code Evolution)   			[25-NOV-2023]  (Done)
30.Forwarding Refs                                                  (Code Evolution)   			[25-NOV-2023]  ()
31.Portals                                                          (Code Evolution)   			[25-NOV-2023]  ()
32.Error Boundary                                                   (Code Evolution)   			[25-NOV-2023]  ()

33.Higher Order Components Part 1                                   (Code Evolution)   			[25-NOV-2023]  (Done)
34.Higher Order Components Part 2                                   (Code Evolution)   			[25-NOV-2023]  (Done)
35.Higher Order Components Part 3                                   (Code Evolution)   			[25-NOV-2023]  (Done)

36.Render Props Part 1                                              (Code Evolution)   			[25-NOV-2023]  (Done)
37.Render Props Part 2                                              (Code Evolution)   			[26-NOV-2023]  (Done)

38.Context Part 1                                                   (Code Evolution)   			[25-NOV-2023]  (Done)
39.Context Part 2                                                   (Code Evolution)   			[26-NOV-2023]  (Done)
40.Context Part 3                                                   (Code Evolution)   			[26-NOV-2023]  (Done)

41.HTTP and React                                                   (Code Evolution)   			[25-NOV-2023]  (Done)
42.GET Request                                                      (Code Evolution)   			[26-NOV-2023]  (Done)
43.POST Request                                                     (Code Evolution)   			[26-NOV-2023]  ()

########################################################### 1.Introduction	####################################################

1.React is a project created and maintained by Facebook.
2.React is an open source JavaScript library which is responsible only for building rich user interface.
3.React is not a JavaScript Framework.
4.React does not focus on other aspects of the Application like Routing,HTTP request etc.

5.React has component based Architecture.
This breaks down the Application into smaller encapsulated components which can be reused.

6.React is declarative i.e. we tell React what we want and React will build the actual UI.
React will make the developer life easy to create a Complex UI's by abstracting the difficulties.

7.React will handle the Component updating and rendering efficiently whenever the data changes.
DOM updates is one of the most expensive operation which is handled gracefully in React.

Prerequsites :
--------------
HTML,CSS and JavaScript.
ES6 features like this,filter,map and reduce.
let,const,Arrow functions,Template literals,Default Parameters,Object literals,Rest and Spread operators and destructing Assignment.

The other parts of React are

React Fundementals (Current Series)
React HTTP
Routing
State Management with Redux
Utilities

########################################################### 2.Hello world ###########################################################

To create a React Application we will be using Create React App.
Create React App is a CLI that allows us to quickly create and run React Application with no configuration.
Simply run the command and entire React Application will be created.

	npx create-react-app hello-world
	
npx is an npm package runner which gets installed when we install node.
That is the reason we directly create and run React without installing node modules.
To run the React Application

	npm start
	
Here the Application will start with the port number 3000.

Alternate approach for creating React Application :
---------------------------------------------------

In this approach we install the Create React App globally and then use the Package to generate the Projects.

	npm install create-react-app -g // Creating React App globally
	create-react-app hello-world // Create the Project
	

########################################################### 3.Folder Structure ###########################################################

At the root level we have 3 Folders and 4 Files.

package.json contains the dependencies and the scripts required for an Application.

Ther is a folder called node_modules where all the dependencies are installed.
It will generated when we run the create-react-app command or when we run npm install.

In the public folder we have index.html file.
This is the only HTML file we are going to have in a React Application.
The view might dynamically change in the Browser but it is the index.html we get displayed in the Browser.
Typically we are not going to add any code in the index.html file because we want React to control the UI.
For that purpose we have on <div> with id="root" i.e.

	<div id="root"></div>
	
As a Developer we will be working in the src folder during Development.
Starting point for React Application is index.js.
In index.js we specify the Root component i.e. App Component and DOM Element which will be controled by React.




	





########################################################### 4.Components #################################################################

In React Component represnts the part of the user interface.
The parent component is the App Component which contains all the components.
Components are reusable.

A Component code is placed inside Javascript file.
For example App Component is placed inside App.js.
We can also have components placed with .jsx extension.

In React we have two types of Components.

1.Functional Component (Stateless)
2.Class Component      (Stateful)

Functional Components are literally JavaScript Functions.
They return the HTML which describes the UI.

Example :
---------

	import React from 'react';

	function functionlComponent(){
			return <h1>Functional Component Example</h1>;
	}

	export default functionlComponent;
	
	import './App.css';
	import FunctionalComponent from './Components/FunctionalComponent';

	function App() {
	  return (
		<div className="App">
		  <FunctionalComponent></FunctionalComponent>
		</div>
	  );
	}

	export default App;

Class Components on the other hand are regular ES6 classes that extends Componnet Class from React Library.
They must contain render() which intern returns HTML.

Example :
---------

	import React from "react";
	import { Component } from "react";

	class Welcome extends Component {
		render(){
			return <h1>Class Component</h1>;
		};

	}
	export default Welcome;
	
	import './App.css';
	import  Welcome from './Components/Welcome';


	function App() {
	  return (
		<div className="App">
		  <Welcome></Welcome>
		</div>
	  );
	}

	export default App;


########################################################### 5.Functional Components ######################################################

Functional Components are nothing but JavaScript Functions which will optionally recieve Object of properties i.e. props 
and will return an HTML which will describe the UI.
Here HTML Component is nothing but JSX.

Scenario 1 :
------------

	import './App.css';
	import FunctionalComponent from './Components/FunctionalComponent';

	function App() {
	  return (
		<div className="App">
		  <FunctionalComponent></FunctionalComponent>
		</div>
	  );
	}
	
Here our Functional Component is no where connected to React.
For that we need to export and import the Component.

Scenario 2 :
------------
We can also define the Functional Components using Arrow Functions.

	const functionlComponent1 = () => <h1>Functional Component Example Two</h1>;

Note1 :
-------
From the above scenario we are exporting the Component with default Component.
In this case we can import the Componnet with any name.

	export const FunctionlComponent1 = () => <h1>Functional Component Example Two</h1>;

We can also have the named export.
In this case we need to use the same name while importing the Functional Component.

	import './App.css';
	import { FunctionlComponent1 } from './Components/FunctionalComponent';

	function App() {
	  return (
		<div className="App">
		  <FunctionlComponent1/>
		</div>
	  );
	}

	export default App;
	
Note2 :
-------
For most of the cases we will be using default export.

########################################################### 6.Class Components ###########################################################

Class Componnets are basically ES6 Classes.
Similar to Functional Componnet,Class Component optionally recieves props as an input and returns an HTML which describes the UI.
Class Component can maintain its private internal state and uses that information to describe the user interface.

Whenever we are creating Class Component we need to import two Components 
1.React
2.Component

For the Class to become React Component It should extend Component Class and override the render().
render() should return either HTML or null.

	import React from "react";
	import { Component } from "react";

	class Welcome extends Component {
		render(){
			return <h1>Class Component</h1>;
		};

	}

	export default Welcome;

	import './App.css';
	import  Welcome from './Components/Welcome';


	function App() {
	  return (
		<div className="App">
		  <Welcome></Welcome>
		</div>
	  );
	}

	export default App;
	
Difference between Functional Components and Class Components :
---------------------------------------------------------------
Functional Componnets are JavaScript functions which optionally recieves props and returns the HTML.
Use Functional Components as much as possible.
Always prefer Functional Components.
Absence of this keyword in Functional Component.
If we are using Functional Component we will be forced to think about the solution without having a state.
If we have number of Components each having its own state maintainance and debugging the Application is bit difficult.
Functional Components are intended to be without any complicated logic and are mainly responsible for the user interface.
This is the reason Functional Components are Stateless/Dumb/Presentational Components.

Class Components are more feature rich.
Class Components can maintain their own private data i.e. state.
Class Components can contain complex UI logic.
Class Components provide life cycle hooks.
This is the reason Class Components are Stateful/Smart/Container Components.

Note :
------
In Functional/Class Component we are simply returning HTML.
Here we are not returning regular HTML but we are returning JSX.

########################################################### 7.Hooks update ###############################################################


########################################################### 8.React JSX  #################################################################

JavaScript Xml (JSX) is an extension to JavaScript language syntax.
With React library we can write the XML like code for Elements and Components.
Just like XML,JSX tags can have tag name,attributes and children.

JSX is not a necessity to write React Application.
We can definitely write React Application without JSX.
But JSX makes React code simpler and elegant.
JSX ultimately transpiles to pure JavaScript which is understood by the Browser.

How JSX works :
---------------
Create the Component using JSX.

	const Hello = () => {
    return <h1>Hello Srinivas</h1>;
	}

	export default Hello;
	
We can also create the Component without using JSX.
React library provides CreateElement() method to create a Component without using JSX.
CreateElement() accepts 3 parameters.

1.First parameter is the String which specifies the HTML element to be rendered.
2.Second parameter is the optional parameter.It is an Object with key value pair which can be applied to the element.
3.Third parameter is the children for the HTML element.

	const Hello = () => {
    return React.createElement('div',{id:'hello',className:'dummy'},React.createElement('h1',null,'Welcome Srinivas'));
	}
	
Here each JSX Element is syntactically replacement of React.createElement which inturn uses React Library.
That is the reason we are importing React library whenever we are using JSX.
                  
########################################################### 9.Props  #####################################################################

Props is an optional input to the Component which makes the Component dynamic.
Requirement here is to pass the name from App Component to the Greet Componnet and render that name in the Browser.

	import React from "react";

	const Greet = (props) => {
		   return(
			<div>
				<h1>Welcome {props.name} and occupation is {props.occupation}</h1>
				{props.children}
			</div>
			)
	}

	export default Greet;
	
	function App() {
	  return (
		<div className="App">
		   <Greet name='Srinivas' occupation='Software'>
			<p> Parent </p>
		  </Greet>
		  <Greet name='Nandini' occupation='Housewife' ></Greet>
		  <Greet name='Bhaumik' occupation='First' ></Greet>
		  <Greet name='Aadvik' occupation='Nursery' ></Greet>
		</div>
	  );
	}

	export default App;
	
Note :
------
If no values are assigned then {props.children} will not display anything.
Irrespective of the Components properties are mentioned as attributes.
Props are Immutable and its value cannot be canged.
                         
########################################################### 10.State  ####################################################################                        

Every React Component returns JSX which describes the UI.
The way to influence what is rendered into the screen is by using props.
The second way to influence what is rendered in the screen is by using state.
Both props and state holds the information which influences the UI.

props :
props are passed to the Component.
props can be used as Function parameters.
props are Immutable because variables are passed down from Parent Component to child Component.

state :
State is managed within the Component.
State variables are declared in the function body.
State can be changed because Component has full control of it.

Create the Component named Message.js.
Here the requirement is need to have subscribe button.
Whenever we click on subscribe button it should display the message Thank you for subscribing.
Here we cannot use props because these are immutable.
The solution is to use the state Object.

Steps to create state Object.
1.Create the class constructor.
2.create the state Object with the message.
3.Create the Subscribe button and perform onClick
4.Change the state on Button Click.

	import React from "react";
	import { Component } from "react";

	class Message extends Component{

		constructor(){
			super();
			this.state={
				message:'Welcome visitor',
				subscribe:'Subscribe'
			}
		}

		changeMessage(){
			this.setState({
				message: 'Thank you for Subscribing',
				subscribe: 'unsubscribe'
			})
		}

		render(){
			return(
			<div>
				<h1>{this.state.message}</h1>
				<button onClick={() => this.changeMessage()}>{this.state.subscribe}</button>
			</div>
			)
		};
	}
	export default Message;


########################################################### 11.setState  #################################################################

Create one Counter component which will have Count value and a button which will increment count value.

	import React from "react";
	import { Component } from "react";

	class Counter extends Component{

		constructor(){
			super();
			this.state={
				count : 0
			}
		}
		render(){
			return <h1>Counter value : {this.state.count}</h1>;
		}

	}

	export default Counter;
	
Add a button to the Counter.

	  render(){
        return(
            <div>
            <h1>Counter value : {this.state.count}</h1>
            <button>Increment</button>
            </div>
        )
    }
	
we use the setState() to update the state value on button click.
setState() accepts an Object as first parameter and Arrow function as second parameter.

	 <button onClick={() => this.increment()}>Increment</button>
	 
	  increment() {
        this.setState({
            count: this.state.count + 1
        }
        )
    }
	
setState() with both the parameters
	
	   increment() {
            this.setState({
                count: this.state.count + 1
            },
				() => {
					console.log(this.state.count);
				}
			) 
		}
		

	
Note :
------
1.The only place where we can assign the state is constructor.	
We cannot modify the state directly.If we modify the state React will not re-render the Component.
Always make use of setState and never modify the state directly.

2.If the code has to be executed after the state has been updated,place the code in the callback function which is the second argument to setState().
React will group multiple setState() calls into single setState for better performance.

3.Whenever we want to update the state based on previous state value,pass in as a function argument instead of regular Object.

########################################################### 12.Destructuring Props and State  ############################################

Destructuring is an ES6 feature that makes possible to unpack values from arrays or props from Objects into distinct variables.
In React destructuring props and state improoves code reusability.
Destructuring can be done by using {}.

	import React from "react";

	const Greet = ({name,occupation}) => {
		return(
		<div>
			<h1>Welcome {name} and occupation is {occupation}</h1>
		</div>
		)
	}

	export default Greet;
	
The second way to destructure the props is by using function body.

	import React from "react";

	const Greet = (props) => {
		const {name,occupation} =props;
		return(
		<div>
			<h1>Welcome {name} and occupation is {occupation}</h1>
		</div>
		)
	}

	export default Greet;
	

########################################################### 13.Event Handling  ###########################################################

Any Web Application we create typically tends to have user interaction.
When the user interacts with the Application events are fired. 
Consider the scenario of button click.
Create the component for Event Handler named FunctionClick.js.

	import React from "react";

	const ClickEvent = () => {
		return (
			<div>
				<h1><button>Click</button></h1>
			</div>
		)
	};
	export default ClickEvent;
	
Our goal is to capture the click event and perform some logic.
React events are named using camel case.

	   function clickHandler(){
        console.log('Button clicked');
	   }

	   return (
			<div>
				<h1><button onClick={clickHandler}>Click</button></h1>
			</div>
	   )

Note :
------
To the button click we are passing the function as an Event handler.
Here we want the handler to be a function and not the function call.
              
########################################################### 14.Binding Event Handlers  ###################################################

The reason we bind Event Handlers in Class Component is purely because of the way this keyword works in JavaScript.
It is not because of how React works.
Here the requirement is when we click on the button we need to change the message.
Also create a state property called message and bind it to the user interface.
	
	import React from "react";
	import { Component } from "react";

	class EventBind extends Component{
		constructor(props){
			super(props)
			this.state={
				message : 'Event Handing using bind'
			}
		}
	render(){
		return(
			<div>
				<h1>{this.state.message}</h1>
				<button>Click</button>
			</div>
		)
		}
	}

	export default EventBind;
	
Now change the message "Event Handing using bind" to "Binding is done" using Event Handler.
We can do this by calling the Event Handler on the button click.This can be done by using setState().

	 eventHandler(){
        this.setState({
            message: 'Binding is done'
        })
    }

	render(){
		return(
			<div>
				<h1>{this.state.message}</h1>
				<button onClick={this.eventHandler}>Click</button>
			</div>
		)
	}
	
Here it will throw an Error message saying "Cannot read properties of undefined".
There are number of ways to bind Event Handlers in React.

1.First approach is to use the bind keyword i.e. bind the handler in the render() If we are calling the normal Function on Button Click.

	 <button onClick={this.eventHandler.bind(this)}>Click</button>
	 
The problem with this approach is every update to the state will cause the component to re-render.
This inturn will generate a brand new Event Handler when it re-renders.
The impact of the performance will decrease in large Applications where the Components contains the nested Children Components.

2.Second approach is to use the arrow function in the render()

	<button onClick={() => this.eventHandler()}>Click</button>
	
3.Third approach deals with binding the Event handler in the constructor rather than render()
Because binding happens once in the constructor better than render().

	constructor(props){
        super(props)
        this.state={
            message : 'Event Handing using bind'
        }
        this.eventHandler=this.eventHandler.bind(this);
    }
	
	render(){
    return(
        <div>
            <h1>{this.state.message}</h1>
            <button onClick={this.eventHandler}>Click</button>
        </div>
		)
    }

4.Final approach is to use arrow function as a class property.
Here we need to change the method we define in the class.

	eventHandler = () => {
        this.setState({
            message: 'Binding is done'
        })
    }
	
	 <button onClick={this.eventHandler}>Click</button>

Note :
------
React document suggests to use approach 3 or 4.

########################################################### 15.Methods as Props  #########################################################

In the earlier videos we have seen how to pass props as parameter from Parent Component to Child Component.
Here the requirement is the Child Component has to communicate with parent Component.
Here also we use the props as a reference to the methods.
	
Parent Component :
------------------

	import React from "react";
	import { Component } from "react";
	import Child from "./Child";

	class Parent extends Component{

		constructor(){
			super()
			this.state={
				parentName : 'Parent Component'
			}
		}

		greetParent = () => {
			alert(`Greeting from ${this.state.parentName}`)
		}

		render(){
			return(
			<div>
				<Child></Child>
			</div>
			)
		}
	}
	
Child Component :
-----------------

	export default Parent;
	
	import React from "react";

	function Child(){
		return( 
		<div>
			<button>Greet Parent</button>
		</div>
		)
	}

	export default Child;

Whenever we click on the button in the Child Component,method in the Parent Component has to be executed.
Here we are passing the method as a reference to the Child Component as a props in the Parent Component.

	<Child greetHandler={this.greetParent}>Greet Parent</Child>
	
Note :
------
We can also pass the parameter from Child Component to Parent Component.
The best approach is to use arrow function.

In Child Component

	  <button onClick={() => props.greetHandler('Child')}>Greet Parent</button>
	  
In Parent Component

	greetParent = (child) => {
        alert(`Greeting to ${this.state.parentName} from ${child}`)
    }
	
         
########################################################### 16.Conditional Rendering   ###################################################

Whenever we are often working on React Application we may need to hide or show HTML based on certain condition.
Conditional rendering in React works same as the Conditional rendering works in JavaScript.
There are 4 diffierent approaches for conditional rendering.

1.If else
2.Element Variables
3.Ternary operators
4.Short circuit operators

1.If else :
-----------
		
		import React from 'react'
		import { Component } from 'react'
		class UserGreet extends Component {
			constructor() {
				super()
				this.state = {
					loggedIn : false
				}
			}
			render() {
				return (
					<div>
						<div>Welcome Guest</div>
						<div>Welcome Srinivas</div>
					</div>
				)
			}
		}
		export default UserGreet;
		
Here the message should be conditionally rendered based on loggedIn parameter.

	render() {
        if (this.state.loggedIn) {
            return (

                <div>Welcome Guest</div>
            )
        }
        else {
            return (<div>Welcome Srinivas</div>)
        }
    }

2.Element Variables :
---------------------
We cannot write the if else statements inside the JSX.
We use JavaScript elements to store the variables.

	    render() {
			let message;
			if (this.state.loggedIn) {
				message = <div>Welcome Guest</div>
			}
			else {
				message = <div>Welcome Srinivas</div>
			}
			return message;
		}
		
3.Ternary operators :
---------------------
		
		return this.state.loggedIn? <div>Welcome Guest</div>:<div>Welcome Srinivas</div>
		
3.Short Circuit operator :
--------------------------
Short Circuit Operator is a specific case of Ternary Operator.
Whenever we want to render the data only if certain condition satisfies then we use Short Circuit Operator.

		 return this.state.loggedIn  && <div>Welcome Srinivas</div>
		
		
########################################################### 17.List Rendering  ###########################################################

Whenever we build any Web Applications common scenario is to display the List of items.
Here we repeat the item for each element in the List.
One of the main advantage in React is it relies mostly on the JavaScript libraries and not introduced any methods to manipulate data.
Create the Component to render the List.

	import React from "react";
	import { Component } from "react";

	class List extends Component{
		constructor(){
			super()
			this.state={
				message: 'Lits Render'
			}
		}
		render(){
			return(
				<div>
					<h1>List Render</h1>
				</div>
			)
		}
	}
	export default List;
	
Create the List of names Array.

	 const names =['Srinivas','Nandini','Bhauik','Aadvik']
	 
To iterate the List of elements 

	 render(){
        const names =['Srinivas','Nandini','Bhauik','Aadvik']
        return(
            <div>
                <h2>{
                        names.map(name => <h3>{name}</h3>)
                    }
                </h2>
            </div>
        )
    }
	
To make it simpler we format the code

	render(){
        const names =['Srinivas','Nandini','Bhauik','Aadvik']
        const nameList=names.map(name => <h3>{name}</h3>);
        return (
            <div>{nameList}</div>
        )
    }
	
Note :
------
Typically we are going to have List of Objects with few properties that has to be rendered.
It is always a good idea to refactor the JSX into seperate Component and then use the Component in the map() JSX.

	render(){
        const persons =[
            {
                id:'22',
                name: 'Srinivas',
                age: '37',
                skill : 'Fullstack'

            },
            {
                id:'27',
                name: 'Nandini',
                age: '32',
                skill : 'Java'

            },
            {
                id:'23',
                name: 'Bhaumik',
                age: '7',
                skill : 'React'

            },{
                id:'15',
                name: 'AAdvik',
                age: '2',
                skill : 'AWS'

            }
        ]
        const names =['Srinivas','Nandini','Bhauik','Aadvik']
        const nameList=names.map(name => <h3>{name}</h3>);
        return (
            <div>{nameList}</div>
        )
    }
	
Now for each person in the List now need to render the name,age and skill.

		const personList=persons.map(person => 
            <h3>{person.name} started studying {person.skill} </h3>
            
        );
        return (
            <div>{personList}</div>
        )
The recomended way is to refactor the JSX into Seperate Component.
Create new Component named Person.js which accepts the person as props.

	import React from "react";
	function Person({person}){
		return(
			<div>
				<h3>{person.name} started studying {person.skill} </h3>
			</div>
		)
	}
	
In the List Componen call the Person Component.
	
   const personList=persons.map(person =>  <Person Person person={person} />);
	return (
		<div>{personList}</div>
	)
	            
########################################################### 18.Lists and Keys ############################################################

Whenever we render the List of elements without key React will throw a warning in the console i.e.

	"Each child in an Array or Iterable should have a unique key prop"

Each item rendered in the List using map operator to have a prop called "key" and the value to the prop should be unique within the List.

	const personList=persons.map(person =>  <Person key={person.id} Person person={person} /> );

Note :
------
Key prop cannot be accessible to the child components.
Key prop is an id to render the List efficiently and is reserved.

A Key is the special String attribute that we need to include when render the List of items.
Keys give the elements a stable identity.
Key helps in identifying React which element in the List is modified i.e. Added,Updated or Deleted.
This way instead of updating the whole DOM Tree,React will update the specific DOM Tree wherever Key is updated.

            
########################################################### 19.Index as Key Anti Pattern  ################################################

    
########################################################### 20.Styling and CSS Basics  ################################################### 


########################################################### 21.Basics of Form Handling ###################################################

Here we will see how to capture input from Form Elements like input,textarea and select and have the data available for Form submission.
In regular HTML Form Elements like input,textarea etc are responsible on their own to handle the user input and update the respective values.
Here we want to React to control the Form Elements.
Such Form elements whose values are controlled by React is called Controlled Components.
Consider the scenario 

	<input type="text" value="" onChange="" />
	
We deal with the values that can change within the Component by using state() and setState().
In the Controlled Component the value of the input field is set to the state property.
Alos we have an onChange Event fired when there is a change in the input field value.
In the OnChange Event handler we use setState to update the state.

When the state gets updated render() is called and new state is assigned as a value to the input element.
So there is a cycle from setting the value of the initial state,propogating the changed value to the state and back to the input field.
React will always have access to the Component state which reflects the updated value of the form elements.
That state object then can be used to submit the form data.

	 render(){
        return(
            <form>
                <div>
                    <label>Student name : </label>
                    <input type='text' value='' ></input>
                </div>
            </form>
            
        )
    }
	
The above code is regular HTML.
To convert the above code into Controlled Component we need to follow the two steps.

1.Create the Component state that will control the value of the input element.

	 constructor(){
        super()
        this.state={
            userName :''
        }
    }
	
	<input type='text' value={this.state.userName} ></input>
	
2.Now we nned to handle the onChange Event  handler.
Whenever we assign a handler to the onChange event, the event itself will be passed as a handler to the onChange event.
From this event we can extract the value of the input element.

	 handleUserName = (event) =>{
        this.setState({
            userName : event.target.value
        }
     )
    }

	<input type='text' value={this.state.userName} onChange={this.handleUserName}></input>
	
To submit the form data we use submit button.
If we submit the data form data gets cleared.
The common approach is to have JavaScript function that handles the form.
That function will also have an access to the data entered  by the user into the form.

	 submitStuedntForm = (event) =>{
        alert(`${this.state.userName} - ${this.state.comments} ${this.state.skill}`)
    }

	 <form onSubmit={this.submitStuedntForm}>
	 <button type='submit'>Submit</button>

Whenever we dismiss the alert,Form data is cleared.
To avoid this we have to call preventDefault().

	submitStuedntForm = (event) =>{
        alert(`${this.state.userName} - ${this.state.comments} ${this.state.skill}`)
        event.preventDefault();
    }

########################################################### 22.Component Life Cycle Methods ##############################################

When we create any React Component,Component goes through several stages in its Lifecycle.
React provides built in methods that we can override at particular stages in the Lifecycle.
Lifecycle methods are available for Class Component and not for the Functional Component.
We can classify the methods into 4 phases.

1.Mounting
Mounting Lifecycle methods are called whenever an instance of the Component is being created and inserted into the DOM.
During the Mounting Lifecycle phase we have 4 methods.

1.constructor()
2.getDerivedStateFromProps()
3.render()
4.componentDidMount()

2.Updating
Updating Lifecycle methods are called whenever a Component is being re-rendered as a result of changes either to its props or state.

3.Unmounting
Unmounting Lifecycle methods are called whenever a Component is being removed from the DOM.

4.Error Handling
Error Handling methods are called whenever there is an Error during rendering,Lifecycle method or in the Constructor of any Child Component.


########################################################### 23.Component Mounting Lifecycle Methods ######################################

Mounting Lifecycle methods are called whenever an instance of the Component is being created and inserted into the DOM.
We will be going through the order in which Mounting Lifecycle methods will be inoked.

1.Constructor :
---------------
Constructor is a special function that will get called whenever a new Component is created.
Constructor is used for initializing the state and binding the Event handlers to the Class instance.
We cannot make HTTP Request from the Constructor.
In the Component we have access to this.props only after calling super(props) from the Constructor.
Constructor is the only place where we initialize the state.
In all other scenarios we have to use this.setState().

2.getDerivedStateFromProps(props,state) :
-----------------------------------------
React Documentation officially specifies that it is a rarely used Lifecycle method.
This method recieves props as its parameter and is used whenever state of the Component depends on changes in props over time.
Consider the scenario where we have a Component.
Here initial state of the Component depends on the props being passed to the Component.
In such scenario we can use this method to set the state.
Since this method is a static method it does not have access to this keyword.
We cannot call this.setState() as it is a static method.
getDerivedStateFromProps() has to return either null or an Object that represents new/updated state of the Component.
This method is called everytime when a Component is re-rendered.

3.render() :
------------
render() is the only required method in Class Component.
render() reads the props and state and returns the JSX which describes the UI.
In the render() avoid changing the state of the Component or interact with DOM or make AJAX calls.
Since the render() returns the JSX which also contains other children Components,Children Component Lifecycle methods will also get executed.

4.componentDidMount() :
-----------------------
Ths method will be invoked only once in the Lifecycle of the given Component.
This method will be invoked immideately after the Component and it's Child Component have been rendered to the DOM.
This method is the perfect place to call side effects i.e. interact with DOM or perform any AJAX calls to load the data.

########################################################### 24.Component Updating Lifecycle Methods ######################################

Updating Lifecycle methods will get called whenever a Component is being re rendered because of the changes either in props or state.
There are 5 methods in Updating Lifecycle methods out of which 3 methods are rearely used.

1.getDerivedStateFromProps() :
------------------------------

2.shouldComponentUpdate(props,state) :
--------------------------------------
This method recieves the updated props and state.
The purpose of this method is to re-render the Component or not.
By default all the Class Components will re-render whenever the props they recieve or the state changes.
This method can return the default behavior by returining false.
What we can do here is by comparing the state with the previous state and based on the result we can re-render the Component.
This method can be used for performance optimization.
We need to avoid calling setState() and performing AJAX calls.

3.render() :
------------

4.getSnapshotBeforeUpdate(prevProps,pervState) :
------------------------------------------------
React Documentation officially specifies that it is a rarely used Lifecycle method.
This method accepts prevProps and prevState as its parameter and is called right before the changes from the Virtual DOM to be reflected into the DOM.
We use this method to capture some information from the DOM.
We can read the user scroll position and after updating the DOM maintain the scroll position by performing some calculations.
This method will return either null or return a value.
Returned value will be passed as a third parameter to the next method.

5.componentDidUpdate(prevProps,pervState,snapshot) :
----------------------------------------------------
This method will get called after the render is finished in the re render Lifecycle.
This means we can be sure that the Component and all its sub Components have properly rendered itself after the update.
This method is gauranteed to called only once in each re render Lifecycle.
This method is the perfect place to call side effects i.e. interact with DOM or perform any AJAX calls to load the data.
Before performing any calls we need to compare prevProps with the new props otherwise we are making unwanted requests.

Create the Component named UpdatingLifecycle.js.
To trigger the updating Lifecycle we nned to change either the state or props.


########################################################### 25.Fragments #################################################################

Scenarion 1 :
-------------
Fragments allows us to group list of Children nodes without adding extra nodes to the DOM.
JSX will expect only one element for that we enclose all the statement in the <div>.
Here the <div> will be added to the DOM Tree.

We can replace the <div> with Fragment that will prevent from adding extra node to the DOM Tree.

	import React from 'react'

	function FragmentDemo(){

		return(
			<React.Fragment>
				<h2>Fragment Demo</h2>
				<p>This describes the Fragment Demo Component</p>
			</React.Fragment>
		)
	}

	export default FragmentDemo
	
After adding React.Fragment we no longer have <div> in the DOM Tree.

Scenarion 2 :
-------------
React Fragment can also be used in Table data where column data is define in another Component which contains multiple data.
If we define in <div> then <div> cannot be child tag of <td>.
In this scenario we use React.Fragement.

Scenario 3:
-----------
React Fragment accepts the key attribute while rendering the List.

Note :
------
Alternative syntax of React.Fragment is <>.
The drawback of this syantx is we cannot add key attribute.
                     
########################################################### 26.Pure Components ###########################################################

There is an another way to create Component in React i.e. by extending PureComponent.
To understand the difference between Component and PureComponent consider the scenario.

Lets create 3 Components

1.ParentComponentDemo
2.RegularComponentDemo
3.PureComponentDemo

Then include the Regular and Pure Components into Parent Component by passing the name as Props.
The difference between Regular Component and Pure Component is Pure Component is never re-rendered.

Regular Componnet does not implement shouldComponentUpdate() and always returns true by default.

Pure Component implements shouldComponentUpdate() with shallo props and state comparison.
Pure Component does a Shallow Comparison of Previous State/Previous Props with Current State/Current Props 
and if it finds any difference then only it will re-render the Component.

Note :
------
If the Parent Component does not re-render then child Component will not re-render.

Pure Components can be used to avoid unnecessary renders to improove the performance.
Also don't mutate the List while pushing the elements into the List because reference to the Array never changes.
Because Pure Component will only check the reference to re render the Componenet.

It is best practice to ensure that all the Child Components are also pure to avoid unexpected behavior.

########################################################### 27.Memo ######################################################################

Pure Components re-render the Class Component only when there is a difference in the shallow comparison of props and state.
Pure Components works with Class Components.
If we want to achieve the same in Functional Component we use React.Memo

Create the Component named MemoDemo.js
	
########################################################### 28.Refs  #####################################################################

Refs makes it possible to access the DOM node directly within React.
Consider the scenario of focusing the input text element i.e. username when the page loads.
Using Refs we can do in 3 steps.

Scenario 1 :
------------
1.Create the Ref
2.Attach the Ref to the input element.
3.Call the focus() on the current input reference in componentDidMount().

	constructor(props) {
        super(props)
        this.userNamereference = React.createRef() // Creating Ref
        this.state = {
            name: 'Username',
        }
    }
	
	<input type='text' ref={this.userNamereference}></input> // Adding Ref to input element
	
	componentDidMount(){
        this.userNamereference.current.focus() // Calling focus() on input Ref
    }
}


Scenario 2 :
------------
Another approach to create a Ref is by using callback reference.
Using callback reference we can do it in 4 steps.

1.Create the property with the default value.
2.Use the setState of the property as a reference.
3.Change the State of the property.
4.Call the focus() on the property in componentDidMount().

	class RefsDemo extends Component{
    constructor(props) {
        super(props)
        this.userNamereference = React.createRef()
        this.state = {
            name: 'Username',
        }
        this.surname = null
        this.setSurname = element => {
            this.surname = element
        }
        
    }

    userNameHandler = () =>{
        alert(`Username : ${this.userNamereference.current.value} and surname : ${this.surname.value}` )
    }

    render(){
        return(
            <div>{this.state.name}
            <input type='text' ref={this.userNamereference}></input>
            <input type='text' ref={this.setSurname}></input>
            <button onClick={this.userNameHandler}>Submit</button>
            </div>
        )
    }

    componentDidMount(){
        if(this.surname){
            this.surname.focus()
        } 
    }
	}
	export default RefsDemo
	
Note :
------
By using Ref we can also fetch the user input value.
                      	
###########################################################  29.Refs with Class Components  ##############################################

It is also possible to add Ref to Class Component.
Create the Component named RefsClassDemo.
Add the input text element.
Consider the scenario of focusing the input text element i.e. username when the page loads.
Using Refs we can do it in 3 steps.

1.Create the Ref using React.createRef()
2.Attach it to the input element.
3.Call the focus() in the componentDidMount()

Here instead of using componentDidMount() we use regular method which will focus the input element.
This method will be called by the Parent Component and the input element in the Child Component will recieve the focus.
We achieve this using Refs on input Component.

Create the Parent Component named FocusUsername.js.

1.Create the Ref in the Parent Component
2.Attach the ref to the Componnet
3.Add the Click handler button and using this method call the Child Component method using ref.

Parent Component :
------------------

	class FocusUsername extends Component{
		constructor(props){
			super(props)
			this.state={
				name:'Focus Username'
			}
			this.parentUseNameRef=React.createRef()
		}

		parentFocusUserName = () =>{
			this.parentUseNameRef.current.focusUserName()
		}

		render(){
			return(
				<div>
					<RefsClassDemo ref={this.parentUseNameRef}></RefsClassDemo>
					<button onClick={this.parentFocusUserName}>Focus Username</button>
				</div>
			)
		}
	}
	
Child Component :
-----------------

	class RefsClassDemo extends Component {
    constructor(props) {
        super(props)
        this.state = {
            name: 'Refs using Class Component'
        }
        this.userNameRef=React.createRef()
    }

    focusUserName(){
        this.userNameRef.current.focus()
    }
        
    render() {
        return (
            <React.Fragment>
                <h2>
                    {this.state.name}
                </h2>
                <br></br>
                <label>Username : </label>
                <input type="text" ref={this.userNameRef}></input>
            </React.Fragment>
        )
    }
	}

Note :
------
Refs makes it possible to access the DOM node directly and can also be attached to Class Component.
Refs cannot be attached to Functional Component.
                                
########################################################### 30.Forwarding Refs  ##########################################################

             
########################################################### 31.Portals  ##################################################################

                      
########################################################### 32.Error Boundary  ###########################################################
               

########################################################### 33.Higher Order Components Part 1  ###########################################

Create the Component name ClickCounter.js

	render() {
        return(
            <React.Fragment>
            <h2>{this.state.name}</h2>
            <button>Clicked x Times</button>
        </React.Fragment>
        )
    }
	
Implement the Click Counter on the button Click.

	 <button onClick={this.incrementCount}>Clicked {this.state.count} Times</button>

	 incrementCount=() =>{
        this.setState((previousState) =>{
            return {
                count: previousState.count+1
            }
     })
    }
	
Now the Click Counter functionality is working fine.
But there is one more requirement where we want the hover Count.
Create the Component name HoverCounter.js
Similarly If there is a requirement of KeyUp Counter again we need to create one more Component.
Here we are duplicating the code and not reusing the functionality.
One of the approach will be moving the state to the Parent Component and pass it as a handler to the props.
Define the Counter functionality in the App Component and provide the state and handler as props to Click Counter and Hover Counter.
If there is a scenario where the Counter Component are not child of Parent Component then in this case we have to drill down till the Child Component.
So there is a need to share the common functionalities between the Components without having any Parent Child Relationship.
Here we use Higher Order Components.

########################################################### 34.Higher Order Components Part 2  ###########################################

Higher Order Component is a pattern where function takes a Component as an argument and returns a new Component.
Typlically Higher Order Component adds additional data to Original Component.
So the new Component is also referred to as enhanced Component.

	const newComponent=higherOrderComponent(OriginalComponent)

Setps to create an Higher Order Component :
1.Create a HOC named withCounter.js

	const withCounter = (OriginalComponent) => {

    class WithCounter extends OriginalComponent{
        render(){
            return <OriginalComponent name='Srinivas'></OriginalComponent>
        }
    }
    return NewComponent;
	}

2.For the ClickCounter to return the same Component itself,return the HOC with the ClickCounter Component.

	export default UpdatedComponent(ClickCounter)
	
3.Now in both the Components we can render the name property.

	 render() {
        return(
            <React.Fragment>
            <h2>{this.state.name}</h2>
            <button onClick={this.incrementCount}>{this.props.name} Clicked {this.state.count} Times</button>
        </React.Fragment>
        )
    }
	
4.Here we want Counter functionality to be shared across the Components from the HOC.
In the HOC we need to pass the state and incrementCounter() as props so that original Component can make use of that.

	render(){
            return <OriginalComponent name ='Srinivas' count={this.state.count} incrementCount={this.incrementCount}></OriginalComponent>
        }
	
And in the Child Component we use the props count and incrementCount.

	class ClickCounter extends Component {
    render() {
			return(
				<React.Fragment>
				<h2>Click Counter</h2>
				<button onClick={this.props.incrementCount}>{this.props.name} Clicked {this.props.count} Times</button>
			</React.Fragment>
			)
		}
	}
	export default UpdatedComponent(ClickCounter)
	
Note :
------
The Function name and the Component name should be same.

########################################################### 35.Higher Order Components Part 3  ###########################################

Scenario 1 :
------------
Passing down the props.
Consider the scenario we passed one parameter from App Component to ClickCounter i.e. message

	function App() {
	  return(
		<div className='App'>
		  <ClickCounter message='HOC props parameter'></ClickCounter>
		  <HoverCounter></HoverCounter>
		</div>
	  )
	}
	
If we want to read the prop in ClickCounter Component

	class ClickCounter extends Component {
    render() {
			return(
				<React.Fragment>
				<h2>Click Counter</h2>
				<button onClick={this.props.incrementCount}>{this.props.message} {this.props.name} Clicked {this.props.count} Times</button>
			</React.Fragment>
			)
		}
	}
	
Here we cannot see the message props in the ClickCounter Component because props is passed to HOC i.e. withCounter and not ClickCounter.
To fix this issue we need we need to pass the remaining props to the wrapped Component using Spread Operator.

	render() {
		console.log(`From App Component to HOC : ${this.props.message}`)
		return <OriginalComponent name='Srinivas'
			count={this.state.count}
			incrementCount={this.incrementCount}
			{... this.props}
			></OriginalComponent>
        }
		
Scenario 2 :
------------
Passing parameters to the HOC function.
Consider the scenario where we increment the count by 5 in ClickCounter and 10 in HoverCounter Component.
We can do that by passing the parameter to the HOC function.

	const withCounter = (OriginalComponent,incrementNUmber) => {
	}
	
	incrementCount = () => {
		this.setState((previousState) => {
			return {
				count: previousState.count + incrementNUmber
			}
		})
    }
	
	export default withCounter(ClickCounter,5)

########################################################### 36.Render Props Part 1 #######################################################

Render Props is similar to Higher Order Component.

Create the Component named 
ClickCounterTwo.js
HoverCounterTwo.js
 
########################################################### 37.Render Props Part 2 #######################################################   

In React it is possible to use a prop whose value is a function to control what is actually rendered by a Component.
The term "render props" refers to a technique for sharing code between Components using a prop whose value is a function.

Create the Component named User.js

Scenario 1:
-----------
To the User Component pass the name as props from App Component.

	function App() {
	  return (
		<div className='App'>
		  <ClickCounterTwo/>
		  <HoverCounterTwo/>
		  <User name='Srinivas from App Component'/>
		</div>
	  )
	}
	
	render(){
		return(
			<React.Fragment>
			   {this.props.name}
			</React.Fragment>
		)
    }
	
Scenario 2 :
------------
Instead of passing the name as String,pass the function which will return a String.

	function App() {
	  return (
		<div className='App'>
		  <ClickCounterTwo/>
		  <HoverCounterTwo/>
		  <User name={() => 'Srinivas from App Component'}></User>
		</div>
	  )
	}
	
	render(){
        return(
            <React.Fragment>
               {this.props.name()}
            </React.Fragment>
        )
    }
	
Scenario 3 :
------------
Now pass the parameter to the function from App Component to User Component.

	function App() {
	  return (
		<div className='App'>
		  <ClickCounterTwo/>
		  <HoverCounterTwo/>
		  <User name={(loggedIn) => loggedIn?'Srinivas':'Guest'}></User>
		</div>
	  )
	}
	
	render(){
        const {loggedIn} =this.props
        return(
            <React.Fragment>
               {this.props.name(loggedIn)}
            </React.Fragment>
        )
    }

Scenario 4 :
------------
In React it is possible to use a prop whose value is a function to control what is actually rendered into the Component.
From the above 3 Scenarios we have learnt how to use prop whose value is a function
Now we will see how to share the functionality.

Create the Component named Counter.js
Copy the common functionality i.e. state and incrementCounter.

	function App() {
	  return (
		<div className='App'>
		  <Counter
			render={(count, incrementCount) => (<ClickCounterTwo count={count} incrementCount={incrementCount}>
			</ClickCounterTwo>) 
			}
		  ></Counter>
		  <Counter
			render={(count, incrementCount) => (<HoverCounterTwo count={count} incrementCount={incrementCount}>
			</HoverCounterTwo>)
			}
		  ></Counter>
		</div>
	  )
	}

########################################################### 38.Context Part 1   ##########################################################

Consider the scenario we have lot of Components.

	Component A   Component B        Component C
					  ^					 ^
				  Component D		 Component E
										 ^
									 Component F
									
Here the requirement is that Component A,D and F are supposed to display Logged in Username.
Here the Username is the property in the App Component.
For Component A it is straight forward i.e. we can pass it as props.
It will become complex when the Componnet hierarchy grows as it has to pass through all the Components.
Context provides a way to pass the data through the Component Tree without having to pass props down to the Tree manually at every Level.
 
########################################################### 39.Context Part 2   ##########################################################

Here we will be implementing User Context which will enable Component at any Level to read a props that is passed at Top level.
Our goal is passs the name from App Component and read that value in Component F using the Context.
Create the File named userContext.js
There are 3 steps to implement the Context
1.Create the Context

	import React from "react";

	const UserContext=React.createContext()
	const UserProvider=UserContext.Provider
	const UserConsumer=UserContext.Consumer

	export {UserProvider,UserConsumer}
	
2.Provide the Context value
The place we provide the Provider is important because only the descendant Components can consume it.
We place the Provider in the App Component.

	function App() {
	  return (
		<div className='App'>
		  <UserProvider value='Srinivas'>
			  <C></C>
		  </UserProvider>
		</div>
	  )
	}

3.Consume the Context value in necessary Component.
To consume the Context Value we need to use the Consumer Component.

	class F extends Component {
    constructor(props) {
        super(props)
        this.state = {
            message: 'Component F'
        }
    }
    render() {
        return (
            <UserConsumer>
                {
                    (username) => {
                        <h2>Component F</h2>
                        return <React.Fragment>Hello {username} </React.Fragment>
                    }
                }
            </UserConsumer>
        )
    }
	}
	export default F

########################################################### 40.Context Part 3   ##########################################################

Usecase 1 :
-----------
We can set the default value to the Context while creating the Context.
It is passed as an argument to createContext().

	import React from "react";

	const UserContext=React.createContext('Code Evolution')
	const UserProvider=UserContext.Provider
	const UserConsumer=UserContext.Consumer

	export {UserProvider,UserConsumer}
	
	function App() {
	  return (
		<div className='App'>
			  <C></C>
		</div>
	  )
	}
	
Usecase 2 :
-----------
In the above example we used UserConsumer to consume the Context value.
We can also get the Consumer value by using Context Type property on a Class.

There are 2 setps to get the context value by using Context Type
1.export the Context itself
	
	import React from "react";

	const UserContext=React.createContext('Code Evolution')
	const UserProvider=UserContext.Provider
	const UserConsumer=UserContext.Consumer

	export {UserProvider,UserConsumer}
	export default UserContext
	
Step 2 :
--------
Assign the UserContext to the contextType property on the Class.

	class E extends Component {
    constructor(props) {
        super(props)
        this.state = {
            message: 'Component E'
        }
    }
    render() {
        return (
            <React.Fragment>
			 {this.context}
                <F></F>
            </React.Fragment>
        )
    }
	}

	E.contextType=UserContext (or)  static contextType=UserContext
	export default E

Notes :
-------
Context Type works only with Class Component.
We can subscribe only to a single Context using Context Type.

########################################################### 41.HTTP and React ############################################################

Whenever we are building any Web Application we do not often reach to Server to fetch the data or to send the data.
We use API's to perform these tasks.
React is a library for building User Interfaces.React is no where concerned about HTTP.
React Component simply reads the props & state and render the UI.
Here we make use of HTTP Library.
There are few popular HTTP libraries like axios,fetch API etc.
We will be using axios to communicate with the Server.
Add the axios package to the React Application.

	npx create-react-app react-http
		
To install the axios package

	npm install axios
		      
########################################################### 42.GET Request  ##############################################################

To fetch the API we need to have an API End Point.
For that we will be using Json Place Holder.
Create the Component named PostList.js.

Step 1 :
--------
import the axios library.

	import axios from 'axios'

Step 2 :
--------
Create the state property which will hold List of Posts.

	 constructor(props){
		super(props)
		this.state={
			posts:[]
		}
	}
	
Step 3 :
--------
Use the axios to make the GET request to an API in the componentDidMount() Lifecycle method.

	 componentDidMount(){
        axios.get('https://jsonplaceholder.typicode.com/posts1').then(response => {
            this.setState({
                posts:response.data
            })
        }).catch(error => {
            this.setState({
                errorMessage:'Error in fetching the post'
            })
        })
    }
	
	 render() {
        const {posts,errorMessage} =this.state
        return (
            <React.Fragment>
                <h2>List of Posts</h2>
                {posts.map(post => 
                    <div key={post.id}>
                        {post.title}
                    </div>
                )}
                {
                    errorMessage?<div><h3>{errorMessage}</h3></div>:null
                }
            </React.Fragment>
        )
    }


########################################################### 43.POST Request ##############################################################  