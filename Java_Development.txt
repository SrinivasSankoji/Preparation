1.Classpath                                        									   						[24-DEC-2020]  (Done)
2.Jar file Creation                                                                    						[24-DEC-2020]  (Done)
3.System properties                                                                    						[24-DEC-2020]  (Done)
4.jar vs war vs ear                                                                    						[24-DEC-2020]  (Done)
5.web Application vs Enterprise Application                                            						[24-DEC-2020]  (Done)
6.Web server vs Application Server                                                     						[24-DEC-2020]  (Done)
7.Classpath vs Path                                                                    						[02-OCT-2023]  (Done)
8.JDK vs JRE                                                                           						[24-NOV-2021]  ()
9.Object Creation Ways  (geeksforgeeks)			                                       						[25-AUG-2020]  (Done)
10.Class Loaders								                                       (Alexander Obregon)	[25-NOV-2021]  ()
11.Memory Area of JVM                                                                  						[02-DEC-2020]  ()
12.Understanding JVM Memory, Heap, Garbage Collection and Monitoring the JVM           (Tech Primers)    	[23-NOV-2025]  ()
13.Memory Leaks in Java,Issue cause and How to prevent them                            (Lazy Programmer)    [23-NOV-2025]  ()
14.Understanding Garbage Collection, Memory Leaks, Heap and Thread Dumps               (Perfology)          [23-NOV-2025]  ()
15.Java JVM Architecture Overview													   (Kaizen Chandra)     [23-NOV-2025]  ()
16.JVM Internal Architecture ()
17.Java Memory Management ()
18.Garbage Collector ()
19.Heap Memory ()
20.Metaspace ()


#############################################################  11.Classpath  ###################################################################################

we use javac command to compile a single or group of java source files.

	javac [options] A.java
	
Here the options are 
-d
-version
-cp/-classpath
-source

we use java command to run a single .class file

	java [option] A.class
	
Here Options are
-version
-cp/-classpath
-ea/-da/-esa/-dsa
-D
-verbose
	
We can compile any number of source files where as we can run only one .class file.

Classpath :
-----------
Classpath represents the location where the .class file is present.
javac and JVM will use the classpath to locate required .class files.
By default javac and JVM will look for the .class files in the current working directory.
By setting the classpath we are conveying javac and JVM that required .class files are present in this location.
If the particular .class file is not found then we will get ClassNotFoundException.

Various ways for setting Classpath :
------------------------------------
Environment Level
Command Prompt Level
Command Level

Environment Level :
-------------------
Required whenever we are installing permanent software in our system.
This way of setting the Classpath is preserved even when the System restarts also.

Command Prompt Level :
----------------------
From the command prompt we can set the classpath by using the set command

	set classpath="";
	
This way of setting the classpath will be preserved till the Command Prompt is open.
Once the Command Prompt is closed then Classpath will be lost automatically.

Command Level :
---------------
Once the Command completes the executes then the Classpath will be lost.
By using the command we set the Classpath.

	java -cp """;
	
Note :
------
Once we set the Classpath,JVM will not search for the .class files in the current working directory and It searches for the required .class files in the Classpath.

If several dependent .class files are required never recomended to set the classpath individually.
we have to group all the .class files into a single zip file.zip file is nothing but jar file.
To develop a Servlet all the required dependencies are present in servlet-api.jar file.

#############################################################  11.Jar file Creation  ##################################################################

To create a Jar File

	jar -cvf Test.jar A.class
	jar -cvf Test.jar A.class B.class

To extract the Jar File

	jar -xvf Test.jar 
	
To display the contents of the Jar file and not to extract

	jar -tvf Test.jar
	
If the .class file is present in the remote machine and has to be used by client machine
1.Send the request to the server machine and get the .class file.
2.Make the jar file available to the Client i.e download the jar file.


	JDK --> JRE --> lib --> ext  --> #.jar

If we place the jar file in the above location we are not required to set the classpath explicitly.
It is by default available to the JVM.

############################################################# 12.System properties  ################################################################# 

For every System some persistent information will be maintained in the form of System properties.
These may include OS Version,Java Version,JVM Vendor,URL,User Country etc.
We can also get and set the System Properties.

############################################################# 13.jar vs war vs ear  #################################################################

Jar,War and Ear are different types of archives that can be used to package applications.

Jar :
-----
Jar file can be used to package .class files, metadata and resources.
Jar file can be used for libraries, Stand alone Java Applications and Applets.

War :
-----
War file can be used to package Web Applications for deployment on Servlet Conatiner like Tomcat and Jetty.
War file contains components like Servlet,JSP,HTML Pages,JavaScript Files and other resources.
War file containes the directory WEB-INF

EAR :
-----
Ear file can be used to package Enterprise Application which contains multiple modules like EJB,Web Applications and Client Applications
to deploy on Enterprise Application Server like JBoss,WebLogic,WebSphere etc. 
Ear contains multiple Jar and War Files.


############################################### 14.web Application vs Enterprise Application  #######################################################

Web Application contains only web related technologies like Servlet,JSP,HTML,JavaScript etc where as
Enterprise Application can be developed by any technology from Jave i.e 
J2EE,EJB,JMS Component etc.
J2EE compatible Application is Enterprise Application.

############################################### 15.Web server vs Application Server  ################################################################

Web Server provides an environment to run the Web Application.
Web Server provides only support for web related technologies like Servlet,JSP HTML,JavaScript etc.
Some of the Web Servers are Tomcat,Nginix etc.

Application Server provides an environment to run Enterprise Application.
Application Server provides support for any technology like Servlet,JSP,EJB,JMS etc.
Some of the Application Server are
WebLogic
WebSphere
JBoss
GlassFish etc.

###############################################  16.Classpath vs Path  #################################################################################

Path :
------
Path is an environment variable that can be used to locate the JDK binaries or Executable Files that can be used to run any Java Commands.
Path is used by Operating System to find the location of the executable files.
The executable files are present in \bin folder.
If the Path variable is not we need to move to the directory containing the executables to execute the Java command.
If the Path variable is set we can run the Java command from anywhere.

Classpath :
-----------
Classpath is an environment variable that can be used to provide the path for all the .class files which are used in our Application.
Classpath can be used by Java Class Loader to load .class files.
In the Classpath we include all the .class files or jar files which are required for our Application.
Classpath can be overriden by command line options.

###############################################  17.JDK vs JRE  ########################################################################################


	
############################################### 18.Object Creation Ways  (geeksforgeeks) ###############################################################

The no of ways using which we can create Object are

1.new keyword
2.newInstance
3.clone()
4.deserialization
5.newInstance() of Constructor class

2.newInstance() :
-----------------
If we know the name of the Class and It has default Constructor then we can create an Object of the Class using newInstance().
Class.forName actually loads the class but doesn't create the Object.
To create an Object of the Class we use newInstance() method of the Class.

	public class NewInstance {
	String value="hello";
	public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
		Class cls=Class.forName("com.javainterview.objectcreation.NewInstance");
		NewInstance demo=NewInstance.class.newInstance();
		System.out.println(demo.value);
	}
	}
	
3.clone() :
-----------
Whenever clone() is called on any Object,JVM actually creates a new Object by copying all the contents of the previous Object.
Creating an Object usig clone() does not invoke any Constructor.
To use clone() Class must implement Cloneable Interface.

	public class ClonableInstance implements Cloneable {
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
	public static void main(String[] args) throws CloneNotSupportedException {
		ClonableInstance instanceOne=new ClonableInstance();
		ClonableInstance instanceTwo=(ClonableInstance)instanceOne.clone();
		System.out.println(instanceOne.hashCode());
		System.out.println(instanceTwo.hashCode());
	}
	}

4.deserialization :
-------------------
Whenever we serialize and deSerialize the Object new Object gets created.
While performing deserialization JVM does not use any Constructor to create the Object.
To deSerialize an Object,an Object must implements Serializable interface.

	public class DeSerializableInstance {
	public static void main(String[] args) {
		User user=new User();
		user.setName("Srinivas");
		user.setId(36);
		try {
			FileOutputStream fos=new FileOutputStream("user.ser");
			ObjectOutputStream oos=new ObjectOutputStream(fos);
			oos.writeObject(user);
			oos.close();
			
			FileInputStream fis=new FileInputStream("user.ser");
			ObjectInputStream ois=new ObjectInputStream(fis);
			User user2=(User)ois.readObject();
			ois.close();
			
			System.out.println(user.hashCode());
			System.out.println(user2.hashCode());
		}
		catch (Exception e) {
		}
	}
	}
	
5.newInstance() of Constructor class :
--------------------------------------
This is similar to newInstance() of a Class.
There is one more newInstance() in java.lang.reflect.Constructor class using which we can create new Object.
newInstance() of Class internally uses newInstance() of Constructor class.
Both newInstance() are Reflective ways to create an Object.

	public class ConstructorInstance {
	public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
		Constructor constructor=ConstructorInstance.class.getDeclaredConstructor();
		ConstructorInstance instance=(ConstructorInstance) constructor.newInstance();
		System.out.println(instance.hashCode());
	}
	}

############################################### 19.Class Loaders #######################################################################