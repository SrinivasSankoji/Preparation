Defog Tech :
************
1.Concurrency vs Parallelism						[08-JAN-2020]  (Done)
2.Java Memory Model									[15-JAN-2020]  (Done)
3.Volatile vs Atomic Integer						[05-JAN-2020]  ()
4.Adder and Accumulator Classes						[05-JAN-2020]  ()
5.Fork JoinPool										[15-JAN-2020]  ()
6.Synchronous Queue									[05-JAN-2020]  ()
7.ThreadLocal										[05-JAN-2020]  ()
8.Phaser vs CountDownLatch vs Cyclic Barrier		[05-JAN-2020]  ()
9.Java Asynchronous Programming						[05-JAN-2020]  ()
10.Lock Condition Class								[05-JAN-2020]  ()
11.Semaphore in Java Concurrency					[05-JAN-2020]  ()
12.Reentrant Lock									[05-JAN-2020]  ()
13.ReadWrite Lock									[05-JAN-2020]  ()
14.Exchanger Class									[05-JAN-2020]  ()
15.Guava Library									[05-JAN-2020]  ()
16.Completable Future								[05-JAN-2020]  ()
17.ExecutorService									[05-JAN-2020]  ()


******************************************** 1.Concurrency vs Parallelism ************************************************************


Parallelism :
-------------
Let us Consider an Example
Here Two Threads are Executing In Parallel and One Method.

	public static void main(String[] args) 
	{
		
		new Thread(new Runnable() {
			public void run() {				--> Task One
				processTax();
			}
		}) {
		}.start();
		
		
		new Thread(new Runnable() {
			public void run() {				--> Task Two
				processTax();
			}
		}) {
		}.start();

		hevayCalculations();				--> Task Three
	}

Here Task One and Task Two runs on Different Threads and Task Three runs on the Main Thread.
If we Run this Program on a Quad Core Processor i.e there are 4 Cores in a Processor,
Then we can Run These Tasks in Parallel.
In OS We have a Component Called Scheduler which is Responsible to Schedule the Threads on to these CPU Processor.

Task One  Runs on Core 1
Task Two  Runs on Core 2
Task Three  Runs on Core 3
Task Four  Runs on Core 4

Here All these Task will Run in Separate Cores in Parallel.
Parallelism is about doing lot of things at once so that we can speed up Performance.

We can also Change the Above Code by Using ExecutorService.
Using ExecutorService Fixed Thread Pool.

		ExecutorService executorService=Executors.newFixedThreadPool(4);
		executorService.submit(()-> processTax());
		executorService.submit(()-> processTax());
		
In Java To Enable Parallelism We Can Use Raw Threads or We can use The Concept of Thread Pool.
Even in Thread Pool It Can be 

1.ExecutorService
2.ForkJoin Pool
3.Custom Thread Pools (Used By Web Servers)

We Need to Ensure that the CPU has More than One Core So that We can run the Threads In Parallel.


Concurrency :
-------------
Consider he Scenario for Booking a Ticket.

		new Thread(() -> {
			if(ticketsAvailale>0)
			{
				bookTicket();				-->  Task Accessing Shared Variable
				ticketsAvailale--;
			}
			
		}).start();
		
		new Thread(() -> {
			if(ticketsAvailale>0)
			{
				bookTicket();			 	-->  Task Accessing Shared Variable
				ticketsAvailale--;
			}
			
		}).start();
		
		Thread.sleep(500);
		
Here Each Tasks Shares the Common Resource.
After Starting Two Thread Put The Main Thread For Two Seconds.
Let us Assume we have a Single Core Processor in CPU and Scheduler is assigning the Threads to the Processor.
Since CPU has Single Core Processor,Scheduler has to do Time Sharing Between The Threads.
Here The Scheduler Will Schedule the Thread 1 for Few Milli Seconds and Pick Thread 1 out and Keep Thread 1 For Few Mill Seconds.
This Concept is Called Interleaving of Threads.
How Much Time Scheduler Assigns to the Thread is Non Deterministic and Depends on Many Factors.
Here it Might Possible That Thread One Accomplishes all the Task within Time.
In Worst Scenario If The Thread has Not Accomplished the Task then there is Mismatch in Processing.
This is also the Case with MultiCore Processor.

To resolve the Issue we use the Concept Called Lock.
Thread One will Acquire the Lock,Completes the Task and Updates the Shared Variable and Release the Task.
Here Multiple Threads are Coordinating Between Each Other Using a Single Lock.
This Scenario is Called Concurrency.

Concurrency is about Dealing lot of things Once.
Concurrency is Applied When we Have a Shared Resource that has to be Accessed or Updated
or Multiple Threads need to Coordinate

In Java we Have Lot of Tools to Deal With Concurrency.

1.Locks /Synchronized
2.Atomic Classes
3.Concurrent Data Structures (ConcurrentHashMap.Blocking Queue)
4.Completable Future
5.CountDownLatch / Phaser / CyclicBinder / Semaphore etc.

Concurrency  + Parallelism  :
-----------------------------
Split he Sequential Flow into Independent Components 
Use Thread / Thread Pool to Parallelize these Components
Whenever a Shared Resource has to be Updated or Multiple Threads needs to be Coordinate Use Concurrency Tools to Manage.


******************************************** 2.Java Memory Model ************************************************************
Java Memory Model is a Specification which Guarantees the Visibility of Fields 
when we have Re Ordering of Instructions.
Java Memory Model Enforces that all the JVM has to implement these set of Rules 
so that Program Runs in the Same Manner. 

1.Out of Order Execution
2.Field Visibility
3.Happens Before

1.Out of Order Execution :
--------------------------
When we Write a Program and in General it is a Series of Statements.
We Expect that It will Run in the Same order as we have Written.
But is Completely Possible that the Compiler or JVM or CPU will Change the Order of Instructions to Drive Some 
Performance out of it.
This is Done in a Way that the Program Semantics Remains Same and Output will Not Change.

Consider the Scenario 

a=3;
b=1;
a=+1;

Actual Conversion look Like 

Load a
Set to 3
Store about

Load b
Set to 1
Store b

Load a
Set to 4
Store a

Here we are Loading a Twice and 
one Performance Improvement could be incrementing the Value would be before setting the Value.

Load a
set to 3
set to 4
Store a

Load b
Set to 1
Store b

 
2.Field Visibility :
--------------------
Field Visibility is Only Applicable in terms of MultiThreaded Applications also Called Concurrent Programming.

A.If we have a Quad Core Processor Machine Generally that have 4 Cores and each core has Set of Registers.
B.Registers are Nothing but a Memory Area which is very Small and is within the Core,
  Stores the Value in the Register and Faster to retrieve from the Register.
C.we Have L1 Cache for each Core i.e Nothing but Memory Area Set a Side For Each Core.
D.We Have L2 Cache which could be Shared between Shared L1 Cache.
E.We Have L3 Cache which could be Shared between Shared L2 Cache.
F.We Have RAM which could be Shared across Cores.

Consider the Example :

			int x=0;
	
			public void writerThread()
			{
				x=1;
			}
			
			public void readerThread()
			{
				int reader=x;
			}			

Here Initially the Value is Stored in the Shared Cache.
Consider Thread T1 Calls the WriterThread() and Thread T2 Calls the ReaderThread().
Thread T1 sits into the Core 1 and Thread T2 Sits into the Core 2.
When the Thread T1  Executes the writerThread(), Value is incremented and updated in the Local Cache of Thread T1.
Similarly When the Thread T2 executes the readerThread(),It Wont get the Updated Value because it is not Updated in the Shared Cache.
It is Completely Possible that x=1 is Never Pushed into the Shared Cache.
This issue is Called Field Visibility Issue.

We Can Resolve the Issue by Using Volatile Key Word.
If the Variable is Volatile,then JVM Ensures that Changes in the Local Cache will be Flushed to the Shared Cache 
so that the Remaining Threads will get The Updated Value.






 




