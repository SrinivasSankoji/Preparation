1.ACID Properties											(TheCodeAlchemist)   			  [01-DEC-2025]  (Done)
2.Optimistic Locking										(Umesh Kumar Yadav)   			  [04-DEC-2025]  (Done)
3.Pesimistic Locking										(Umesh Kumar Yadav)   			  [04-DEC-2025]  (Done)
4.Timeout									                (ChatGPT)   			  		  [09-JAN-2026]  (Done)
5.Handle Deadlock                                           (ChatGPT)   			          [09-JAN-2026]  (Done)
6.@Retryable												()								  [09-JAN-2026]  ()

############################################################### 1.ACID Properties ######################################################################

Database stores, retrieves and manages the data that makes everything work.
But what happens when some thing goes wrong i.e. sudden crash, network error or multiple users trying to update the same information simultaneously.
How does the database prevent chaos and keep your data safe and correct.
That’s where a crucial set of principles known as ACID properties comes in.

ACID principles are the fundamental rules that guarantee reliability and integrity in many database systems.
ACID stands for Atomicity,Consistency,Isolation and Durability.
These properties ensure that even when things go wrong, our data remains accurate, trustworthy, and consistent.

Database transaction is a sequence of operations performed as a single, logical unit of work.
For example, transferring money from one bank account to another involves at least two operations.
Debiting money from one account and crediting it to another. 
For the transfer to be valid, both these operations must succeed. 
If one fails, the entire transaction must fail as if it never happened. 
ACID properties are specifically designed to govern how these transactions behave.

1.Atomicity — All or Nothing
----------------------------
Atomicity indicates that a Database transaction must be treated as a single, individual unit of work.
Think of it as an atomic operation and it cannot be broken down into smaller parts from an external perspective.
A transaction either completes fully, with all its operations successful, or it fails entirely, leaving the database unchanged.
There’s no middle ground.

Example: Consider the scenario of sending money. 
If your account gets debited, but the system crashes before other's account gets credited.
Atomicity ensures the debit from your account is rolled back so that no money vanishes into thin air.

2.Consistency — Staying Valid
-----------------------------
Consistency ensures that every transaction moves the database from one valid state to another valid state.
To ensure the Consistency, Database must always follow all rules.
1.Constraints (Primary Key, Foreign Key, UNIQUE, NOT NULL, CHECK)
2.Business rules
3.Triggers
4.Data type rules

If a transaction violates any rule,The database rejects it and rolls it back so that the database is never left in an invalid state.

Consistency prevents negative balances.
Consistency protected : No orphan orders can exist 
Consistency ensured : Duplicate data prevented

3.Isolation — Working Separately
--------------------------------
When multiple transactions occur concurrently, Isolation ensures they don’t interfere with each other’s intermediate, possibly incomplete, states. 
Each transaction feels like it’s running alone on the database.

Example:Consider the scenario of Booking System.
Isolation ensures that the system processes one request completely, preventing others from double-booking.

4 Durability — Changes That Stick
---------------------------------
Once a transaction has been successfully completed, the changes made to the database are permanent.
The changes will survive any subsequent system crash, power outage or other failures.

Example: Consider the scenario of an online purchase and your order is confirmed. 
Moments later, the server crashes. 
Thanks to Durability, when the system comes back online, order information will still be there.

################################################################# 2.Optimistic Locking ######################################################################

Concurrency Control :
---------------------
Concurrency control is the critical aspect when multiple users or process try to access the shared data simultaneously
and ensures that multiple transactions can execute simultaneously without leading to inconsistent or corrupted data.
The two common strategies for managing concurrency are optimistic locking and pessimistic locking.

Optimistic Locking :
--------------------
Optimistic locking assumes that conflicts are rare. 
Instead of locking the data, it allows multiple transactions to proceed concurrently and checks for conflicts only when saving changes. 
If a conflict is detected (e.g., someone else modified the data), the transaction fails, and the application handles the conflict.

Optimistic locking uses a version field in the database to track changes. 
When an entity is updated, the version is checked to ensure it hasn’t changed since the entity was read.
If the versions don’t match, an OptimisticLockException is thrown.

Use Optimistic Locking when
✅ High concurrency scenarios where conflicts are rare.
✅ Read-heavy applications (e.g., e-commerce product views).
✅ When you want to avoid the overhead of database locks.

Implementation :
----------------

	@Entity
	public class Product {
		@Id
		private Long id;
		private String name;
		private int stock;
		@Version
		private Long version; // Tracks changes
		// Getters and setters
	}
	
The @Version annotation tells JPA to use this field for optimistic locking.

	public interface ProductRepository extends JpaRepository<Product, Long> {
	}
	
	@Service
	public class ProductService {
	
		private final ProductRepository productRepository;
		
		public ProductService(ProductRepository productRepository) {
			this.productRepository = productRepository;
		}
		
		@Transactional
		public void updateStock(Long productId, int newStock) {
			Product product = productRepository.findById(productId)
					.orElseThrow(() -> new RuntimeException("Product not found"));
			product.setStock(newStock);
			productRepository.save(product); // JPA checks version automatically
		}
	}

If two users try to update the same product simultaneously
User A reads the product (version = 1, stock = 10).
User B reads the same product (version = 1, stock = 10).
User A updates the stock to 8 and saves (version increments to 2).
User B tries to update the stock to 7 but fails because the version is now 2, throwing an OptimisticLockException.

Handling the Exception :
------------------------
	
	@Transactional
	public void updateStockWithRetry(Long productId, int newStock) {
		int maxRetries = 3;
		for (int attempt = 1; attempt <= maxRetries; attempt++) {
			try {
				Product product = productRepository.findById(productId)
						.orElseThrow(() -> new RuntimeException("Product not found"));
				product.setStock(newStock);
				productRepository.save(product);
				return;
			} catch (OptimisticLockException e) {
				if (attempt == maxRetries) {
					throw new RuntimeException("Failed to update stock after " + maxRetries + " attempts", e);
				}
				// Retry after a short delay
				try {
					Thread.sleep(100);
				} catch (InterruptedException ie) {
					Thread.currentThread().interrupt();
				}
			}
		}
	}

This code retries the operation up to three times if an OptimisticLockException occurs.

✅ Pros:
High scalability for read-heavy applications.
No database locks, reducing contention.
Simple to implement with JPA.
❌ Cons:
Requires conflict resolution logic (e.g., retries).
Not suitable for high-conflict scenarios.

################################################################# 2.Pesimistic Locking ######################################################################

Pessimistic locking assumes conflicts are likely.
Pessimistic locking locks the data at the database level to prevent other transactions from modifying it until the current transaction is complete.
It’s like reserving a meeting room — only one person can use it at a time. 

When a transaction reads an entity with pessimistic locking, it acquires a lock (e.g., SELECT ... FOR UPDATE).
Other transactions trying to access the same data are blocked until the lock is released.

When to Use Pessimistic Locking :
✅ High-conflict scenarios (e.g., booking a unique resource like a concert ticket).
✅ Write-heavy operations where data integrity is critical.
✅ When you want to avoid retries and ensure exclusive access.


	public interface ProductRepository extends JpaRepository<Product, Long> {
		@Lock(LockModeType.PESSIMISTIC_WRITE)
		@Query("SELECT p FROM Product p WHERE p.id = :id")
		Product findByIdWithPessimisticLock(Long id);
	}
	
The @Lock(LockModeType.PESSIMISTIC_WRITE) ensures the entity is locked for writing.

	@Service
	public class ProductService {
		private final ProductRepository productRepository;

		public ProductService(ProductRepository productRepository) {
			this.productRepository = productRepository;
		}

		@Transactional
		public void updateStockWithPessimisticLock(Long productId, int newStock) {
			Product product = productRepository.findByIdWithPessimisticLock(productId);
			if (product == null) {
				throw new RuntimeException("Product not found");
			}
			product.setStock(newStock);
			productRepository.save(product); // Lock is held until transaction commits
		}
	}
	
User A calls updateStockWithPessimisticLock, locking the product row in the database.
User B tries to access the same product but is blocked until User A’s transaction commits or rolls back.
Once User A’s transaction is complete, User B can proceed.

Types of Pessimistic Locks
PESSIMISTIC_READ: Allows other transactions to read but not write.
PESSIMISTIC_WRITE: Prevents other transactions from reading or writing (exclusive lock).
PESSIMISTIC_FORCE_INCREMENT: Forces an increment of the version field (used with optimistic locking).

✅ Pros:
Ensures data integrity in high-conflict scenarios.
No need for retry logic.
Ideal for critical operations like financial transactions.

❌ Cons:
Can lead to deadlocks If not managed properly.
Reduced scalability due to database locks.
Increased latency for blocked transactions.

Quick Tips for Choosing :
-------------------------
Use optimistic locking for applications with many reads and few writes, like blogs or product catalogs.
Use pessimistic locking for operations where conflicts are common, like booking systems or inventory management.
Combine both in complex apps: optimistic locking for general operations and pessimistic locking for critical updates.


	| Aspect            | Optimistic Locking | Pessimistic Locking |
	| ----------------- | ------------------ | ------------------- |
	| Conflict handling | Detect & fail      | Prevent & block     |
	| DB locks          | ❌ No               | ✅ Yes             |
	| Throughput        | High               | Lower               |
	| Latency           | Low                | Can increase        |
	| Retry logic       | Required           | Not required        |
	| Deadlock risk     | None               | Possible            |
	| Best for          | Read-heavy         | Write-heavy         |
	| Example           | Wallet updates     | Ticket booking      |

####################################################################### 4.Timeout #####################################################################

Scenario :
---------- 
Account row is locked by Transaction A (e.g., long processing).
Transaction B tries SELECT … FOR UPDATE.
Without timeout: Transaction B may block for a long time (bad for APIs).
With timeout: Transaction B fails fast (e.g., within 2 seconds) and you return a clean response like 409 Conflict / 423 Locked.

This is essential for
Ticket booking (high contention)
Inventory reservation
Wallet debit / stock decrement
Any high-conflict write path

There are two way we can implement this.

Option A :
----------

	@Lock(LockModeType.PESSIMISTIC_WRITE)
		@Query("SELECT a FROM Account a WHERE a.id = :id")
		@QueryHints({
			// timeout in milliseconds
			@QueryHint(name = "jakarta.persistence.lock.timeout", value = "2000")
		})
    Optional<Account> findByIdForUpdateWithTimeout(@Param("id") Long id);
	
Value is in milliseconds.
On some databases/dialects it maps cleanly.
On PostgreSQL, behavior may depend on Hibernate dialect/version and driver; it may still block longer in certain setups. If you need certainty, use Option B.

Option B :
----------

	@Service
	public class AccountService {

    private final AccountRepository repository;

    @PersistenceContext
    private EntityManager em;

    public AccountService(AccountRepository repository) {
        this.repository = repository;
    }

    @Transactional
    public AccountResponse updateBalancePessimisticWithPgTimeout(
            Long id,
            BigDecimal newBalance,
            long sleepMs,
            String lockTimeout // e.g. "2s" or "2000ms") {
        try {
            // Applies ONLY for this transaction (best practice).
            em.createNativeQuery("SET LOCAL lock_timeout = :t")
              .setParameter("t", lockTimeout)
              .executeUpdate();

            Account account = repository.findByIdForUpdate(id) // your normal PESSIMISTIC_WRITE method
                    .orElseThrow(() -> new RuntimeException("Account not found"));

            sleep(sleepMs);

            account.setBalance(newBalance);
            return toResponse(account);

        } catch (Exception e) {
            // PostgreSQL will typically throw a lock timeout SQL exception.
            // Hibernate translates it; safest is to map by message/class in one place.
            if (isLockTimeout(e)) {
                throw new AccountLockedException("Account is busy. Retry later.", e);
            }
            throw e;
        }
    }

    private boolean isLockTimeout(Throwable e) {
        // PostgreSQL: "canceling statement due to lock timeout"
        Throwable cur = e;
        while (cur != null) {
            String msg = cur.getMessage();
            if (msg != null && msg.toLowerCase().contains("lock timeout")) return true;
            cur = cur.getCause();
        }
        return false;
    }

############################################################### 5.Handle Deadlock ###############################################################################

A Deadlock occurs when two transactions hold locks that the other needs, creating a circular wait.
Databases resolve this by aborting one transaction.
The primary way to avoid deadlocks is to acquire locks in a consistent order and keep transactions short.
Lock timeouts and retries help reduce impact but do not eliminate deadlocks.
Prefer Optimistic Locking whereever possible.