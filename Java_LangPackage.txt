1.Object Class Introduction											[14-DEC-2020]  (Done)
2.toString()                                                        [14-DEC-2020]  (Done)
3.hashCode()                                                        [14-DEC-2020]  (Done)
4.equals()                                                          [14-DEC-2020]  (Done)
5.clone()                                                           [15-DEC-2020]  (Done)
6.getClass()                                                        [15-DEC-2020]  (Done)
7.finalize()                                                        [15-DEC-2020]  (Done)
8.wait(),notify() and notifyAll()                                   [15-DEC-2020]  (Done)
9.String Class                                                      [16-DEC-2020]  (Done)
10.StringBuffer                                                     [16-DEC-2020]  (Done)
11.StringBuilder                                                    [16-DEC-2020]  (Done)
12.Method Chaining                                                  [16-DEC-2020]  (Done)

*********************************************************************** 1.Object Class Introduction  ***********************************************************************

In Java we have Severla packages like util,sql,io,lang,awt,.net etc.
Without using java.lang package we cannot write single program.

Class Test
{
  main(String[] args)
  {
  System.out.println("Main Method");
  }
}

Here it extends Object Class because Class is a Child Class of Object Class.
System,String are available in lang package.
For writing any Java Program whether it is small or complex most commonly required classes and interfaces are encapsulated into a seperate package 
which is nothing but java.lang package.
It is not required to import java.lang package explicitly because all classes and interfaces are present in this package and are by default available to every Java Program.

Object Class :
--------------
Every Class in Java should be a Child class of Object Class directly or indirectly.
Object Class acts as a root Class for all Java Classes because most commonly required methods for every class are encapsulated into a seperate class nothing but Object Class.

Methods in Object Class :
-------------------------
1.public String toString();
2.public native int hashCode();
3.public boolean equals(Object o);
4.public native Object clone() throws CloneNotSupportedException
5.protected void finalize() throws Throwable
6.public final Class getClass();
7.public final void wait() throws InterruptedException;
8.public final void wait(long ms) throws InterruptedException;
9.public final void wait(long ms,long ns) throws InterruptedException;
10.public final void notify();
11.public final void notifyAll(;

***********************************************************************  2.toString() ***********************************************************************

public String toString() :

We use toString() to get the String representation of an Object.
Whenever we are trying to print an Object reference internally Object class toString() is called and If we want to get the meaningful representation of an Object
we need to override the toString().
Object Class toString() is implemented as below

public String toString()
{
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}

Example :
---------
public class ToStringDemo {
	String name;
	int rollno;
	public ToStringDemo(String name, int rollno) {
		this.name=name;
		this.rollno=rollno;
	}
	public static void main(String[] args) {
		ToStringDemo demo=new ToStringDemo("Srinivas",36);
		System.out.println(demo);
	}
	@Override
	public String toString() {
		return name +"- "+rollno;
	}
}

Note :
------
In Collection Classes,Wrapper Classes,String Class toString() is overridden for meaningful String representation of an Object.
It is highly recomended to override toString() in user defined class also.

*************************************************************************** 3.hashCode()  *****************************************************************************

public native int hashCode() :

hashCode() does not represent an address of an object.
For every object JVM is going to assign one unique number nothing but hashCode and based on hashCode object will be inserted.
JVM internally uses hashCode() while storing data into hashing related data structure like HashTable,HashMap,HashSet etc.
In case of hashing related data items,To search for a particular object is available or not,what is the hashcode of that object,
then directly goes to that object with that hashCode.
Main advantage of Storing objects based on hashCode() is search option will become efficient.

Most successful alogorithm is 

Hashing Search  --> Search algorithm is O(1) because it does not depends on number of elements.
Binay Search    --> Search Algorithm is O(logN/2)
Linear Search   --> Search Algorithm is O(n)

Hashing is the most powerful Search Algorithm.
Object class hashCode() generates hashCode based on address of object if we are not overriding.
Based on our requirement we can override hashCode() in our class.
While overriding hashCode() for every object we have to generate a unique number and is called proper way of overriding.

	@Override
	public int hashCode() {
		return rollno;
	}

If we generate the same hashcode for every object then search operation is disturbed.


Note :
------
Whenever object class toString() is called it will internally call hashCode().
but whenever we are overriding toString() it will not call hashCode().

*************************************************************************** 4.equals()  ***************************************************************************

public booelan equals(Object obj) :

We use equals() to check equality of two objects i.e given two objects are equal or not.
equals() can be used to check the content comparison where as == meant for reference comparison.
In String class equals() is overridden and meant for content comparison.

public class StringDemo {
	public static void main(String[] args) {
		String s1 = new String("Chary");
		String s2 = new String("Chary");
		System.out.println(s1 == s2); //false
		System.out.println(s1.equals(s2)); //true
	}
}

In StringBuffer class equals() is not overridden and object class equals method got executed which is meant for reference comparison.
eventhough content is same itreturns false.

		StringBuffer s3 = new StringBuffer("Chary");
		StringBuffer s4 = new StringBuffer("Chary");
		System.out.println(s3 == s4);//false
		System.out.println(s3.equals(s4));//false
		
Rules to Override equals() :
----------------------------
1.What is the meaning of content comparison i.e we have to check only names or only rollno or we have to check both.
2.If we pass different type of objects equals() should return false but not ClasscastException.
3.If we pass null to the equals(),it should return false but not NullPointerException.
4.Based on which parameter we override equals() same parameter we need to use for hashCode.

public class EqualsDemo {

	String name;
	int rollno;

	public EqualsDemo(String name, int rollno) {
		this.name=name;
		this.rollno=rollno;
	}
	@Override
	public boolean equals(Object obj) {
		try {
		int rollno1 = this.rollno;
		String name1 = this.name;

		EqualsDemo equalsDemo = (EqualsDemo) obj;

		int rollno2 = equalsDemo.rollno;
		String name2 = equalsDemo.name;

		if (name1.equals(name2) && rollno1 == rollno2) {
			return true;
			}
		}
		catch (NullPointerException | ClassCastException  e) {
			return false;
		}
		return false;
	}
	public static void main(String[] args) {

		EqualsDemo e1=new EqualsDemo("Bhaumik",23);
		EqualsDemo e2=new EqualsDemo("Bhaumik",23);
		System.out.println(e1.equals(e2));
	}
}

Relation between == operator and equals() :
-------------------------------------------
Scenario 1:
If r1==r2 returns true then r1.equals(r2) is always true.
Scenario 2:
If r1==r2 is false then r1.equals(r2) may be true or false
Scenario 3:
If r1.equals(r2) is true then r1==r2 may be true or false.
Scenario 4:
If r1.equals(r2) is false then r1==r2 is always false.

Difference between == operator and equals() :
---------------------------------------------
== operator :
1.It is an operator applicable for both object and primitive types.
2.In case of object references == operator always meant for reference comparison.
3.we cannot override == operator for content comparison.
4.To use == operator between object types,there must be some relationship between objects i.e
parent to child or child to parent or same type.

equals method :
1.It is a method applicable only for object types but not for primitive types.
2.equals() present in object class is meant for reference comparison.
3.Based on our requirement we can override equals().
4.If we apply equals() on two different objects we won't get any CTE but returns false.


Note :
------
If the Objects are stored based on hashCode,while storing elements we should follow some rules.
Two different objects must be stored in the same bucket i.e hashCode must be same.
All objects present within the same bukcet need not be same.

***************************************************************************  5.clone()  *****************************************************************************

Once we get the object started performing some operations on the object and because of unwanted operation object got destroyed and it is not recoverable.
To preserve original state as it is we make an object as clonable.
Process of creating exactly duplicate object is called Cloning.
Main purpose of cloning is to maintain backup.

	protected native Object clone()throws CloneNotSupportedException

Rules for Cloning :
-------------------
To perform Cloning an Object must be clonable object.
An object is said to be clonable If the corresponding Class implements Clonable interface.
Clonable interface is present in java.lang package and it does not contain any method.It is a Marker Interface.
If we are trying to perfrom Cloning on Non Clonable objects we get RTE saying CloneNotSupportedExcpetion.

public class CloneDemo implements Cloneable{
	int i=10;
	int j=20;
	public static void main(String[] args) throws CloneNotSupportedException {
		CloneDemo demo=new CloneDemo();
		CloneDemo demo2=(CloneDemo) demo.clone();
		
		System.out.println(demo==demo2);
		
		demo.i=35;
		demo.j=36;
		System.out.println(demo2.i +" - "+demo2.j);
	}
}

Shallow Cloning :
-----------------
Process of creating bitwise copy of an object is called Shallow Cloning.
If the Main object contains only primitive variables,then exactly duplicate objects will be created in the cloned object.
If the Main object contains any reference variables then duplicate object won't be created and reference variable will be created pointing to the old content object.
By using clone object reference if we perform any changes to the cloned object then those changes will be reflected to the original object.
By default Object Class clone() menat for Shallow Cloning.
Shallow Cloning is the best choice if the object contains only primitive variables and not recomended when there are any reference variables.
To overcome this we go for Deep Cloning.

public class Cat {
	int j;
	public Cat(int j) {
		super();
		this.j = j;
	}
}

public class Dog implements Cloneable{
	int i;
	Cat cat;
	public Dog(int i, Cat cat) {
		super();
		this.i = i;
		this.cat = cat;
	}
	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}

public class ShallowCloningDemo {
	public static void main(String[] args) throws CloneNotSupportedException {
		Cat cat=new Cat(20);
		Dog dog1=new Dog(30,cat);
		//Shallow Cloning
		Dog dog2=(Dog)dog1.clone();
		System.out.println("Original Object Values "+dog2.i +" And " +dog2.cat.j);
		dog2.cat.j=40;
		System.out.println("Cloned Object Values "+dog2.i +" And " +dog2.cat.j);
		System.out.println("Cat Value "+cat.j);
	}
}

Deep Cloning :
--------------
Process of creating exactly duplicate independent objects including contained object is called Deep Cloning.
In Deep cloning if the Main object contains any reference variables the corresponding duplicate object will be created.
In Deep Cloning,By using clone object reference if we perform any changes to the main object then those changes will not be reflected to the Main Object.

Note :
------
Shallow cloning is recomende when the object contains only primitive variables.
Deep cloning is required when the object contains reference variables.

*************************************************************************** 6.getClass()  ***************************************************************************

public final Class getClass() :

If we to know the Runtime CLass definition of an object we use getClass().
Connection connection=DriverManager.getConnection("");

To print the Database connection interface vendro implemented ClassName

	connection.getClass().getName();
	

*************************************************************************** 7.finalize()  ***************************************************************************

protected void finalize() throws Throwable :

Just befor destroying an object Garbage Collector always calls finalize() to perform cleanup activities.
Once finalize() completes the execution then Garbage collector destroys the object automatically.

*************************************************************************** 8.wait(),notify() and notifyAll()  *******************************************************

Two Threads can communicate with each other by using above methods.
Inter Thread Communication can be acheived by using these Methods.

*************************************************************************** 9.String Class  ***************************************************************************

Once we create a String object we cannot perform any changes in the existing object.
If we are trying with those changes a new object will be created and it does not have any reference and is eligible for Garbage Collector.
Non changeable behavior is nothin but 

String s=new String("Chary");
s.concat("Software");
System.out.println(s);// Chary

Once we create a StringBuffer object and if we perform any changes,then those changes will be applied on the existing object.
This changeable behavior is nothing but mutability of StringBuffer object.

StringBuffer s1=new StringBuffer("Chary");
s1.append("Software");
System.out.println(s1);//CharySoftware


Note :
------
In String Class equals() is overridden for conetnt comparison Hence if the content is same equals() returns true otherwise returns false.
In StringBuffer Class equals() is not overridden and is meant for reference comaprison.
Due to this even though content is same it returns false.

		String s1=new String("Chary");
		String s2=new String("Chary");
		
		StringBuffer s3=new StringBuffer("Chary");
		StringBuffer s4=new StringBuffer("Chary");
		
		System.out.println(s1.equals(s2)); //true
		System.out.println(s3.equals(s4)); //false

String Object Creation :
------------------------

	String s=new String("Chary");  --> (1)
	String s="Chary";			   --> (2)
	
Incase of (1) Two objects are created one in SCP and another is in Heap and s points to the Heap Object.
Where as of (2) Only one object is created in SCP and s points to the SCP.

Note :
------
Object creation in SCP is always optional.
First JVM will check is there any object already available with required content or not.
If any object is already available then JVM will use the existing object.
If the object is not already available then only a new object will be created.
Garbage Collector is not allowed to access SCP area eventhough object does not have any reference.
All SCP objects will be destroyed automatically at the time of JVM shut down.

Scenario :
----------
	String s1=new String("Chary");
    String s2=new String("Chary");
	String s3="Chary";
	String s4="Chary";
	
Whenever we are using new operator compulsory a new object will be created in Heap Area.
There is no chance of existing Two objects with the same content in SCP where as it is possible to have two objects with the same content on Heap.
Duplicate objects are allowed in Heap but not in SCP.

Example 1 :
-----------
		String s1=new String("Srinivas");
		String s2=s1.concat(" Chary");
		s1=s1.concat(" Sankoji");
		System.out.println(s1);// Srinivas Sankoji
		System.out.println(s2); // Srinivas Chary
		
Note :
------
If an object is required to create at Runtime object is going to create in Heap but not in SCP.

Example 2 :
-----------
		String s1=new String("Summer");
		s1.concat("Winter");
		String s2=s1.concat("Spring");
		s1=s1+"fall";
		System.out.println(s1);// Summerfall
		System.out.println(s2);//SummerSpring

Example 3 :
-----------

		String s1=new String("You Cannot Chaneg Me");
		String s2=new String("You Cannot Chaneg Me");
		System.out.println(s1==s2); // false
		
		String s3="You Cannot Chaneg Me";
		System.out.println(s1==s3); //false
		
		String s4="You Cannot Chaneg Me";
		System.out.println(s3==s4); //true
		
		String s5="You Cannot"+" Chaneg Me";
		System.out.println(s3==s5); //true
		
		String s6="You Cannot";
		String s7=s6.concat(" Chaneg Me");
		System.out.println(s3==s7); //false
		
		final String s8="You Cannot";
		String s9=s8+" Chaneg Me";
		System.out.println(s3==s9); //true
		
		System.out.println(s6==s8); //true
		
Note :
------
If both are constants then compiler is responsible to perform concatenation at the time of compilation only and replaces as one constant.
If one of them is variable at Runtime concatenation is possible.
If the String is declared as final then at the time of compilation only replaces as one constant.

Intern of String Object :
-------------------------
		String s1=new String("Chary");
		String s2=s1;
		String s3=s1.intern();
		System.out.println(s1==s2);//true
		System.out.println(s1==s3);//false

		String s2=s1;

Here s2 points to the Heap Memory.If i want s2 to point to the SCP object we go for intern().
We use intern() to get the corresponding SCP object reference for the given object.

		String s3=s1.intern();
		
Note :
------
Variables are stored inside the stack where as objects are stored inside Heap and SCP.
If an object is going to create at runtime,then object is going to create in Heap and reference points to the Heap object.
If i want reference to be pointed to the SCP object we use intern().

Importance od String Content Pool :
-----------------------------------
If any String object is required to use repeatedly it is not recomended to create a seperate object for each requirement.
Problem in this approach is performance will be impacted and memory utilization will be reduced.
To resolve this problem we can create only one object and we can reuse the same object with multiple references.
we can acheive this by using SCP.

Disadvantage of SCP is If a Single object is referred by multiple references,By using one reference if we change the content of the object,
with those changes a new object will be created and reference will be pointed to newly created object.

Note :
------
String Constants are mostly used where as StringBuffer is rarely used.
String is immutable because of SCP.
All Wrapper classes are Immutable similar to String.

 
		String s1="chary";
		String s2=s1.toUpperCase();
		String s3=s1.toLowerCase();
		String s4=s2.toUpperCase();
		
		System.out.println(s1==s2);//false
		System.out.println(s1==s3);//true
		System.out.println(s2==s4);//true
		
If there is no change in the content no new object will be created both in Heap and SCP.


		String s1="durga";
		String s2=s1.toString();
		String s3="DURGA";
		String s4=s1.toUpperCase();
		String s5=s1.toLowerCase();
		String s6=s5.toLowerCase();
		String s7=s4.toLowerCase();
		String s8=new String("DURGA");
		String s9=new String("durga");
		String s10=s9.toLowerCase();
		
		System.out.println(s1==s2);//true
		System.out.println(s3==s4);//false
		
Creation of our Own Immutable Class :
-------------------------------------
Once we created a String object we cannot perform any changes in the existing object.
If we are trying with those changes a new object will be created .
If there is no change in the content existing object will be reused.
This behavior is nothing but Immutability.

Rules to create a Final Class :
-------------------------------
1.Declare the Class as Final so that it cannotbe extended.
2.Make all the variable/fields as private so that direct access is not allowed.
3.Don't provide setter method for variables.
3.Declare the Constructor as public
4.Declare the static method and verify the object has created or not.
5.use the instance method to create the Object.

final class Immutable {
	private int i;
	public Immutable(int i)
	{
		this.i=i;
	}
	public Immutable modify(int i)
	{
		if (this.i == i) {
			return this;
		} else {
			return new Immutable(i);
		}
	}
	public int getI() {
		return i;
	}
}

public class ImmutableTest {
	public static void main(String[] args) {
		Immutable i1=new Immutable(10);
		Immutable i2=i1.modify(10);
		Immutable i3=i2.modify(100);
		System.out.println(i1==i2);
		System.out.println(i2==i3);
	}
}

final vs Immutability :
-----------------------

final StringBuffer sb=new StringBuffer("Durga");
sb.append(" Software");
System.out.println(sb);
sb=new StringBuffer("Naresh");  // CTE

Oncw e create a StringBuffer object as final we can perform changes in the existing object.
only thing is we cannot reassign the variable.
final is applicable for reference variables where as immutability is applicable for objects.


StringBuffer :
--------------
If the content is fixed and won't change frequently we go for String.
In String for every change a new object will be created.
If the content is not fixed and keep on changing then we go for StringBuffer.
In StringBuffer for every change new object will be created and all changes will be doen in the existing object.
All the methods in StringBuffer are synchronized.
At a Time only one Thread is allowed to operate on the object and performance of the system is going down.
To resolve this we go fro StringBuilder.

StringBuilder :
---------------
Only difference between StringBuffer and StringBUilder is all the methods present in StringBuilder are no synchronized.
StringBuilder is introduced in Java 1.5.

Method Chaining :
-----------------
For most of the methods in String,StringBuffer and StringBuilder returt type is same.
Hence after applying amethod call based on the return type we can apply another method call.












	


		
	

	









