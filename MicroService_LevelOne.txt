{Micro Services Level 1 Concepts :
*********************************
1.Spring Boot Micro Services 								[04-JUL-2019]  (Done)
2.Why So Many Technologies   								[04-JUL-2019]  (Done)
3.Micro Service vs Service Oriented Architecture  			[04-JUL-2019]  (Done)
4.Application Building  									[04-JUL-2019]  (Done)
5.Designing Simple Micro Service  							[04-JUL-2019]  (Done)
6.Creating Starter Micro Service Project  					[10-JUL-2019]  (Done)
7.Building Movie Catalog Service 							[10-JUL-2019]  (Done)
8.Building Movie Info Service 								[10-JUL-2019]  (Done)
9.Configuring Server Port 									[10-JUL-2019]  (Done)
10.Coding Third Service and Communication 					[10-JUL-2019]  (Done)
11.Using Rest Template to Call an External Micro Service 	[10-JUL-2019]  (Done)
12.Using Bean To Create Rest Template 						[10-JUL-2019]  (Done)
13.Using Web Client to Make Rest API Call 					[11-JUL-2019]  (Done)
14.Making a Call to Ratings API 							[12-JUL-2019]  (Done)
15.Avoiding Returning List In API  							[12-JUL-2019]  (Done)
16.Understanding Service Discovery 							[13-JUL-2019]  (Done)
17.Introducing Eureka 										[13-JUL-2019]  (Done)
18.Staring Eureka Server 									[13-JUL-2019]  (Done)
19.Creating Eureka Clients 									[13-JUL-2019]  (Done)
20.Discovering Service Through Eureka  						[13-JUL-2019]  (Done)
21.Client Side Load Balancing								PENDING
22.Recap of Micro Services Level 1							PENDING
23.Creating Multiple Instances								PENDING

Search More :
*************
Client Side Discovery
Server Side Discovery


1.Spring Boot Micro Services :
****************************
It is Different Way of Building Applications where each Module is Independent of Other and Deployed on different Servers.
In Case of Monolith Application All the Functionalities/Modules are Bundled as Single Entity(Jar/War) and deployed on a Single Server.
Both Monolith and Micro Services have the Same Pattern of Writing the Code.

We Create the  Micro Services and Make Them to Communicate With Each Other  
i.e Consider the Big Monolith Application has divided into Smaller Parts and make them to talk with each Other.
Here We Use RestTemplate(Hard Coding the URL),Service Discovery(Eureka Server),WebClient(Hard Coding the URL But calls Asynchronously),
and Eureka Client.
Some of the Common Cloud Platforms Used to Deploy Micro Services are Spring Cloud,AWS,Google Cloud Platform,Azure and so on.
As an End Result we get Cohesive Piece of Code as Response(Mostly J son) from Micro Service.

Challenges While Creating Micro Services are from Where to Start Because There are lots of Technologies that can be used for
Developing Micro Services and one of them is Spring Cloud.
In Spring Cloud there are so Many Buzz Words/Features and also Design Patterns to Implement Micro Services.

2.Why So Many Technologies Involved in MicroServices :
******************************************************
While Converting The Monolith Application into Micro Services we are Solving Some Problems Like Scalability,Modularity of Deployment etc.
While Developing Micro Services we have to check Modularity So that Release Process is Fine
and we have to check Scalability So that there wont be Multiple Copies of Code.

In Case of Monolith Complexity is hidden with in the Application where as in Case of Micro Services Complexity is between the 
Micro Services.

The Problem that Comes with Monolith Applications are Specific to that Module where as the Problems with Micro Service are Generic.
One of  the Example is Load Balancing i.e Here Individual Micro Service is doing what an Application is Supposed to do.
and the Common Problem is Communicating Between the Micro Services.

There are Lot of Frameworks/Technologies to resolve the Common Problems of Micro Services.
Eureka Implements Discovery Pattern.
Hystrix Implements  Circuit Breaker  Pattern.

3.Micro Service and Service Oriented Architecture :
***************************************************
Service Discovery is a Pattern i.e when we have an Application Broken into Micro Services and how Microservice Communicate within each Other
and also How to Discover among them to Communicate With.
Eureka is One of the Technology that Implements Service Discovery Pattern.
Whenever we are Implementing Service Oriented Architecture,We are Building a Service for Re Usability and we don't know where the Service 
is Going to be Used.
Using Service Oriented Architecture,We are Going to Create an Utility and we don't have any Application in Mind.
But In Case of Micro Services we have a Clear Idea of What an Application is Supposed to do and It also can be reused If Requires.
Service Oriented Architecture has lot of Complexity Involved Because they are More Standardized,have an Explicit Contract and 
lot of Precautions.

4.Application Building :
************************
PreRequisites For Micro Services are Spring Boot and Java

Movie Catalog Service and the output is 


{
  id: SrinivasSankoji
  name: Srinivas Chary
  movies :[
	{id:12,name:"ABC",desc:"Good",rating:4},
	{},
	{}
 ]
}

5.Designing Micro Services :
**************************
1.Movie Catalog Service  :
Input :userId 
Output : Movie List with Details
2.Movie Info Service  :
Input : movieId 
Output : Movie Details
3.Rating Data Service :
Input : userId 
Output : Movie Id and Ratings

Designing Micro Service is nothing But Creating a Spring Boot Projects.

6.Creating Spring Boot Micro Service :
**************************************
Create  above Spring Boot Projects in STS.

7.Building the Movie Catalog Service API  :
*******************************************
Create a Controller and Method inside the Controller to return the Response
MovieCatalogController --> getCatalog(userId)

8.Building the Movie Info Service API  :
****************************************
Create a Controller and Method inside the Controller to return the Response
MovieInfoController --> getMovieInfo(movieId)

9.Configuring Server Port  :
****************************
Change the Server Port in application.properties and
change all the Ports of Micro Services

10.Coding Third Service (Building the Rating Data Service API) :
****************************************************************
Create a Controller and Method inside the Controller to return the Response
RatingDataController --> getRating(movieId)

11.Using Rest Template To Call an External Movie Info Service API :
*******************************************************************
To Make call to Movie Info Service from Movie Catalog Service we use Rest Template.
Get the Response Back and UnMarshall it And Create an Object Instance out of it and Send the Response.
Spring Boot Comes with the Client in Built in our Class Path i.e Rest Template
Rest Template is Going to be Deprecated in Later Versions and we can do it By Using Web Client.
Rest Template is Easy Way and Web Client is Some What Hard.
Web Client Requires Reactive Programming.
Programming in Java Language is Synchronous and If we Want to get the data Asynchronously then make the Function Asynchronous.

Create a Rest Template and it has Some Methods.For Example getForObject().
getForObject() accepts URL and returns the String and if we Know the it is going to return an Object Then it UnMarshals the String into Object.

Note: In Micro Services There May be a Chance of Multiple Copies of Same Classes(Model).

RestTemplate restTemplate=new RestTemplate();
Movie movie=restTemplate.getForObject("http://localhost:5002/movies/"+rating.getRating(), Movie.class);

The Problem in this case is We are HardCoding the URL and We have to Discover the Service at Run Time.
Here We have Created RestTemplate Object.
We Can Create a RestTemplate Object once,Annotate with @Bean and reuse it using @Autowired Annotation.

12.Using Bean to Create a Rest Template :
*****************************************

To have Single instance of Rest Template and Used across the Application we use @Bean Annotation.
In The Spring Boot Application Main Class, Create a Method that returns RestTemplate and Mark the Method as @Bean.

13.Using Web Client to Make  API Calls :
****************************************
Rest Template is Going to be Deprecated Soon and Web Client is Going to use to Make the Rest API Calls.
To create a Web Client we use the Class WebClient Builder and to make it available we have to add the dependency in pom.xml.

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-webflux</artifactId>
		</dependency>
		
In case of RestTemplate,we make an API call and Wait for the Response to come i.e Synchronous Communication.
Where as in case of Web Client,it does not wait for the Response and will Do the Other things in Parallel.
Web Client is Present in The Reactive Programming of Spring Boot and deals with Asynchronous Programming.
We Have API calls to make the Calls and do the Other Things.
Once we are done calling the API then call the Lambda i.e whats need to be done once received the Response.

Movie movie=webClientBuilder.build().get().uri("http://localhost:5002/movies/" +rating.getRating())
							.retrieve().bodyToMono(Movie.class).block();

If we are Using block() then it becomes Synchronous.
To get Asynchronous Nature then Return Type of the Service Must be Asynchronous.
							
14.Using Rest Template To Call Ratings Service API :
****************************************************
Lets Create Another Service in RatingDataController that returns List.

@RequestMapping("users/{userId}")

and Remove the Code that return Ratings List in MovieCatalogController that has been Hard Coded.
Here the Problem is the Service is Returning List.

15.Avoiding Returning List In API  :
************************************
Here If The Root Node is List and Not an Object then Consumer  does not know Which Object He has to Use.
We can also Know the List of Object contains what kind of Object it is.

De Serialization is on of the Problem.
If we want to Enhance the Object i.e for Example add on new Variable/Field
we can do that without breaking the Consumers and they don't care about the Extra Field and ignore it.
Similarly If we want to add a new Variable , then in case of Returning List We Cannot add any more and 
we have to change the Entire Structure and breaking the Contract between consumer.
To Resolve This Create an Object and Add The List to an Object and return The Object.

Questions and Answers :
-----------------------
Q: If the Application is being Accessed in Multi Threaded Environment Do We Have any Concurrency Issue.
A: When we deploy Our Application In Servlet Container,Lot of Threads Run in Parallel.
Each Request is Treated as One Thread and it is important that all the Services are Thread Safe.
By Default Rest Template is Thread Safe i.e one call is not going to effect another Call.

Q : Is it Possible To Make a Call to an External API that is Not a Micro Service.
A: Yes (Also By Using RestTemplate)

Q: How do we Handle Security When Communicating Between Micro Services
A: By Using HTTPS,Basic Authentication and So on.

16.Understanding Service Discovery :
************************************
From The above Movie Catalog Service,we are Calling Two Services and the URL is Hard Coded to call The Services.
The Problem is Changing the URL Frequently and Requires Update in the Code.
When We Deploy the Micro Services in The Cloud Environment we get Dynamic URL's and also it keep on Changes.
We also need to do the Load Balancing and that is not Possible if the URL is Hard Coded.
If Particular Micro Service has lot of Demand and we can Spin up to 3 or 4 and in this Case all the URL's will be different 
for the Single Micro Service.
When We push the Code to Heroku,URL gets Changed and we have no Idea about the URL.
Other drawback of Hard Coding URL is When we deploy the Application in Multiple Environments and we have different URL for Each 
Environment.

Because of all these Reasons we have Service Discovery and it is a Pattern.
When we build Micro Services,it needs to talk them to each other and how do they know what do they talk to.
We discover the Target.

Client Side Discovery Server :
------------------------------
Example we have one Client here i.e MovieCatalogService and Two other Services it needs to be Consumed 
i.e MovieInfoService and RatingsDataService
Here how Does the MovieCatalogService discover the other two Services.
Here the Minimum thing required here is URL's and we need to provide a Layer of Abstraction(Discovery Server) 
so that Client Will call the Discovery Server to get the URL and calls the Service.
Here Each Micro Service has to Register with Service Discovery.(Mark the Main Method in Spring Boot Annotated with @EnableEurekaServer)
Here Discovery Server is kind of Phone Book that Maintains all the URL Details of Each Micro Service.
Here The Problem is Client Calls the Discovery Server to get Where Exactly the Micro Service is and 
Once it finds the Address(URL),Then It Calls the Service.
Here Additional Call is Required Instead of Directly calling The Service.
This way of Calling is Called Client Side Discovery.

Server Side Discovery Server :
------------------------------
In Case of Server Side,Discovery Client Says to the Discovery Server to Call the Service.
Here Discovery Server is responsible to call Service and Provide Response to The Client.
Spring Cloud Uses Client Side Discovery Server.

17.Introducing Eureka :
***********************
Technology to Implement Service Discovery Pattern is Eureka.
Eureka is one Of The Project that made open Source by Netflix OSS.
The Other Libraries form Netflix are Ribbon,Hystrix,Zuul etc.
Spring Provides an Abstraction to work with these Libraries.

Steps :
-------
1.We have to Start Eureka Server and We have to Make Individual Micro Service as Eureka Client.
2.Eureka Client Registers With Eureka Server.
3.The Service that is Consuming the Other Service is also Eureka Client.

18.Staring Eureka Server :
**************************
The Way to Create a Eureka Server is to Create a Spring Boot Application.
Add the Dependency Eureka Server in pom.xml.
Add the Annotation @EnableEurekaServer to the Spring Boot Application to make it as Eureka Server.

Add the property Server.port=8761 in application.properties

Start the Application and run the URL http://localhost:8761/ to Start the Eureka Server.
In the UI we have an Option that shows the Instances That are Currently Registered with Eureka Server and we Get UnKnown
Because No Eureka Client is registered with the Server.
While Starting the Application we get the Errors and to Fix those Errors we have to add  values in Properties file :

eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

This Means that Eureka Does not Register With Itself.
Because Every Eureka Server is also a Eureka Client and When it runs it Not Only Provides a Registry and also 
tries to register with other Eureka Server.
We Not Only Have Multiple Instances of Micro Services,we also Have Multiple Instances of Eureka Server and they
Can Register With Each Other.If One Server Fails other Server Will Provide the Services.
Since we Have One Server, Then Stop Behaving as a Client and to and to Make this we added in the Properties File.

19.Creating Eureka Clients :
****************************
Start with MovieInfoService 
Add the Eureka Client Dependency in pom.xml

		<dependency>
    		<groupId>org.springframework.cloud</groupId>
    		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    		<version>2.1.2.RELEASE</version>
		</dependency>

Spring Cloud is a Technology to Build Bunch of Micro Services.
All the Open Source Projects of Netflix became a part of Spring Cloud Family.

Add the Annotation @EnableEurekaClient to Spring Boot Client Application
Start the Eureka Server and it Shows the Unknown Service.
To get The Name of the Application in Eureka Server add the Property in properties File.

		spring.application.name=movie-info-service
		
Now We see the Service is Registered with Discovery Server.
Eureka Client tries to Identify the Discovery Server with default Port and it registers with the Server,But it is always not the Case.
We have to add the Configuration in the Properties File if the Discovery Server port is Changed.
Similarly do the Above Steps For the other two Services i.e movie-catalog-service and ratings-data-service

20.Discovering Service Through Eureka :
***************************************
Now we have Registered all The Services with Discovery Server and we have to consume it.
We have hard coded the URL in movie-catalog-service to call the other Services.
We can make Use of Rest Template or WebClient to call the Service that is registered in Discovery Server by Providing an Annotation
@LoadBalanced (where we Configured the Rest Template)

	@Bean
	@LoadBalanced
	public RestTemplate restTemplate()
	{
		return new RestTemplate();
	}

and change the http://localhost:8761/ to instance name in Service Discovery

The Above code will do the Service Discovery in a Load Balanced Way.
Do the Same Steps for all The Services

21.Client Side Load Balancing :
*******************************



22.Recap of Micro Services Level 1 :
************************************


23.Creating Multiple Instances :
********************************
Add the Properties in the Properties File
https://dzone.com/articles/registering-multiple-local-microservice-instances

server.port=${PORT:0}
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}

To Call the API using Eureka discovery Client 
Click on Eureka discovery URL and add the Rest End Point along with request Mapping.

	http://desktop-rpkudng:6001/catalog/one



